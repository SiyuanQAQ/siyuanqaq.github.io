<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Siyuan&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/7f5c232e160bb21b4c009adb298fdcfa</icon>
  <subtitle>你强归你强，我永不示弱！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hydingsy.github.io/"/>
  <updated>2019-02-09T05:30:00.968Z</updated>
  <id>http://hydingsy.github.io/</id>
  
  <author>
    <name>Siyuan</name>
    <email>294873684@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「HNOI 2010」弹飞绵羊</title>
    <link href="http://hydingsy.github.io/articles/problem-HNOI-2010-Bounce-Sheep/"/>
    <id>http://hydingsy.github.io/articles/problem-HNOI-2010-Bounce-Sheep/</id>
    <published>2019-02-08T16:00:00.000Z</published>
    <updated>2019-02-09T05:30:00.968Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2002" target="_blank" rel="noopener">BZOJ 2002</a></p></blockquote><p>某天，Lostmonkey 发明了一种超级弹力装置，为了在他的绵羊朋友面前显摆，他邀请小绵羊一起玩个游戏。游戏一开始，Lostmonkey 在地上沿着一条直线摆上 $n$ 个装置，每个装置设定初始弹力系数 $k_i$，当绵羊达到第 $i$ 个装置时，它会往后弹 $k_i$ 步，达到第 $i+k_i$ 个装置，若不存在第 $i+k_i$ 个装置，则绵羊被弹飞。绵羊想知道当它从第 $i$ 个装置起步时，被弹几次后会被弹飞。为了使得游戏更有趣，Lostmonkey 可以修改某个弹力装置的弹力系数，任何时候弹力系数均为正整数。</p><p>数据范围：$1\le n\le 2\times 10^5$，$1\le m\le 10^5$</p><a id="more"></a><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="解法-1（LCT）"><a href="#解法-1（LCT）" class="headerlink" title="解法 1（LCT）"></a>解法 1（LCT）</h3><p>首先我们建立一个<strong>虚点</strong> $n+1$，意味着绵羊到达这个点就被弹飞。</p><p>对于每个装置，如果 $i+k_i\le n$，那么我们连边 $(i,i+k_i)$，否则连边 $(i,n+1)$。</p><p>对于修改操作，显然我们需要断开原来的边 $(i,i+k_i)$ 或 $(i,n+1)$，连上新的边 $(i,i+k)$ 或 $(i,n+1)$。由于要<strong>动态连边和删边</strong>，我们可以很自然地想到 $\text{LCT}$。</p><p>接下来我们考虑询问操作。对于询问 $x$，我们要查询的就是 $x$ 到 $n+1$ 这条<strong>链上的边的数量</strong>。于是我们就可以用 $\text{LCT}$ 的 $\text{split}$ 操作，得到 $x$ 到 $n+1$ 这条链的 $\text{Splay}$。我们只要维护 $\text{Splay}$ 中的节点个数，那么答案就是 $size_{n+1}-1$ 了。</p><p><strong>时间复杂度</strong>：$O(m\log n)$</p><h3 id="解法-2（分块）"><a href="#解法-2（分块）" class="headerlink" title="解法 2（分块）"></a>解法 2（分块）</h3><p>考虑 $\sqrt n$ 分块。我们维护每个点它在块内可以<strong>往后跳动的次数</strong>，记为 $cnt_i$；跳动后到达<strong>块内最远点的位置</strong>（如果直接跳出块，那么记录跳动一次到达的位置），记为 $pos_i$。</p><p>对于修改操作，我们对 $x$ 所在块的信息暴力重新计算，复杂度为 $O(\sqrt n)$。</p><p>对于查询操作，我们从 $x$ 往后暴力跳，因为每个块内经过的次数是 $O(1)$ 的，那么复杂度为 $O(\sqrt n)$。</p><p><strong>时间复杂度</strong>：$O(m\sqrt n)$（由于常数问题，分块比 $\text{LCT}$ 跑的要快 QAQ）</p><hr><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法 1"></a>解法 1</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(x) ch[x][0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(x) ch[x][1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k[N],fa[N],ch[N][<span class="number">2</span>],sz[N],st[N];</span><br><span class="line"><span class="keyword">bool</span> rev[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rs(fa[x])==x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ls(fa[x])!=x&amp;&amp;rs(fa[x])!=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    sz[x]=sz[ls(x)]+sz[rs(x)]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rev[x]) &#123;</span><br><span class="line">        <span class="built_in">std</span>::swap(ls(x),rs(x));</span><br><span class="line">        rev[ls(x)]^=<span class="number">1</span>,rev[rs(x)]^=<span class="number">1</span>,rev[x]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y=fa[x],z=fa[y],k=get(x);</span><br><span class="line">    !isroot(y)&amp;&amp;(ch[z][get(y)]=x),fa[x]=z;</span><br><span class="line">    ch[y][k]=ch[x][k^<span class="number">1</span>],fa[ch[x][k^<span class="number">1</span>]]=y;</span><br><span class="line">    ch[x][k^<span class="number">1</span>]=y,fa[y]=x;</span><br><span class="line">    pushup(y),pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u=x,tp=<span class="number">0</span>;</span><br><span class="line">    st[++tp]=u;</span><br><span class="line">    <span class="keyword">while</span>(!isroot(u)) st[++tp]=u=fa[u];</span><br><span class="line">    <span class="keyword">while</span>(tp) pushdown(st[tp--]);</span><br><span class="line">    <span class="keyword">while</span>(!isroot(x)) &#123;</span><br><span class="line">        <span class="keyword">int</span> y=fa[x];</span><br><span class="line">        <span class="keyword">if</span>(!isroot(y)) rotate(get(x)==get(y)?y:x);</span><br><span class="line">        rotate(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;x;x=fa[y=x]) splay(x),rs(x)=y,pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    access(x),splay(x),rev[x]^=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    access(x),splay(x);</span><br><span class="line">    pushdown(x);</span><br><span class="line">    <span class="keyword">while</span>(ls(x)) pushdown(x=ls(x));</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    makeroot(x),access(y),splay(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    makeroot(x);</span><br><span class="line">    <span class="keyword">if</span>(findroot(y)!=x) fa[x]=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    makeroot(x);</span><br><span class="line">    <span class="keyword">if</span>(findroot(y)==x&amp;&amp;fa[x]==y&amp;&amp;!rs(x)) fa[x]=ls(y)=<span class="number">0</span>,pushup(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k[i]);</span><br><span class="line">        link(i,i+k[i]&lt;=n?i+k[i]:n+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);m--;) &#123;</span><br><span class="line">        <span class="keyword">int</span> opt,x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;opt,&amp;x),++x;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">1</span>) &#123;</span><br><span class="line">            split(x,n+<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sz[n+<span class="number">1</span>]<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> v;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;v);</span><br><span class="line">            cut(x,x+k[x]&lt;=n?x+k[x]:n+<span class="number">1</span>);</span><br><span class="line">            link(x,x+v&lt;=n?x+v:n+<span class="number">1</span>);</span><br><span class="line">            k[x]=v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法 2"></a>解法 2</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">5</span>,M=<span class="number">500</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,len,num,bl[N],l[M],r[M],k[N],cnt[N],pos[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    len=<span class="built_in">sqrt</span>(n),num=(n<span class="number">-1</span>)/len+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) bl[i]=(i<span class="number">-1</span>)/len+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;++i) l[i]=(i<span class="number">-1</span>)*len+<span class="number">1</span>,r[i]=i*len;</span><br><span class="line">    r[num]=n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=y;i&gt;=x;--i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j=i+k[i];</span><br><span class="line">        <span class="keyword">if</span>(j&gt;r[bl[i]]) &#123;</span><br><span class="line">            cnt[i]=<span class="number">1</span>,pos[i]=j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cnt[i]=cnt[j]+<span class="number">1</span>,pos[i]=pos[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n) ans+=cnt[x],x=pos[x];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k[i]);</span><br><span class="line">    build();</span><br><span class="line">    modify(<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);m--;) &#123;</span><br><span class="line">        <span class="keyword">int</span> opt,x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;opt,&amp;x),++x;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query(x));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> v;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;v);</span><br><span class="line">            k[x]=v,modify(l[bl[x]],r[bl[x]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=2002&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ 2002&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;某天，Lostmonkey 发明了一种超级弹力装置，为了在他的绵羊朋友面前显摆，他邀请小绵羊一起玩个游戏。游戏一开始，Lostmonkey 在地上沿着一条直线摆上 $n$ 个装置，每个装置设定初始弹力系数 $k_i$，当绵羊达到第 $i$ 个装置时，它会往后弹 $k_i$ 步，达到第 $i+k_i$ 个装置，若不存在第 $i+k_i$ 个装置，则绵羊被弹飞。绵羊想知道当它从第 $i$ 个装置起步时，被弹几次后会被弹飞。为了使得游戏更有趣，Lostmonkey 可以修改某个弹力装置的弹力系数，任何时候弹力系数均为正整数。&lt;/p&gt;
&lt;p&gt;数据范围：$1\le n\le 2\times 10^5$，$1\le m\le 10^5$&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://hydingsy.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="LCT" scheme="http://hydingsy.github.io/tags/LCT/"/>
    
      <category term="分块" scheme="http://hydingsy.github.io/tags/%E5%88%86%E5%9D%97/"/>
    
      <category term="根号分治" scheme="http://hydingsy.github.io/tags/%E6%A0%B9%E5%8F%B7%E5%88%86%E6%B2%BB/"/>
    
      <category term="BZOJ" scheme="http://hydingsy.github.io/tags/BZOJ/"/>
    
      <category term="HNOI" scheme="http://hydingsy.github.io/tags/HNOI/"/>
    
  </entry>
  
  <entry>
    <title>「Luogu 1501」Tree II</title>
    <link href="http://hydingsy.github.io/articles/problem-Luogu-1501-Tree-II/"/>
    <id>http://hydingsy.github.io/articles/problem-Luogu-1501-Tree-II/</id>
    <published>2019-02-08T16:00:00.000Z</published>
    <updated>2019-02-09T08:14:26.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://www.luogu.org/problemnew/show/P1501" target="_blank" rel="noopener">Luogu 1501</a></p></blockquote><p>一棵 $n$ 个点的树，每个点的初始权值为 $1$。对于这棵树有 $q$ 个操作，每个操作为以下四种操作之一：</p><ul><li><code>+ u v c</code>：将 $u$ 到 $v$ 的路径上的点的权值都加上 $c​$。</li><li><code>- u1 v1 u2 v2</code>：将树中原有的边 $(u_1,v_1)$ 删除，加入一条新边 $(u_2,v_2)$，保证操作完之后仍然是一棵树。</li><li><code>* u v c</code>：将 $u$ 到 $v$ 的路径上的点的权值都乘上 $c$。</li><li><code>/ u v</code>：询问u到v的路径上的点的权值和，求出答案对于 $51061$ 的余数。</li></ul><p>数据范围：$1\le n,q\le 10^5$，$0\le c\le 10^4$</p><a id="more"></a><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>其实 $\text{LCT}​$ 中的懒标记下传和线段树中的是一样的，并且都是按照<strong>乘法比加法优先</strong>的原则进行的。</p><p>这里主要提几个坑点：</p><ol><li>我们发现 $\text{mod}=51061$，但是 $\text{mod}^2=2607225721&gt;2147483647$，因此我们要开 $\text{unsigned int}$ 或者 $\text{long long}$。</li><li>题目中没有保证操作都是合法的！也就是说 $\text{link}$ 或 $\text{cut}$ 时可能不合法，需要判断不合法情况。</li></ol><p>时间复杂度：$O(q\log n)$</p><hr><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(x) ch[x][0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(x) ch[x][1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> mod=<span class="number">51061</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,fa[N],ch[N][<span class="number">2</span>],sz[N],st[N];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> val[N],sum[N],add[N],mul[N];</span><br><span class="line"><span class="keyword">bool</span> r[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">getc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'*'</span>) ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rs(fa[x])==x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ls(fa[x])!=x&amp;&amp;rs(fa[x])!=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rev</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::swap(ls(x),rs(x)),r[x]^=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    (sum[x]*=v)%=mod,(val[x]*=v)%=mod,(add[x]*=v)%=mod,(mul[x]*=v)%=mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    (sum[x]+=<span class="number">1L</span>L*v*sz[x]%mod)%=mod,(val[x]+=v)%=mod,(add[x]+=v)%=mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    sz[x]=sz[ls(x)]+sz[rs(x)]+<span class="number">1</span>;</span><br><span class="line">    sum[x]=(sum[ls(x)]+sum[rs(x)]+val[x])%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r[x]) rev(ls(x)),rev(rs(x)),r[x]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(mul[x]!=<span class="number">1</span>) Mul(ls(x),mul[x]),Mul(rs(x),mul[x]),mul[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(add[x]!=<span class="number">0</span>) Add(ls(x),add[x]),Add(rs(x),add[x]),add[x]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y=fa[x],z=fa[y],k=get(x);</span><br><span class="line">    !isroot(y)&amp;&amp;(ch[z][get(y)]=x),fa[x]=z;</span><br><span class="line">    ch[y][k]=ch[x][k^<span class="number">1</span>],fa[ch[x][k^<span class="number">1</span>]]=y;</span><br><span class="line">    ch[x][k^<span class="number">1</span>]=y,fa[y]=x;</span><br><span class="line">    pushup(y),pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u=x,tp=<span class="number">0</span>;</span><br><span class="line">    st[++tp]=u;</span><br><span class="line">    <span class="keyword">while</span>(!isroot(u)) st[++tp]=u=fa[u];</span><br><span class="line">    <span class="keyword">while</span>(tp) pushdown(st[tp--]);</span><br><span class="line">    <span class="keyword">while</span>(!isroot(x)) &#123;</span><br><span class="line">        <span class="keyword">int</span> y=fa[x];</span><br><span class="line">        <span class="keyword">if</span>(!isroot(y)) rotate(get(x)==get(y)?y:x);</span><br><span class="line">        rotate(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;x;x=fa[y=x]) splay(x),rs(x)=y,pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    access(x),splay(x),rev(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    access(x),splay(x);</span><br><span class="line">    pushdown(x);</span><br><span class="line">    <span class="keyword">while</span>(ls(x)) pushdown(x=ls(x));</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    makeroot(x),access(y),splay(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    makeroot(x);</span><br><span class="line">    <span class="keyword">if</span>(findroot(y)!=x) fa[x]=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    makeroot(x);</span><br><span class="line">    <span class="keyword">if</span>(findroot(y)==x&amp;&amp;fa[x]==y&amp;&amp;!rs(x)) fa[x]=ls(y)=<span class="number">0</span>,pushup(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) sz[i]=val[i]=mul[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">        link(u,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch=getc();</span><br><span class="line">        <span class="keyword">int</span> u,v,c;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">'+'</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;c);</span><br><span class="line">            split(u,v),Add(v,c%mod);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">'-'</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v),cut(u,v);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v),link(u,v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">'*'</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;c);</span><br><span class="line">            split(u,v),Mul(v,c%mod);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">'/'</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">            split(u,v);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%u\n"</span>,sum[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.luogu.org/problemnew/show/P1501&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Luogu 1501&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一棵 $n$ 个点的树，每个点的初始权值为 $1$。对于这棵树有 $q$ 个操作，每个操作为以下四种操作之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;+ u v c&lt;/code&gt;：将 $u$ 到 $v$ 的路径上的点的权值都加上 $c​$。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;- u1 v1 u2 v2&lt;/code&gt;：将树中原有的边 $(u_1,v_1)$ 删除，加入一条新边 $(u_2,v_2)$，保证操作完之后仍然是一棵树。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;* u v c&lt;/code&gt;：将 $u$ 到 $v$ 的路径上的点的权值都乘上 $c$。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/ u v&lt;/code&gt;：询问u到v的路径上的点的权值和，求出答案对于 $51061$ 的余数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据范围：$1\le n,q\le 10^5$，$0\le c\le 10^4$&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://hydingsy.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="LCT" scheme="http://hydingsy.github.io/tags/LCT/"/>
    
      <category term="Luogu" scheme="http://hydingsy.github.io/tags/Luogu/"/>
    
  </entry>
  
  <entry>
    <title>「IOI 2007」矿工配餐</title>
    <link href="http://hydingsy.github.io/articles/problem-IOI-2007-Miners/"/>
    <id>http://hydingsy.github.io/articles/problem-IOI-2007-Miners/</id>
    <published>2019-02-08T16:00:00.000Z</published>
    <updated>2019-02-09T05:13:18.607Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1806" target="_blank" rel="noopener">BZOJ 1806</a></p></blockquote><p>现有两个煤矿，每个煤矿都雇用一组矿工。采煤工作很辛苦，所以矿工们需要良好饮食。每当一辆食品车到达煤矿时，矿工们便会产出一定数量的煤。</p><p>$n​$ 辆食品车分为三种类型：肉车，鱼车和面包车。矿工们喜欢变化的食谱。如果提供的食品能够不断变化，他们的产煤量将会增加。每当一个新的食品车到达煤矿时，矿工们就会比较这种新的食品和前两次（或者少于两次，如果前面运送食品的次数不足两次）的食品，并且：</p><ul><li>如果这几次食品车都是同一类型的食品，则矿工们产出一个单位的煤。</li><li>如果这几次食品车中有两种不同类型的食品，则矿工们产出两个单位的煤。</li><li>如果这几次食品车中有三种不同类型的食品，则矿工们产出三个单位的煤。</li></ul><p>预先已知食品车的类型及其被配送的顺序。食品车不能被拆分，每个食品车必须被全部送到一个或另一个煤矿。求出两个煤矿的产煤量的总和的最大值。</p><p>数据范围：$1\le n\le 10^5$</p><a id="more"></a><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>我们定义 $\text{DP}$ 状态 $f_{i,a,b,c,d}$：考虑完第 $i$ 个食品车，第一个煤矿前 $2$ 个食品车为 $a,b$，第二个煤矿前 $2$ 个食品车为 $c,d$。我们可以枚举写一个食品车 $x​$ 到达哪个煤矿，直接转移即可。对于三个食品的贡献，我们可以写一个函数<strong>分类讨论</strong>。</p><p><strong>注意</strong>：$\text{DP}$ 转移过程中，可能会遇到<strong>不合法的状态</strong>（比如 $a=0,b&gt;0$，我们可以通过 $f​$ 数组的值来判断状态是否合法）。</p><p>对于 $\text{DP}$ 的写法，可能递归写起来更简短。但是本题卡空间（$18\text{MB}$）！只能写递推并使用<strong>滚动数组</strong>。</p><p><strong>时间复杂度</strong>：$O(4^4\cdot n)$</p><hr><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><h3 id="递推（MLE）"><a href="#递推（MLE）" class="headerlink" title="递推（MLE）"></a>递推（MLE）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n,p[N],f[N][<span class="number">4</span>][<span class="number">4</span>][<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a&amp;&amp;!b) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!a) <span class="keyword">return</span> b!=c?<span class="number">2</span>:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> a==b&amp;&amp;b==c?<span class="number">1</span>:(a!=b)+(b!=c)+(c!=a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;ans=f[x][a][b][c][d];</span><br><span class="line">    <span class="keyword">if</span>(ans) <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">return</span> ans=<span class="built_in">std</span>::max(dfs(x+<span class="number">1</span>,b,p[x],c,d)+get(a,b,p[x]),dfs(x+<span class="number">1</span>,a,b,d,p[x])+get(c,d,p[x]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%s"</span>,&amp;n,s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) p[i]=s[i]==<span class="string">'M'</span>?<span class="number">1</span>:s[i]==<span class="string">'F'</span>?<span class="number">2</span>:<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dfs(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递推"><a href="#递推" class="headerlink" title="递推"></a>递推</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,a,b) for(int i=a;i&lt;=b;++i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n,f[<span class="number">4</span>][<span class="number">4</span>][<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a&amp;&amp;!b) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!a) <span class="keyword">return</span> b!=c?<span class="number">2</span>:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> a==b&amp;&amp;b==c?<span class="number">1</span>:(a!=b)+(b!=c)+(c!=a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chkmax</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x=x&gt;y?x:y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%s"</span>,&amp;n,s+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    FOR(_,<span class="number">1</span>,n) &#123;</span><br><span class="line">        <span class="keyword">int</span> g[<span class="number">4</span>][<span class="number">4</span>][<span class="number">4</span>][<span class="number">4</span>],o=(s[_]==<span class="string">'M'</span>?<span class="number">1</span>:s[_]==<span class="string">'F'</span>?<span class="number">2</span>:<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">memset</span>(g,<span class="number">-1</span>,<span class="keyword">sizeof</span>(g));</span><br><span class="line">        FOR(i,<span class="number">0</span>,<span class="number">3</span>) FOR(j,<span class="number">0</span>,<span class="number">3</span>) FOR(k,<span class="number">0</span>,<span class="number">3</span>) FOR(l,<span class="number">0</span>,<span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[i][j][k][l]&lt;<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            chkmax(g[j][o][k][l],f[i][j][k][l]+get(i,j,o));</span><br><span class="line">            chkmax(g[i][j][l][o],f[i][j][k][l]+get(k,l,o));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memcpy</span>(f,g,<span class="keyword">sizeof</span>(g));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    FOR(i,<span class="number">0</span>,<span class="number">3</span>) FOR(j,<span class="number">0</span>,<span class="number">3</span>) FOR(k,<span class="number">0</span>,<span class="number">3</span>) FOR(l,<span class="number">0</span>,<span class="number">3</span>) chkmax(ans,f[i][j][k][l]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=1806&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ 1806&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现有两个煤矿，每个煤矿都雇用一组矿工。采煤工作很辛苦，所以矿工们需要良好饮食。每当一辆食品车到达煤矿时，矿工们便会产出一定数量的煤。&lt;/p&gt;
&lt;p&gt;$n​$ 辆食品车分为三种类型：肉车，鱼车和面包车。矿工们喜欢变化的食谱。如果提供的食品能够不断变化，他们的产煤量将会增加。每当一个新的食品车到达煤矿时，矿工们就会比较这种新的食品和前两次（或者少于两次，如果前面运送食品的次数不足两次）的食品，并且：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果这几次食品车都是同一类型的食品，则矿工们产出一个单位的煤。&lt;/li&gt;
&lt;li&gt;如果这几次食品车中有两种不同类型的食品，则矿工们产出两个单位的煤。&lt;/li&gt;
&lt;li&gt;如果这几次食品车中有三种不同类型的食品，则矿工们产出三个单位的煤。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;预先已知食品车的类型及其被配送的顺序。食品车不能被拆分，每个食品车必须被全部送到一个或另一个煤矿。求出两个煤矿的产煤量的总和的最大值。&lt;/p&gt;
&lt;p&gt;数据范围：$1\le n\le 10^5$&lt;/p&gt;
    
    </summary>
    
    
      <category term="动态规划" scheme="http://hydingsy.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="BZOJ" scheme="http://hydingsy.github.io/tags/BZOJ/"/>
    
      <category term="IOI" scheme="http://hydingsy.github.io/tags/IOI/"/>
    
  </entry>
  
  <entry>
    <title>「Codeforces 1110E」Magic Stones</title>
    <link href="http://hydingsy.github.io/articles/problem-Codeforces-1110E-Magic-Stones/"/>
    <id>http://hydingsy.github.io/articles/problem-Codeforces-1110E-Magic-Stones/</id>
    <published>2019-02-07T16:00:00.000Z</published>
    <updated>2019-02-08T02:34:55.122Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://codeforces.com/contest/1110/problem/E" target="_blank" rel="noopener">Codeforces 1110E</a></p></blockquote><p>Grigory 有 $n​$ 个魔法石，标号为 $1​$ 到 $n​$。第 $i​$ 个石头的电荷量为 $c_i​$。有时 Grigory 会选择一些内部的石头（第 $i​$ 个石头满足 $2\le i\le n-1​$），使得它失去自己的电荷，得到相邻的石头的电荷。也就是说，它的电荷 $c_i​$ 变为 $c_i’=c_{i+1}+c_{i-1}-c_i​$。</p><p>Grigory 的朋友 Andrew 也有 $n$ 个电荷量为 $t_i$ 的石头。Grigory 想知道是否存在一系列操作，将 Grigory 的石头的电荷量和 Andrew 的石头的电荷量相同。如果存在操作，那么输出 <code>Yes</code> 否则输出 <code>No</code>。</p><p>数据范围：$2\le n\le 10^5​$，$0\le c_i,t_i\le 2\times 10^9​$</p><a id="more"></a><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>我们定义<strong>差分数组</strong> $d_i=c_{i+1}-c_i$，如果我们此时对 $c_i$ 进行操作，即 $c_i’=c_{i+1}+c_{i-1}-c_i$，那么我们将得到：</p><ul><li>$d_{i-1}’=c_i’-c_{i-1}=(c_{i+1}+c_{i-1}-c_i)-c_{i-1}=c_{i+1}-c_i=d_i$</li><li>$d_i’=c_{i+1}-c_i’=c_{i+1}-(c_{i+1}+c_{i-1}-c_i)=c_i-c_{i-1}=d_{i-1}$</li></ul><p>也就是说，我们对 $c_i$ 进行一次操作，在差分数组中的体现，只不过是将 $d_{i-1}$ 和 $d_i$ 的值<strong>交换</strong>了。这意味着，如果我们把差分数组看做是<strong>无序</strong>的，那么它将是永远<strong>不会变化</strong>的。</p><p>因此，我们只要把 $c$ 和 $t$ 数组的差分数组求出来，如果排序后两个数组<strong>完全相同</strong>那么意味着有解（注意：我们首先要判断 $c_1=t_1,c_n=t_n$）；否则就是无解。</p><p><strong>时间复杂度</strong>：$O(n\log n)$</p><hr><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;b[i]);</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">1</span>]!=b[<span class="number">1</span>]||a[n]!=b[n]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"No"</span>),<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i) a[i]-=a[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i) b[i]-=b[i<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">std</span>::sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>),<span class="built_in">std</span>::sort(b+<span class="number">1</span>,b+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(a[i]!=b[i]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"No"</span>),<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Yes"</span>),<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://codeforces.com/contest/1110/problem/E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Codeforces 1110E&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Grigory 有 $n​$ 个魔法石，标号为 $1​$ 到 $n​$。第 $i​$ 个石头的电荷量为 $c_i​$。有时 Grigory 会选择一些内部的石头（第 $i​$ 个石头满足 $2\le i\le n-1​$），使得它失去自己的电荷，得到相邻的石头的电荷。也就是说，它的电荷 $c_i​$ 变为 $c_i’=c_{i+1}+c_{i-1}-c_i​$。&lt;/p&gt;
&lt;p&gt;Grigory 的朋友 Andrew 也有 $n$ 个电荷量为 $t_i$ 的石头。Grigory 想知道是否存在一系列操作，将 Grigory 的石头的电荷量和 Andrew 的石头的电荷量相同。如果存在操作，那么输出 &lt;code&gt;Yes&lt;/code&gt; 否则输出 &lt;code&gt;No&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;数据范围：$2\le n\le 10^5​$，$0\le c_i,t_i\le 2\times 10^9​$&lt;/p&gt;
    
    </summary>
    
    
      <category term="结论" scheme="http://hydingsy.github.io/tags/%E7%BB%93%E8%AE%BA/"/>
    
      <category term="差分" scheme="http://hydingsy.github.io/tags/%E5%B7%AE%E5%88%86/"/>
    
      <category term="Codeforces" scheme="http://hydingsy.github.io/tags/Codeforces/"/>
    
  </entry>
  
  <entry>
    <title>「Codeforces 1110C」Meaningless Operations</title>
    <link href="http://hydingsy.github.io/articles/problem-Codeforces-1110C-Meaningless-Operations/"/>
    <id>http://hydingsy.github.io/articles/problem-Codeforces-1110C-Meaningless-Operations/</id>
    <published>2019-02-07T16:00:00.000Z</published>
    <updated>2019-02-11T12:34:36.391Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://codeforces.com/contest/1110/problem/C" target="_blank" rel="noopener">Codeforces 1110C</a></p></blockquote><p>定义函数 $f(a)$ 的值为：</p><script type="math/tex; mode=display">f(a)=\max_{0<b<a}\gcd(a\oplus b,a\ \&\ b)</script><p>给出 $q$ 个询问，每个询问为一个整数 $a_i$。你需要对于每个询问，求出 $f(a_i)$  的值。</p><p>数据范围：$1\le q\le 10^3$，$2\le a_i\le 2^{25}-1$</p><a id="more"></a><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>首先我们可以找到 $f(a)$ 的上界：找到满足 $2^x-1\ge a$ 的最小的 $x$，那么上界就是 $2^x-1$。我们考虑能够<strong>构造</strong>出这个上界。</p><p>我们发现，$\gcd(0,x)=x$，我们用 $\text{bit}_{a,i}$ 表示 $a$ 的第 $i$ 位。构造方式如下：</p><ul><li>当 $\text{bit}_{a,i}=0$ 时，$\text{bit}_{b,i}=1$。</li><li>当 $\text{bit}_{a,i}=1$ 时，$\text{bit}_{b,i}=0$。</li></ul><p>通过如上方式，我们可以使得 $a\oplus b=2^x-1$，使得 $a\ \&amp;\ b=0$，这样一来我们就构造出了上界。</p><p>但是考虑特殊情况：当 $a=2^x-1$ 时，这样构造得到的 $b=0$，不满足条件。那么我们考虑<strong>异或</strong>和<strong>与</strong>的本质，发现当 $a$ 的所有二进制位都是 $1$ 时，$a\oplus b$ 相当于在 $a$ 中消去 $b$ 的二进制位为 $1$ 的位，$a\ \&amp;\ b$ 相当于在 $a$ 中保留 $b$ 的二进制位为 $1$ 的位。那么我们有：</p><script type="math/tex; mode=display">\gcd(a\oplus b,a\ \&\ b)=\gcd(a-b,b)=\gcd(a,b)</script><p>经过分析，我们可以得到：当 $b$ 为 $a$ 的<strong>最大因子</strong>的时候，$\gcd(a,b)$ 的值最大（可以直接暴力<strong>预处理</strong>出所有 $a=2^x-1$ 的函数值）。</p><p><del>当然这题的最好做法当然是打表啦！</del></p><p><strong>时间复杂度</strong>：$O(q\log a_i)$（预处理）或 $O(q\sqrt{a_i})$（枚举因子）</p><hr><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">3</span>) <span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">7</span>) <span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">15</span>) <span class="built_in">puts</span>(<span class="string">"5"</span>);</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">31</span>) <span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">63</span>) <span class="built_in">puts</span>(<span class="string">"21"</span>);</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">127</span>) <span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">255</span>) <span class="built_in">puts</span>(<span class="string">"85"</span>);</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">511</span>) <span class="built_in">puts</span>(<span class="string">"73"</span>);</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1023</span>) <span class="built_in">puts</span>(<span class="string">"341"</span>);</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">2047</span>) <span class="built_in">puts</span>(<span class="string">"89"</span>);</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">4095</span>) <span class="built_in">puts</span>(<span class="string">"1365"</span>);</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">8191</span>) <span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">16383</span>) <span class="built_in">puts</span>(<span class="string">"5461"</span>);</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">32767</span>) <span class="built_in">puts</span>(<span class="string">"4681"</span>);</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">65535</span>) <span class="built_in">puts</span>(<span class="string">"21845"</span>);</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">131071</span>) <span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">262143</span>) <span class="built_in">puts</span>(<span class="string">"87381"</span>);</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">524287</span>) <span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1048575</span>) <span class="built_in">puts</span>(<span class="string">"349525"</span>);</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">2097151</span>) <span class="built_in">puts</span>(<span class="string">"299593"</span>);</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">4194303</span>) <span class="built_in">puts</span>(<span class="string">"1398101"</span>);</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">8388607</span>) <span class="built_in">puts</span>(<span class="string">"178481"</span>);</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">16777215</span>) <span class="built_in">puts</span>(<span class="string">"5592405"</span>);</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">33554431</span>) <span class="built_in">puts</span>(<span class="string">"1082401"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);n--;) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>,tp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">24</span>;++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(x&amp;(<span class="number">1</span>&lt;&lt;i)) tp=i,++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt==tp+<span class="number">1</span>) solve(x);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,(<span class="number">1</span>&lt;&lt;(tp+<span class="number">1</span>))<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://codeforces.com/contest/1110/problem/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Codeforces 1110C&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;定义函数 $f(a)$ 的值为：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
f(a)=\max_{0&lt;b&lt;a}\gcd(a\oplus b,a\ \&amp;\ b)&lt;/script&gt;&lt;p&gt;给出 $q$ 个询问，每个询问为一个整数 $a_i$。你需要对于每个询问，求出 $f(a_i)$  的值。&lt;/p&gt;
&lt;p&gt;数据范围：$1\le q\le 10^3$，$2\le a_i\le 2^{25}-1$&lt;/p&gt;
    
    </summary>
    
    
      <category term="贪心" scheme="http://hydingsy.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="位运算" scheme="http://hydingsy.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="Codeforces" scheme="http://hydingsy.github.io/tags/Codeforces/"/>
    
      <category term="打表" scheme="http://hydingsy.github.io/tags/%E6%89%93%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>「算法笔记」Link-Cut Tree</title>
    <link href="http://hydingsy.github.io/articles/algorithm-Link-Cut-Tree/"/>
    <id>http://hydingsy.github.io/articles/algorithm-Link-Cut-Tree/</id>
    <published>2019-02-07T16:00:00.000Z</published>
    <updated>2019-02-15T10:37:35.427Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">动态树问题，即要求我们维护一个由若干棵子结点无序的有根树组成的森林。要求这个数据结构支持对树的分割、合并，对某个点到它的根的路径的某些操作。</blockquote><a id="more"></a><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>$\text{Splay}​$：博客文章详见<a href="https://orzsiyuan.com/articles/algorithm-Splay-1/" target="_blank" rel="noopener">「算法笔记」Splay 维护二叉查找树</a></p><hr><h2 id="链剖分"><a href="#链剖分" class="headerlink" title="链剖分"></a>链剖分</h2><h3 id="重链剖分"><a href="#重链剖分" class="headerlink" title="重链剖分"></a>重链剖分</h3><p>我们所谓的<strong>树剖</strong>，就是重链剖分的常用称呼。对于每个点，我们选择其最大的子树，将这条连边划分为<strong>重边</strong>，连向其余子树的边化为分<strong>轻边</strong>。</p><h3 id="长链剖分"><a href="#长链剖分" class="headerlink" title="长链剖分"></a>长链剖分</h3><p>对每个点选择其深度最大的儿子作为重儿子，连边即为<strong>重边</strong>，其余作为轻儿子，连边即为<strong>轻边</strong>。由此得到了若干条互不相交的长链。</p><h3 id="实链剖分"><a href="#实链剖分" class="headerlink" title="实链剖分"></a>实链剖分</h3><p>同样将某一个儿子的连边为<strong>实边</strong>，其余儿子的连边为<strong>虚边</strong>。只不过虚实是可以<strong>动态变化</strong>的，因此我们需要用更高级、更灵活的数据结构 $\text{Splay}$ 来维护每一条<strong>实链</strong>。</p><p>基于性质更加优秀的实链剖分，$\text{LCT}$（$\text{Link-Cut Tree}$）应运而生。</p><hr><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol><li><p>每一个 $\text{Splay}$ 维护的是一条<strong>从上到下</strong>在原树中<strong>深度严格递增</strong>的<strong>链</strong>，且<strong>中序遍历</strong> $\text{Splay}$ 得到的点的深度严格递增。</p></li><li><p>每个节点包含且仅包含在一个 $\text{Splay}$ 中。</p></li><li><p>边分为且仅分为<strong>实边</strong>和<strong>虚边</strong>，所有实边包含在 $\text{Splay}$ 中，而虚边总是由一棵 $\text{Splay}$ 指向另一个节点（指向该 $\text{Splay}​$ 中序遍历最靠前的节点在原树中的父亲）。</p><p>为了保持树的形态，我们要让它到其他儿子的边变为虚边，由对应儿子所属的 $\text{Splay}​$ 的根节点的父亲指向该点，而该点不能直接访问该儿子（认父不认子）。</p></li></ol><hr><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>我们首先认识一下 $\text{LCT}$ 支持的操作类型：</p><ul><li>查询、修改链上的信息。</li><li>对某一个树进行换根操作。</li><li>动态连边、删边。</li><li>动态维护连通性。</li><li><del>其他神奇的操作。</del></li></ul><h3 id="access-x"><a href="#access-x" class="headerlink" title="access(x)"></a>access(x)</h3><p><strong>功能</strong>：将根节点到 $x$ 上的边都变为实边。</p><p>假如我们有一棵树，实边和虚边一开始是这样划分的（图片引用于 <a href="https://wenku.baidu.com/view/75906f160b4e767f5acfcedb" target="_blank" rel="noopener">YangZhe 的论文</a> 和 <a href="https://www.cnblogs.com/flashhu/p/8324551.html" target="_blank" rel="noopener">FlashHu 的博客</a>）：</p><p><img src="/images/Link-Cut-Tree_1.png" alt=""></p><p>那么构成的 $\text{LCT}$ 可能长成这样（绿框中为一个 $\text{Splay}​$，<strong>形态不唯一</strong>，但是只要满足中序遍历按照深度递增，对结果就没有影响）：</p><p><img src="/images/Link-Cut-Tree_2.png" alt=""></p><p>现在我们要执行 $\text{access}(N)$ 操作，把 $A\sim N$ 路径上的边都变成<strong>实边</strong>，形成一个 $\text{Splay}$。由于性质 $2$，那么肯定<strong>有些实边要变为虚边</strong>。我们可以得到这样的重新划分：</p><p><img src="/images/Link-Cut-Tree_3.png" alt=""></p><p>那么如何实现 $\text{access}(N)$ 的操作呢？</p><p>我们从 $N$ 这个点一步步<strong>往上</strong>进行操作。首先把 $N$ 进行 $\text{splay}$ 操作，使得它变成这个 $\text{Splay}​$ 中的<strong>根节点</strong>。</p><p>为了满足性质 $2​$，那么 $(N,O)​$ 这条边需要从实边变为虚边。由于 $O​$ 的深度比 $N​$ 大，在 $\text{Splay}​$ 中的表现形式就是 $O​$ 在 $N​$ 的<strong>右子树</strong>中，那么直接把 $N​$ 的<strong>右儿子变为空</strong>（认父不认子）。得到如图形式：</p><p><img src="/images/Link-Cut-Tree_4.png" alt=""></p><p>接着我们把 $N$ 所属的 $\text{Splay}$ 的<strong>虚边</strong>指向的 $I$（在原树上 $I$ 是 $L$ 的父亲）也转到所属的 $\text{Splay}$ 的根节点，那么边 $(I,K)$ 边需要变为虚边，同时去掉右儿子。这时候把 $(I,N)​$ 变成实边即可。</p><p><img src="/images/Link-Cut-Tree_5.png" alt=""></p><p>接下来同理进行一系列操作：</p><p>由于 $I$ 所属 $\text{Splay}$ 指向 $H$，故 $\text{splay(H)}$，将 $H$ 的右儿子变为 $I​$。</p><p><img src="/images/Link-Cut-Tree_6.png" alt=""></p><p>由于 $H$ 所属 $\text{Splay}$ 指向 $A$，故 $\text{splay(A)}$，将 $A$ 的右儿子变为 $H$。</p><p><img src="/images/Link-Cut-Tree_7.png" alt=""></p><p>至此，$A\sim N$ 的路径上的边都变成实边了，而总结整个过程，我们发现只有如下 $4$ 步：</p><ol><li>将节点转到所属 $\text{Splay}$ 的根。</li><li>将其右儿子删除，变为删一个 $\text{Splay}​$ 的根节点。</li><li>更新节点信息。</li><li>将当前点变为虚边所指的父亲，转到步骤 $1$。</li></ol><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;x;x=fa[y=x]) splay(x),ch[x][<span class="number">1</span>]=y,pushup(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="makeroot-x"><a href="#makeroot-x" class="headerlink" title="makeroot(x)"></a>makeroot(x)</h3><p><strong>功能</strong>：将 $x​$ 成为原树的根节点。</p><p>我们首先进行 $\text{access}(x)$ 操作，这样一来我们得到了一条从根节点到 $x$ 的链，$x$ 一定是这个 $\text{Splay}$ 中深度最大的点。根据性质 $1$，在这个 $\text{Splay}$ 中 $x$ 一定没有右子树（没有比 $x$ 深度更大的点）。我们直接<strong>翻转</strong>整个 $\text{Splay}$，使得所有点的深度都倒过来，$x$ 就没有了左子树，成为了<strong>深度最小</strong>的点，也就成为了根节点。注意要给这个 $\text{Splay}​$ 打上<strong>翻转懒标记</strong>。</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    access(x),splay(x),rev(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="findroot-x"><a href="#findroot-x" class="headerlink" title="findroot(x)"></a>findroot(x)</h3><p><strong>功能</strong>：找到 $x$ 所在的树的根，主要用来判断两点之间的连通性。</p><p>我们利用这样一个性质：一棵树的根节点一定是<strong>深度最小的点</strong>。那么我们先用 $\text{access}(x)$ 把 $x$ 先和根连成一条链，然后用 $\text{splay}(x)$ 将 $x$ 旋转到 $\text{Splay}$ 的根节点。之后根节点一定是 $x​$ 不断<strong>往左走</strong>得到的（越往左深度越小）。注意在往左走的过程中一定要<strong>下传标记</strong>！</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    access(x),splay(x);</span><br><span class="line">    pushdown(x);</span><br><span class="line">    <span class="keyword">while</span>(ch[x][<span class="number">0</span>]) pushdown(x=ch[x][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="split-x-y"><a href="#split-x-y" class="headerlink" title="split(x,y)"></a>split(x,y)</h3><p><strong>功能</strong>：得到 $x$ 到 $y$ 的一条路径，其中 $y$ 是为路径所在 $\text{Splay}$ 的根节点。</p><p>我们可以通过上面的函数直接写出 $\text{split}$ 函数。先把 $x$ 作为根节点，然后得到根节点到 $y$ 的链，将 $y$ 旋转到 $\text{Splay}$ 的根即可。</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    makeroot(x),access(y),splay(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="link-x-y"><a href="#link-x-y" class="headerlink" title="link(x,y)"></a>link(x,y)</h3><p><strong>功能</strong>：连一条虚边 $(x,y)$（如果已经连通则不操作）。</p><p>我们将 $x$ 变成原树的根，然后将 $x$ 的<strong>父节点</strong>直接设为 $y$ 即可。因为在 $\text{findroot}(y)$ 中已经执行了 $\text{access}(y)$ 和 $\text{splay}(y)$，则 $y$ 成为了所在 $\text{Splay}​$ 的根节点。</p><p>连通性的检查：$x$ 成为根节点后，如果 $\text{findroot}(y)=x$ 则说明 $x,y$ 连通。</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    makeroot(x);</span><br><span class="line">    <span class="keyword">if</span>(findroot(y)!=x) fa[x]=y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="cut-x-y"><a href="#cut-x-y" class="headerlink" title="cut(x,y)"></a>cut(x,y)</h3><p><strong>功能</strong>：切断边 $(x,y)$（如果没有边则不进行操作）</p><p>首先我们把 $x$ 变成根节点，如果存在边 $(x,y)$，那么 $x$ 的深度一定比 $y$ 浅，则 $x$ 是 $y$ 的<strong>左儿子</strong>，$y$ 是 $x​$ 的<strong>父节点</strong>。</p><p>但是如果不保证操作合法呢？我们需要很多条件来判断 $(x,y)$ 这条边是不存在的。不存在边 $(x,y)​$ 的条件（满足一者即可）：</p><ol><li>如果 $x,y$ <strong>不在同一棵树内</strong>，那么不存在边。</li><li>如果 $x$ 的<strong>父亲</strong>不是 $y$，则意味着 $x,y$ 虽然在同一个 $\text{Splay}$ 中却没有连边。</li><li>如果 $x$ 的<strong>右子树非空</strong>，那么意味着以 $y$ 为根的中序遍历中 $x$ 和 $y​$ 不相邻，则没有边相连。</li></ol><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    makeroot(x);</span><br><span class="line">    <span class="keyword">if</span>(findroot(y)==x&amp;&amp;fa[x]==y&amp;&amp;!ch[x][<span class="number">1</span>]) fa[x]=ch[y][<span class="number">0</span>]=<span class="number">0</span>,pushup(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h3 id="rotate-x"><a href="#rotate-x" class="headerlink" title="rotate(x)"></a>rotate(x)</h3><p><strong>功能</strong>：将 $x​$ 向上旋转。</p><p>和普通 $\text{Splay}​$ 不同的是，我们在修改 $x​$ 的祖父的儿子时，必须判断 $x​$ 的父亲是否为所在 $\text{Splay}​$ 的根。因为如果不判断的话，$0​$ 的儿子就会被定义为 $x​$，而 $x​$ 则永远不可能成为根节点，在 $\text{splay}​$ 函数中将会无限循环。</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y=fa[x],z=fa[y],k=get(x);</span><br><span class="line">    !isroot(y)&amp;&amp;(ch[z][get(y)]=x),fa[x]=z;</span><br><span class="line">    ch[y][k]=ch[x][k^<span class="number">1</span>],fa[ch[x][k^<span class="number">1</span>]]=y;</span><br><span class="line">    ch[x][k^<span class="number">1</span>]=y,fa[y]=x;</span><br><span class="line">    pushup(y),pushup(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="splay-x"><a href="#splay-x" class="headerlink" title="splay(x)"></a>splay(x)</h3><p><strong>功能</strong>：将 $x​$ 旋转到 $\text{Splay}​$ 的根节点。</p><p>由于 $\text{LCT}$ 中对 $\text{Splay}$ 有翻转操作，那么我们在 $\text{splay}(x)$ 之前，必须将 $x$ 的所有祖先的<strong>标记下放</strong>，我们用一个栈来保存所有的祖先并依次下放标记。</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u=x,tp=<span class="number">0</span>;</span><br><span class="line">    st[++tp]=u;</span><br><span class="line">    <span class="keyword">while</span>(!isroot(u)) st[++tp]=u=fa[u];</span><br><span class="line">    <span class="keyword">while</span>(tp) pushdown(st[tp--]);</span><br><span class="line">    <span class="keyword">while</span>(!isroot(x)) &#123;</span><br><span class="line">        <span class="keyword">int</span> y=fa[x];</span><br><span class="line">        <span class="keyword">if</span>(!isroot(y)) rotate(get(x)==get(y)?y:x);</span><br><span class="line">        rotate(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>以<a href="https://www.luogu.org/problemnew/show/P3690" target="_blank" rel="noopener">「Luogu 3690」Link Cut Tree</a> 为例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(x) ch[x][0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(x) ch[x][1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,fa[N],ch[N][<span class="number">2</span>],val[N],sum[N],st[N];</span><br><span class="line"><span class="keyword">bool</span> r[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rs(fa[x])==x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ls(fa[x])!=x&amp;&amp;rs(fa[x])!=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rev</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    r[x]^=<span class="number">1</span>,<span class="built_in">std</span>::swap(ls(x),rs(x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    sum[x]=sum[ls(x)]^sum[rs(x)]^val[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r[x]) rev(ls(x)),rev(rs(x)),r[x]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y=fa[x],z=fa[y],k=get(x);</span><br><span class="line">    !isroot(y)&amp;&amp;(ch[z][get(y)]=x),fa[x]=z;</span><br><span class="line">    ch[y][k]=ch[x][k^<span class="number">1</span>],fa[ch[x][k^<span class="number">1</span>]]=y;</span><br><span class="line">    ch[x][k^<span class="number">1</span>]=y,fa[y]=x;</span><br><span class="line">    pushup(y),pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u=x,tp=<span class="number">0</span>;</span><br><span class="line">    st[++tp]=u;</span><br><span class="line">    <span class="keyword">while</span>(!isroot(u)) st[++tp]=u=fa[u];</span><br><span class="line">    <span class="keyword">while</span>(tp) pushdown(st[tp--]);</span><br><span class="line">    <span class="keyword">while</span>(!isroot(x)) &#123;</span><br><span class="line">        <span class="keyword">int</span> y=fa[x];</span><br><span class="line">        <span class="keyword">if</span>(!isroot(y)) rotate(get(x)==get(y)?y:x);</span><br><span class="line">        rotate(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;x;x=fa[y=x]) splay(x),rs(x)=y,pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    access(x),splay(x),rev(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    access(x),splay(x);</span><br><span class="line">    pushdown(x);</span><br><span class="line">    <span class="keyword">while</span>(ls(x)) pushdown(x=ls(x));</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    makeroot(x),access(y),splay(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    makeroot(x);</span><br><span class="line">    <span class="keyword">if</span>(findroot(y)!=x) fa[x]=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    makeroot(x);</span><br><span class="line">    <span class="keyword">if</span>(findroot(y)==x&amp;&amp;fa[x]==y&amp;&amp;!rs(x)) fa[x]=ls(y)=<span class="number">0</span>,pushup(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;val[i]);</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> opt,x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;opt,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">0</span>) split(x,y),<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum[y]);</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">1</span>) link(x,y);</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">2</span>) cut(x,y);</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">3</span>) splay(x),val[x]=y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><blockquote><p>本文题单摘录自 <a href="https://www.cnblogs.com/flashhu/p/9498517.html" target="_blank" rel="noopener">FlashHu 的博客</a></p></blockquote><h3 id="维护链信息"><a href="#维护链信息" class="headerlink" title="维护链信息"></a>维护链信息</h3><ul><li>&#9745; <a href="https://www.luogu.org/problemnew/show/P3690" target="_blank" rel="noopener">「Luogu 3690」Link Cut Tree</a>（<a href="https://orzsiyuan.com/articles/algorithm-Link-Cut-Tree/" target="_blank" rel="noopener">题解</a>）</li><li>&#9745; <a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2002" target="_blank" rel="noopener">「HNOI 2010」弹飞绵羊</a>（<a href="https://orzsiyuan.com/articles/problem-HNOI-2010-Bounce-Sheep/" target="_blank" rel="noopener">题解</a>）</li><li>&#9745; <a href="https://www.luogu.org/problemnew/show/P1501" target="_blank" rel="noopener">「Luogu 1501」Tree II</a>（<a href="https://orzsiyuan.com/articles/problem-Luogu-1501-Tree-II/" target="_blank" rel="noopener">题解</a>）</li><li>&#9745; <a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2243" target="_blank" rel="noopener">「SDOI 2011」染色</a></li><li>&#9744; <a href="https://www.luogu.org/problemnew/show/P4332" target="_blank" rel="noopener">「SHOI 2014」三叉神经树</a></li></ul><h3 id="维护连通性"><a href="#维护连通性" class="headerlink" title="维护连通性"></a>维护连通性</h3><ul><li>&#9745; <a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2049" target="_blank" rel="noopener">「SDOI 2008」洞穴勘测</a></li><li>&#9745; <a href="https://www.luogu.org/problemnew/show/P3950" target="_blank" rel="noopener">「Luogu 3950」部落冲突</a></li><li>&#9744; <a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1969" target="_blank" rel="noopener">「AHOI 2005」航线规划</a></li><li>&#9744; <a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4998" target="_blank" rel="noopener">「BZOJ 4998」星球联盟</a></li><li>&#9744; <a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2959" target="_blank" rel="noopener">「BZOJ 2959」长跑</a></li></ul><h3 id="维护边权"><a href="#维护边权" class="headerlink" title="维护边权"></a>维护边权</h3><ul><li>&#9745; <a href="https://www.luogu.org/problemnew/show/P4172" target="_blank" rel="noopener">「WC 2006」水管局长</a>（<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2594" target="_blank" rel="noopener">加强版</a>）</li><li>&#9745; <a href="http://uoj.ac/problem/274" target="_blank" rel="noopener">「UOJ 274」温暖会指引我们前行</a></li><li>&#9745; <a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1977" target="_blank" rel="noopener">「BZOJ 1977」次小生成树</a></li><li>&#9745; <a href="https://www.luogu.org/problemnew/show/P4234" target="_blank" rel="noopener">「Luogu 4234」最小差值生成树</a></li><li>&#9745; <a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3669" target="_blank" rel="noopener">「NOI 2014」魔法森林</a></li></ul><h3 id="维护子树信息"><a href="#维护子树信息" class="headerlink" title="维护子树信息"></a>维护子树信息</h3><ul><li>&#9745; <a href="http://cogs.pro:8080/cogs/problem/problem.php?pid=2701" target="_blank" rel="noopener">「COGS 2701」动态树</a></li><li>&#9745; <a href="https://www.luogu.org/problemnew/show/P4219" target="_blank" rel="noopener">「BJOI 2014」大融合</a></li><li>&#9744; <a href="https://www.luogu.org/problemnew/show/U19464" target="_blank" rel="noopener">「Luogu U19464」山村游历</a></li><li>&#9744; <a href="https://www.luogu.org/problemnew/show/P4299" target="_blank" rel="noopener">「Luogu 4299」首都</a></li><li>&#9744; <a href="https://www.spoj.com/problems/QTREE5/" target="_blank" rel="noopener">「SPOJ 2939」QTREE5 - Query on a tree V</a></li><li>&#9744; <a href="https://loj.ac/problem/558" target="_blank" rel="noopener">「LOJ 558」我们的 CPU 遭到攻击</a></li></ul><h3 id="维护树上染色连通块"><a href="#维护树上染色连通块" class="headerlink" title="维护树上染色连通块"></a>维护树上染色连通块</h3><ul><li>&#9744; <a href="https://www.luogu.org/problemnew/show/P2173" target="_blank" rel="noopener">「ZJOI 2012」网络</a></li><li>&#9744; <a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4817" target="_blank" rel="noopener">「SDOI 2017」树点涂色</a></li><li>&#9744; <a href="https://www.spoj.com/problems/QTREE6/" target="_blank" rel="noopener">「SPOJ 16549」QTREE6 - Query on a tree VI</a></li><li>&#9744; <a href="https://www.spoj.com/problems/QTREE7/" target="_blank" rel="noopener">「SPOJ 16580」QTREE7 - Query on a tree VII</a></li><li>&#9744; <a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3914" target="_blank" rel="noopener">「BZOJ 3914」Jabby’s shadows</a></li></ul><h3 id="特殊题型"><a href="#特殊题型" class="headerlink" title="特殊题型"></a>特殊题型</h3><ul><li>&#9744; <a href="https://www.luogu.org/problemnew/show/P3613" target="_blank" rel="noopener">「Luogu 3613」睡觉困难综合征</a></li><li>&#9744; <a href="http://uoj.ac/problem/207" target="_blank" rel="noopener">「UOJ 207」共价大爷游长沙</a></li><li>&#9744; <a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4573" target="_blank" rel="noopener">「ZJOI 2016」大森林</a></li><li>&#9744; <a href="https://www.lydsy.com/JudgeOnline/problem.php?id=5212" target="_blank" rel="noopener">「ZJOI 2018」历史</a></li><li>&#9744; <a href="https://www.luogu.org/problemnew/show/P4546" target="_blank" rel="noopener">「Luogu 4546」在美妙的数学王国中畅游</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;动态树问题，即要求我们维护一个由若干棵子结点无序的有根树组成的森林。要求这个数据结构支持对树的分割、合并，对某个点到它的根的路径的某些操作。&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法笔记" scheme="http://hydingsy.github.io/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数据结构" scheme="http://hydingsy.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="LCT" scheme="http://hydingsy.github.io/tags/LCT/"/>
    
      <category term="Splay" scheme="http://hydingsy.github.io/tags/Splay/"/>
    
  </entry>
  
  <entry>
    <title>「Codeforces 1110D」Jongmah</title>
    <link href="http://hydingsy.github.io/articles/problem-Codeforces-1110D-Jongmah/"/>
    <id>http://hydingsy.github.io/articles/problem-Codeforces-1110D-Jongmah/</id>
    <published>2019-02-07T16:00:00.000Z</published>
    <updated>2019-02-08T02:34:39.865Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://codeforces.com/contest/1110/problem/D" target="_blank" rel="noopener">Codeforces 1110D</a></p></blockquote><p>你在玩一个叫做 Jongmah  的游戏，你手上有 $n$ 个麻将，每个麻将上有一个在 $1$ 到 $m$ 范围内的整数 $a_i$。</p><p>为了赢得游戏，你需要将这些麻将排列成一些三元组，每个三元组中的元素是相同的或者连续的。如 $7,7,7$ 和 $12,13,14$ 都是合法的。你只能使用手中的麻将，并且每个麻将只能使用一次。</p><p>请求出你最多可以形成多少个三元组。</p><p>数据范围：$1\le n,m\le 10^6$，$1\le a_i\le m$</p><a id="more"></a><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>首先我们必须注意到：相同的 $3​$ 个 $[x,x+1,x+2]​$ 三元组，可以变成 $[x,x,x]​$，$[x+1,x+1,x+1]​$，$[x+2,x+2,x+2]​$ 这样 $3​$ 个三元组，而并没有改变三元组的数量。这样一来，我们就可以假设，对于每个 $x​$，形如 $[x,x+1,x+2]​$ 的三元组<strong>最多</strong>只有 $2​$ 个！</p><p>我们可以直接定义 $\text{DP}$ 状态：$f_{x,i,j}$ 表示考虑到前 $x$ 种数字，有 $i$ 个 $[x-1,x,x+1]$，$j$ 个 $[x,x+1,x+2]$，我们枚举有 $k$ 个 $[x+1,x+2,x+3]$，状态转移方程如下（我们记 $cnt_i$ 表示数字 $i$ 的数量）：</p><script type="math/tex; mode=display">f_{x,j,k}=\max\left\{f_{x-1,i,j}+\left\lfloor\frac{cnt_x-i-j-k}{3}\right\rfloor+k\right\}\quad(0\le k\le 2,i+j+k\le cnt_x)</script><p>其中 $i,j,k$ 分别表示：有 $i$ 个 $[x-2,x-1,x]$，有 $j$ 个 $[x-1,x,x+1]$，有 $k$ 个 $[x,x+1,x+2]$，那么肯定有 $i+j+k$ 个数字 $x​$，得到<strong>约束条件</strong>和<strong>贡献</strong>后直接转移。</p><p><strong>时间复杂度</strong>：$O(3^3\cdot m)$</p><hr><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>,M=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[N],f[M][M],g[M][M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x,i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x),++a[x];</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">1</span>;p&lt;=m;++p) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(g,f,<span class="keyword">sizeof</span>(f));</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;++j) <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">3</span>;++k) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i+j+k&lt;=a[p]) f[j][k]=<span class="built_in">std</span>::max(f[j][k],g[i][j]+(a[p]-i-j-k)/<span class="number">3</span>+k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://codeforces.com/contest/1110/problem/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Codeforces 1110D&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你在玩一个叫做 Jongmah  的游戏，你手上有 $n$ 个麻将，每个麻将上有一个在 $1$ 到 $m$ 范围内的整数 $a_i$。&lt;/p&gt;
&lt;p&gt;为了赢得游戏，你需要将这些麻将排列成一些三元组，每个三元组中的元素是相同的或者连续的。如 $7,7,7$ 和 $12,13,14$ 都是合法的。你只能使用手中的麻将，并且每个麻将只能使用一次。&lt;/p&gt;
&lt;p&gt;请求出你最多可以形成多少个三元组。&lt;/p&gt;
&lt;p&gt;数据范围：$1\le n,m\le 10^6$，$1\le a_i\le m$&lt;/p&gt;
    
    </summary>
    
    
      <category term="动态规划" scheme="http://hydingsy.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="贪心" scheme="http://hydingsy.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="Codeforces" scheme="http://hydingsy.github.io/tags/Codeforces/"/>
    
  </entry>
  
  <entry>
    <title>「Codeforces 1110F」Nearest Leaf</title>
    <link href="http://hydingsy.github.io/articles/problem-Codeforces-1110F-Nearest-Leaf/"/>
    <id>http://hydingsy.github.io/articles/problem-Codeforces-1110F-Nearest-Leaf/</id>
    <published>2019-02-07T16:00:00.000Z</published>
    <updated>2019-02-08T13:35:35.300Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://codeforces.com/contest/1110/problem/F" target="_blank" rel="noopener">Codeforces 1110F</a></p></blockquote><p>给你一棵带权有根树，根节点为 $1​$，且保证每个点的父亲 $p_i&lt;i​$，其中 $(p_i,i)​$ 的边权为 $w_i​$。这棵树有个性质：如果我们 $\text{DFS}​$ 这棵树，对于每个点都递增枚举儿子节点，每访问到一个节点就记录其编号，那么得到的序列刚好为 $1​$ 到 $n​$。</p><p>现在有 $q​$ 次询问，每次给出 $v_i,l_i,r_i​$，求从 $v_i​$ 出发到 $[l_i,r_i]​$ 中的其中一个叶子节点的最短距离（保证 $[l_i,r_i]​$ 中至少有一个叶子节点）。</p><p>数据范围：$3\le n\le 5\times 10^5​$，$1\le q\le 5\times 10^5​$，$1\le p_i&lt;i​$，$1\le w_i\le 10^9​$</p><a id="more"></a><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>考虑都没有修改操作，我们可以把询问<strong>离线</strong>下来。按照询问的节点分类。</p><p>我们首先观察一个性质：由于 $\text{DFS}$ 序就是 $1$ 到 $n$，那么意味着<strong>每棵子树内</strong>的编号都是<strong>连续</strong>的，记子树 $i$ 内点的<strong>最大编号</strong>为 $k_i​$。</p><p>我们再考虑一个问题：如果从 $u​$ 到达 $v​$（我们记这条边为 $(u,v,w)​$），其中 $v​$ 的深度大于 $u​$，那么到达每个叶子的路径长度会发生什么变化？</p><ul><li>对于在 $v​$ 子树内的叶子，到他们的距离<strong>减少</strong> $w​$。</li><li>其余叶子节点，到他们的距离<strong>增加</strong> $w​$。</li></ul><p>根据之前的性质，我们发现 $v$ 子树内的节点编号连续，可以直接用<strong>线段树修改</strong>。具体的修改方法为：我们将线段树内 $[1,n]$ 的节点的值增加 $w$，将 $[v,k_v]$ 的节点的值减少 $2w​$。</p><p>为了防止对线段树中<strong>非叶子节点</strong>的影响，我们应该要将他们的值初始化为 $\text{INF}$，使得无论如何修改都不会影响答案。</p><p>这样一来，我们可以得到一个简单的算法流程：</p><ol><li>将 $1$ 到所有叶子节点的距离放到线段树中，非叶子节点的距离定义为 $\text{INF}$。</li><li>直接 $\text{DFS}$ 整棵树，将询问节点为<strong>当前节点</strong>的询问统计答案。</li><li>枚举当前节点 $u$ 的儿子节点 $v$，在线段树上修改 $[v,k_v]$ 的值并递归求解 $v$ 的值；递归后记得<strong>回溯</strong>消去影响！</li></ol><p><strong>时间复杂度</strong>：$O((n+q)\log n)$</p><hr><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson p&lt;&lt;1|1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> INF=<span class="number">1L</span>L&lt;&lt;<span class="number">60</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,tot,l[N],r[N],mx[N],lnk[N],ter[N],nxt[N],val[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> seg[N&lt;&lt;<span class="number">2</span>],tag[N&lt;&lt;<span class="number">2</span>],dis[N],ans[N];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    seg[p]=<span class="built_in">std</span>::min(seg[lson],seg[rson]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tag[p]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> v=tag[p];</span><br><span class="line">    seg[lson]+=v,tag[lson]+=v,seg[rson]+=v,tag[rson]+=v,tag[p]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">long</span> <span class="keyword">long</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y) &#123;</span><br><span class="line">        seg[p]+=v,tag[p]+=v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(p);</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) modify(x,y,lson,l,mid,v);</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;y) modify(x,y,rson,mid+<span class="number">1</span>,r,v);</span><br><span class="line">    pushup(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y) <span class="keyword">return</span> seg[p];</span><br><span class="line">    pushdown(p);</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=INF;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) ans=<span class="built_in">std</span>::min(ans,query(x,y,lson,l,mid));</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;y) ans=<span class="built_in">std</span>::min(ans,query(x,y,rson,mid+<span class="number">1</span>,r));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    ter[++tot]=v,nxt[tot]=lnk[u],lnk[u]=tot,val[tot]=w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    mx[u]=u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=lnk[u];i;i=nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> v=ter[i];</span><br><span class="line">        dis[v]=dis[u]+val[i];</span><br><span class="line">        dfs1(v);</span><br><span class="line">        mx[u]=<span class="built_in">std</span>::max(mx[u],mx[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i:q[u]) ans[i]=query(l[i],r[i],<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=lnk[u];i;i=nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> v=ter[i],w=val[i];</span><br><span class="line">        modify(<span class="number">1</span>,n,<span class="number">1</span>,<span class="number">1</span>,n,w),modify(v,mx[v],<span class="number">1</span>,<span class="number">1</span>,n,-w-w);</span><br><span class="line">        dfs2(v);</span><br><span class="line">        modify(<span class="number">1</span>,n,<span class="number">1</span>,<span class="number">1</span>,n,-w),modify(v,mx[v],<span class="number">1</span>,<span class="number">1</span>,n,w+w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> p,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;p,&amp;w),add(p,i,w);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs1(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        modify(i,i,<span class="number">1</span>,<span class="number">1</span>,n,i==mx[i]?dis[i]:INF);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;v,&amp;l[i],&amp;r[i]),q[v].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs2(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://codeforces.com/contest/1110/problem/F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Codeforces 1110F&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;给你一棵带权有根树，根节点为 $1​$，且保证每个点的父亲 $p_i&amp;lt;i​$，其中 $(p_i,i)​$ 的边权为 $w_i​$。这棵树有个性质：如果我们 $\text{DFS}​$ 这棵树，对于每个点都递增枚举儿子节点，每访问到一个节点就记录其编号，那么得到的序列刚好为 $1​$ 到 $n​$。&lt;/p&gt;
&lt;p&gt;现在有 $q​$ 次询问，每次给出 $v_i,l_i,r_i​$，求从 $v_i​$ 出发到 $[l_i,r_i]​$ 中的其中一个叶子节点的最短距离（保证 $[l_i,r_i]​$ 中至少有一个叶子节点）。&lt;/p&gt;
&lt;p&gt;数据范围：$3\le n\le 5\times 10^5​$，$1\le q\le 5\times 10^5​$，$1\le p_i&amp;lt;i​$，$1\le w_i\le 10^9​$&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://hydingsy.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="线段树" scheme="http://hydingsy.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="Codeforces" scheme="http://hydingsy.github.io/tags/Codeforces/"/>
    
      <category term="离线" scheme="http://hydingsy.github.io/tags/%E7%A6%BB%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>「算法笔记」Splay 维护序列</title>
    <link href="http://hydingsy.github.io/articles/algorithm-Splay-2/"/>
    <id>http://hydingsy.github.io/articles/algorithm-Splay-2/</id>
    <published>2019-02-06T16:00:00.000Z</published>
    <updated>2019-02-09T05:32:16.578Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">$\text{Splay}$ 是一种二叉查找树，它通过不断将某个节点旋转到根节点，使得整棵树仍然满足二叉查找树的性质，并且保持平衡而不至于退化为链。</blockquote><a id="more"></a><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>我们以<a href="https://www.luogu.org/problemnew/show/P3391" target="_blank" rel="noopener">「Luogu 3391」文艺平衡树</a> 作为例题：你需要维护一个有序数列，支持<strong>翻转区间</strong>操作。</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h3><p>我们还是用 $\text{Splay}$ 来维护这个序列，但是不用权值维护，而是用<strong>节点在序列中的位置</strong>为关键字维护，显然一个子树对应一个区间。</p><p>每次提取区间 $[l,r]$ 然后<strong>将左右子树全部交换</strong>。这正是利用了 $\text{Splay}$ 在旋转过程中不会改变<strong>中序遍历</strong>。那么原来的<strong>左根右</strong>在交换后变为<strong>右根左</strong>，实现了区间翻转。</p><h3 id="提取区间"><a href="#提取区间" class="headerlink" title="提取区间"></a>提取区间</h3><p>根据 $\text{Splay}$ 的特性（具体介绍详见<a href="https://orzsiyuan.com/articles/algorithm-Splay-1/" target="_blank" rel="noopener">「算法笔记」Splay 维护二叉查找树</a>），对于区间 $[l,r]$，我们可以把 $l-1$ 旋转到根，$r+1$ 旋转到根的儿子（显然是右儿子）。那么<strong>根的右儿子的左子树</strong>就是区间 $[l,r]$。</p><p>对于这里的 $l-1$ 和 $r+1$，指的是序列中第 $l-1$ 和第 $r+1$ 个元素对应的节点，而不是下标为 $l-1$ 和 $r+1$ 的节点。因此我们要调用 $\text{Splay}​$ 基本操作中的 <code>kth(l-1)</code> 和 <code>kth(r+1)</code> 找到对应的节点编号。</p><h3 id="交换子树"><a href="#交换子树" class="headerlink" title="交换子树"></a>交换子树</h3><p>我们这里要使用一个和<strong>线段树</strong>很相似的<strong>懒标记</strong>，我们对于每个节点记录一个  $\text{rev}​$ 标记，标记这个区间是否被翻转。每次 <code>kth</code> 操作时将<strong>标记下传</strong>、<strong>交换左右子树</strong>、<strong>清空自身标记</strong>。</p><p><strong>时间复杂度</strong>：$O(n\log n)$</p><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,rt,idx,ch[N][<span class="number">2</span>],fa[N],sz[N],cnt[N],val[N],rev[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    sz[x]=sz[ch[x][<span class="number">0</span>]]+sz[ch[x][<span class="number">1</span>]]+cnt[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rev[x]) &#123;</span><br><span class="line">        <span class="built_in">std</span>::swap(ch[x][<span class="number">0</span>],ch[x][<span class="number">1</span>]);</span><br><span class="line">        rev[ch[x][<span class="number">0</span>]]^=<span class="number">1</span>;</span><br><span class="line">        rev[ch[x][<span class="number">1</span>]]^=<span class="number">1</span>;</span><br><span class="line">        rev[x]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>]==x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y=fa[x],z=fa[y],k=get(x);</span><br><span class="line">    ch[z][get(y)]=x,fa[x]=z;</span><br><span class="line">    ch[y][k]=ch[x][k^<span class="number">1</span>],fa[ch[x][k^<span class="number">1</span>]]=y;</span><br><span class="line">    ch[x][k^<span class="number">1</span>]=y,fa[y]=x;</span><br><span class="line">    pushup(y),pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(fa[x]!=g) &#123;</span><br><span class="line">        <span class="keyword">int</span> y=fa[x];</span><br><span class="line">        <span class="keyword">if</span>(fa[y]!=g) rotate(get(x)==get(y)?y:x);</span><br><span class="line">        rotate(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!g) rt=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ++x;</span><br><span class="line">    <span class="keyword">int</span> u=rt;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        pushdown(u);</span><br><span class="line">        <span class="keyword">if</span>(x&gt;sz[ch[u][<span class="number">0</span>]]+cnt[u]) x-=sz[ch[u][<span class="number">0</span>]]+cnt[u],u=ch[u][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x&lt;=sz[ch[u][<span class="number">0</span>]]) u=ch[u][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u=rt,f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x!=val[u]&amp;&amp;u) f=u,u=ch[u][x&gt;val[u]];</span><br><span class="line">    <span class="keyword">if</span>(u) ++cnt[u];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        u=++idx;</span><br><span class="line">        <span class="keyword">if</span>(f) ch[f][x&gt;val[f]]=u;</span><br><span class="line">        ch[u][<span class="number">0</span>]=ch[u][<span class="number">1</span>]=<span class="number">0</span>,fa[u]=f,val[u]=x,sz[u]=cnt[u]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    splay(u,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    ins(-INF),ins(INF);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) ins(i);</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line">        splay(kth(l<span class="number">-1</span>),<span class="number">0</span>),splay(kth(r+<span class="number">1</span>),rt);</span><br><span class="line">        rev[ch[ch[rt][<span class="number">1</span>]][<span class="number">0</span>]]^=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>,val[kth(i)],<span class="string">" \n"</span>[i==n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>详见<a href="https://orzsiyuan.com/articles/algorithm-Splay-1/" target="_blank" rel="noopener">「算法笔记」Splay 维护二叉查找树</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;$\text{Splay}$ 是一种二叉查找树，它通过不断将某个节点旋转到根节点，使得整棵树仍然满足二叉查找树的性质，并且保持平衡而不至于退化为链。&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法笔记" scheme="http://hydingsy.github.io/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数据结构" scheme="http://hydingsy.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="Splay" scheme="http://hydingsy.github.io/tags/Splay/"/>
    
  </entry>
  
  <entry>
    <title>「Codeforces 594D」REQ</title>
    <link href="http://hydingsy.github.io/articles/problem-Codeforces-594D-REQ/"/>
    <id>http://hydingsy.github.io/articles/problem-Codeforces-594D-REQ/</id>
    <published>2019-02-01T16:00:00.000Z</published>
    <updated>2019-02-03T02:21:03.467Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://codeforces.com/contest/594/problem/D/" target="_blank" rel="noopener">Codeforces 594D</a></p></blockquote><p>今天的数学课上，老师告诉 Vovochka 正整数的欧拉函数 $\varphi(n)​$ 是计算小于等于 $n​$ 且与 $n​$ 互质的正整数的函数，$1​$ 和任意正整数互质所以 $\varphi(1)=1​$。</p><p>现在老师给了 Vovochka 一个数列 $a_1,a_2,\dots,a_n​$，要求回答 $q​$ 个询问 $l_i,r_i​$，计算 $\varphi\left(\prod_{i=l}^r a_i\right)​$ 的值，答案对 $10^9 + 7​$ 取模。这个问题对二年级学生来说太难了，所以你决定帮助 Vovochka。</p><p>数据范围：$1\le n,q\le 2\times 10^5​$，$1\le a_i\le 10^6​$</p><a id="more"></a><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>由于只有询问操作，因此我们首先想到<strong>离线</strong>后用莫队解决。但是莫队的复杂度为 $O(q\sqrt n\log a_i)$（其中 $\log a_i$ 指每个数的本质不同的质因子个数），显然无法通过本题（我卡了半个小时常数还是 $\text{TLE}$ <del>出题人毒瘤</del>）。</p><p>还是考虑离线，我们将询问<strong>按照右端点排序</strong>，维护一个右指针，将每个 $a_i​$ 逐个加入。用<strong>树状数组</strong>维护每个位置对答案的贡献。</p><p>我们考虑 $a_i​$ 的其中一个质因子 $p​$（其他的质因子同理）。由于我们把询问按照右端点排序了，而每个质因子只能对答案有<strong>一次贡献</strong>，那么我们把 $p​$ 的贡献放到区间 $[1,i]​$ 的<strong>最右边</strong>，即进行操作 $add(i,p-1)​$ 和 $add(i,p^{-1})​$。如果 $p​$ 已经出现过了，那么我们需要<strong>防止区间左端点左侧产生贡献</strong>，维护一个 $lst[i]​$ 表示 $i​$ 这个质因子<strong>上次出现的位置</strong>，将 $lst[p]​$ 位置的贡献消去即可。</p><p>对于如何快速分解每个数的质因子，我们可以根据线性筛的本质：每个数只会被其<strong>最小质因子</strong>筛去，在筛的过程中直接记录每个数的最小质因子即可！</p><p><strong>时间复杂度</strong>：$O((n+q)\log n\log a_i)$</p><hr><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">5</span>,M=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,tot,a[N],b[N],p[M/<span class="number">10</span>],f[M],pre[N],lst[M],ans[N];</span><br><span class="line"><span class="keyword">bool</span> flg[M];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Data &amp;rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> r&lt;rhs.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!flg[i]) p[++tot]=i,f[i]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot&amp;&amp;i*p[j]&lt;=n;++j) &#123;</span><br><span class="line">            flg[i*p[j]]=<span class="number">1</span>,f[i*p[j]]=p[j];</span><br><span class="line">            <span class="keyword">if</span>(i%p[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;p;p&gt;&gt;=<span class="number">1</span>,x=<span class="number">1L</span>L*x*x%mod) <span class="keyword">if</span>(p&amp;<span class="number">1</span>) ret=<span class="number">1L</span>L*ret*x%mod;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inv</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(x,mod<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;x&lt;=n;x+=x&amp;-x) b[x]=<span class="number">1L</span>L*b[x]*val%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;x;x^=x&amp;-x) ret=<span class="number">1L</span>L*ret*b[x]%mod;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x=a[i],p=f[x];x&gt;<span class="number">1</span>;p=f[x]) &#123;</span><br><span class="line">        add(i,p<span class="number">-1</span>),add(i,inv(p));</span><br><span class="line">        <span class="keyword">if</span>(lst[p]) add(lst[p],inv(p<span class="number">-1</span>)),add(lst[p],p);</span><br><span class="line">        lst[p]=i;</span><br><span class="line">        <span class="keyword">while</span>(x%p==<span class="number">0</span>) x/=p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sieve(M<span class="number">-5</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    pre[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]),pre[i]=<span class="number">1L</span>L*pre[i<span class="number">-1</span>]*a[i]%mod;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;q[i].l,&amp;q[i].r),q[i].id=i;</span><br><span class="line">    <span class="built_in">std</span>::sort(q+<span class="number">1</span>,q+m+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i) b[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=m;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x=q[i].l,y=q[i].r;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;y) update(++j);</span><br><span class="line">        ans[q[i].id]=<span class="number">1L</span>L*pre[y]*inv(pre[x<span class="number">-1</span>])%mod*query(y)%mod*inv(query(x<span class="number">-1</span>))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://codeforces.com/contest/594/problem/D/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Codeforces 594D&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天的数学课上，老师告诉 Vovochka 正整数的欧拉函数 $\varphi(n)​$ 是计算小于等于 $n​$ 且与 $n​$ 互质的正整数的函数，$1​$ 和任意正整数互质所以 $\varphi(1)=1​$。&lt;/p&gt;
&lt;p&gt;现在老师给了 Vovochka 一个数列 $a_1,a_2,\dots,a_n​$，要求回答 $q​$ 个询问 $l_i,r_i​$，计算 $\varphi\left(\prod_{i=l}^r a_i\right)​$ 的值，答案对 $10^9 + 7​$ 取模。这个问题对二年级学生来说太难了，所以你决定帮助 Vovochka。&lt;/p&gt;
&lt;p&gt;数据范围：$1\le n,q\le 2\times 10^5​$，$1\le a_i\le 10^6​$&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://hydingsy.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="欧拉函数" scheme="http://hydingsy.github.io/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"/>
    
      <category term="Codeforces" scheme="http://hydingsy.github.io/tags/Codeforces/"/>
    
      <category term="离线" scheme="http://hydingsy.github.io/tags/%E7%A6%BB%E7%BA%BF/"/>
    
      <category term="树状数组" scheme="http://hydingsy.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>「Codeforces 900D」Unusual Sequences</title>
    <link href="http://hydingsy.github.io/articles/problem-Codeforces-900D-Unusual-Sequences/"/>
    <id>http://hydingsy.github.io/articles/problem-Codeforces-900D-Unusual-Sequences/</id>
    <published>2019-01-31T16:00:00.000Z</published>
    <updated>2019-02-08T02:38:12.733Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://codeforces.com/contest/900/problem/D" target="_blank" rel="noopener">Codeforces 900D</a></p></blockquote><p>求满足下面两个条件的数列 $a_1,a_2,\dots,a_n(1\le a_i)​$ 的个数（答案对 $10^9+7​$ 取模）：</p><ol><li>$\gcd(a_1,a_2,\dots,a_n)=x$</li><li>$\sum_{i=1}^n a_i=y​$</li></ol><p>数据范围：$1\le x.y\le 10^9​$</p><a id="more"></a><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>如果在 $x\nmid y​$ 的情况下，显然无解。</p><p>我们令 $m=\frac{y}{x}​$，那么问题转化为：求满足 $\gcd(a_1,a_2,\dots,a_n)=1​$ 且 $\sum_{i=1}^n a_i=m​$ 的数列个数。</p><p>我们先不考虑 $\gcd=1$ 的限制，设 $g(x)$ 表示 $\sum_{i=1}^n a_i=x$ 的数列个数。</p><p>对于 $g(x)​$ 的值，我们可以使用<strong>隔板法</strong>求解：</p><script type="math/tex; mode=display">g(x)=\sum_{i=1}^x \binom{x-1}{i-1}=2^{x-1}</script><p>我们发现，$g(x)$ 的值又可以通过 $f(x)​$ 求得：</p><script type="math/tex; mode=display">g(x)=\sum_{d\mid x} f(d)</script><p>接下来介绍两种做法：</p><h3 id="递推"><a href="#递推" class="headerlink" title="递推"></a>递推</h3><p>我们可以考虑容斥原理：<strong>所有序列数量</strong>减去<strong>不合法的序列数量</strong>。我们枚举不合法的序列的 $\gcd$ 记为 $d$，显然 $d$ 必须满足 $d\mid x,d&gt;1$，这样的序列数量为 $f\left(\frac{x}{d}\right)$（当然也可以通过 $g$ 和 $f$ 的关系得到）。</p><script type="math/tex; mode=display">\begin{aligned}f(x)&=g(x)-\sum_{d\mid x,d>1} f\left(\frac{x}{d}\right) \\&=2^{x-1}-\sum_{d\mid x,d>1} f\left(\frac{x}{d}\right)\end{aligned}</script><p>由于一个数的因子的因子也一定是这个数的因子，所以我们发现需要的 $x​$ 为 $d(m)​$ 个，即不超过 $O(\sqrt m)​$ 个，可以直接递归求解。</p><p><strong>时间复杂度</strong>：$O(d(m)\sqrt m\log m)​$</p><h3 id="反演"><a href="#反演" class="headerlink" title="反演"></a>反演</h3><p>我们发现：</p><script type="math/tex; mode=display">g(x)=\sum_{d\mid x} f(d)</script><p>这个式子的本质是 $g=f\ast 1$，通过<strong>莫比乌斯反演</strong>可以得到：</p><script type="math/tex; mode=display">f(x)=\sum_{d\mid x} \mu\left(\frac{x}{d}\right)g(d)</script><p>这样一来我们就可以直接暴力求解了。</p><p><strong>时间复杂度</strong>：$O\left(\frac{m}{\log m}\right)​$</p><hr><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><h3 id="递推-1"><a href="#递推-1" class="headerlink" title="递推"></a>递推</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;p;p&gt;&gt;=<span class="number">1</span>,x=<span class="number">1L</span>L*x*x%mod) <span class="keyword">if</span>(p&amp;<span class="number">1</span>) ret=<span class="number">1L</span>L*ret*x%mod;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    (x+=y)&gt;=mod&amp;&amp;(x-=mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mp.count(n)) <span class="keyword">return</span> mp[n];</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>) &#123;</span><br><span class="line">            upd(ans,solve(i));</span><br><span class="line">            <span class="keyword">if</span>(i*i!=n) upd(ans,solve(n/i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    upd(ans,solve(<span class="number">1</span>));</span><br><span class="line">    ans=(<span class="built_in">pow</span>(<span class="number">2</span>,n<span class="number">-1</span>)-ans+mod)%mod;</span><br><span class="line">    <span class="keyword">return</span> mp[n]=ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">    <span class="keyword">if</span>(y%x) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0"</span>),<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,solve(y/x));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反演-1"><a href="#反演-1" class="headerlink" title="反演"></a>反演</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> x,y,tot,p[N];</span><br><span class="line"><span class="keyword">bool</span> flg[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!flg[i]) p[++tot]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot&amp;&amp;i*p[j]&lt;=n;++j) &#123;</span><br><span class="line">            flg[i*p[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%p[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mu</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot&amp;&amp;<span class="number">1L</span>L*p[i]*p[i]&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n%p[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n%p[i]==<span class="number">0</span>) n/=p[i],++now;</span><br><span class="line">        <span class="keyword">if</span>(now&gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>) ++cnt;</span><br><span class="line">    <span class="keyword">return</span> cnt%<span class="number">2</span>==<span class="number">0</span>?<span class="number">1</span>:mod<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;p;p&gt;&gt;=<span class="number">1</span>,x=<span class="number">1L</span>L*x*x%mod) <span class="keyword">if</span>(p&amp;<span class="number">1</span>) ret=<span class="number">1L</span>L*ret*x%mod;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    (x+=y)&gt;=mod&amp;&amp;(x-=mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sieve(N<span class="number">-5</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">    <span class="keyword">if</span>(y%x) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0"</span>),<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n=y/x,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;<span class="number">1L</span>L*i*i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>) &#123;</span><br><span class="line">            upd(ans,<span class="number">1L</span>L*mu(n/i)*<span class="built_in">pow</span>(<span class="number">2</span>,i<span class="number">-1</span>)%mod);</span><br><span class="line">            <span class="keyword">if</span>(i*i!=n) upd(ans,<span class="number">1L</span>L*mu(i)*<span class="built_in">pow</span>(<span class="number">2</span>,n/i<span class="number">-1</span>)%mod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://codeforces.com/contest/900/problem/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Codeforces 900D&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;求满足下面两个条件的数列 $a_1,a_2,\dots,a_n(1\le a_i)​$ 的个数（答案对 $10^9+7​$ 取模）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$\gcd(a_1,a_2,\dots,a_n)=x$&lt;/li&gt;
&lt;li&gt;$\sum_{i=1}^n a_i=y​$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;数据范围：$1\le x.y\le 10^9​$&lt;/p&gt;
    
    </summary>
    
    
      <category term="数论" scheme="http://hydingsy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="莫比乌斯反演" scheme="http://hydingsy.github.io/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
      <category term="动态规划" scheme="http://hydingsy.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="容斥" scheme="http://hydingsy.github.io/tags/%E5%AE%B9%E6%96%A5/"/>
    
      <category term="Codeforces" scheme="http://hydingsy.github.io/tags/Codeforces/"/>
    
  </entry>
  
  <entry>
    <title>「Codeforces 1102F」Elongated Matrix</title>
    <link href="http://hydingsy.github.io/articles/problem-Codeforces-1102F-Elongated-Matrix/"/>
    <id>http://hydingsy.github.io/articles/problem-Codeforces-1102F-Elongated-Matrix/</id>
    <published>2019-01-30T16:00:00.000Z</published>
    <updated>2019-02-08T02:45:27.464Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://codeforces.com/contest/1102/problem/F" target="_blank" rel="noopener">Codeforces 1102F</a></p></blockquote><p>给你一个 $n​$ 行 $m​$ 列的矩阵 $a_{i,j}​$，其中每个元素都是正整数 。</p><p>你可以任意改变行的顺序，但是不能改变同一行中元素的顺序。确定行的顺序后，你可以通过以下方式遍历整个矩阵：首先访问从顶行到底部的第一列的所有元素，然后对第二列进行相同的操作，依此类推。在遍历期间，按照访问它们的顺序记下元素，得到一个序列 $s_i​$。设这个序列为 $s_1,s_2,\dots,s_{nm}​$。</p><p>如果对于任意的 $i(1\le i&lt;nm)​$，有 $\vert s_i-s_{i+1}\vert\ge k​$ 成立，我们称 $k​$ 是合法的。</p><p>你要做的是寻找一个 $a_{i,j}$ 的行的排列顺序，使得最大的合法的 $k​$ 值最大。</p><p>数据范围：$1\le n\le 16​$，$1\le m\le 10^4​$，$2\le nm​$，$1\le a_{i,j}\le 10^9​$</p><a id="more"></a><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>我们发现行的排列顺序的本质是：<strong>哈密顿回路</strong>，即第 $i​$ 行接着第 $i+1​$ 行并产生贡献，第 $n​$ 行接着第 $1​$ 行并产生贡献。注意到 $n​$ 的范围很小，我们可以考虑<strong>状态压缩</strong>。</p><p>由于第一行（哈密顿回路中的<strong>起点</strong>）是不确定的，因此我们首先要枚举起点。定义状态 $f_{i,j}$ 表示已经考虑了 $i$ 集合内的行，最后一行是 $j$ 时，不考虑第一行和最后一行的贡献的<strong>最大贡献</strong>（要求 $\vert s_i-s_{i+1}\vert$ 的最小值最大）。其中第 $i$ 行和第 $j$ 的贡献是指：同一列的元素的的差的绝对值的<strong>最小值</strong>。</p><p>状态转移方程如下：</p><script type="math/tex; mode=display">f_{S\cup j,j}=\max\{\min(f_{S,i},\text{cost}(i,j))\}\quad (i\in S,j\not\in S)</script><p>其中 $\text{cost}(i,j)​$ 表示第 $i​$ 行和第 $j​$ 行相邻的贡献。</p><p>统计答案时，我们枚举结束点 $i​$，根据起点 $k​$ 可以得到答案为：</p><script type="math/tex; mode=display">\text{Ans}=\max\{\min(f_{2^n-1,i},\text{cost}'(k,i))\}</script><p>其中 $2^n-1$ 为全集，$\text{cost}’(i,j)$ 表示第 $i$ 行为第一行，第 $j$ 行为最后一行时，第一行和最后一行之间的贡献。</p><p><strong>时间复杂度</strong>：$O(2^nn^3)$</p><hr><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">17</span>,M=<span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[N][M],f[<span class="number">1</span>&lt;&lt;N][N],g[N][N],h[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j) &#123;</span><br><span class="line">        g[i][j]=INF,h[i][j]=INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=m;++k) g[i][j]=<span class="built_in">std</span>::min(g[i][j],<span class="built_in">std</span>::<span class="built_in">abs</span>(a[i][k]-a[j][k]));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>;k&lt;=m;++k) h[i][j]=<span class="built_in">std</span>::min(h[i][j],<span class="built_in">std</span>::<span class="built_in">abs</span>(a[i][k<span class="number">-1</span>]-a[j][k]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i][j]);</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;++k) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">        f[<span class="number">1</span>&lt;&lt;k][k]=INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> S=<span class="number">0</span>;S&lt;(<span class="number">1</span>&lt;&lt;n);++S) <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) <span class="keyword">if</span>(S&amp;(<span class="number">1</span>&lt;&lt;i)) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!(S&amp;(<span class="number">1</span>&lt;&lt;j))) f[S|(<span class="number">1</span>&lt;&lt;j)][j]=<span class="built_in">std</span>::max(f[S|(<span class="number">1</span>&lt;&lt;j)][j],<span class="built_in">std</span>::min(f[S][i],g[i][j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) &#123;</span><br><span class="line">            ans=<span class="built_in">std</span>::max(ans,<span class="built_in">std</span>::min(f[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>][i],h[k][i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://codeforces.com/contest/1102/problem/F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Codeforces 1102F&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;给你一个 $n​$ 行 $m​$ 列的矩阵 $a_{i,j}​$，其中每个元素都是正整数 。&lt;/p&gt;
&lt;p&gt;你可以任意改变行的顺序，但是不能改变同一行中元素的顺序。确定行的顺序后，你可以通过以下方式遍历整个矩阵：首先访问从顶行到底部的第一列的所有元素，然后对第二列进行相同的操作，依此类推。在遍历期间，按照访问它们的顺序记下元素，得到一个序列 $s_i​$。设这个序列为 $s_1,s_2,\dots,s_{nm}​$。&lt;/p&gt;
&lt;p&gt;如果对于任意的 $i(1\le i&amp;lt;nm)​$，有 $\vert s_i-s_{i+1}\vert\ge k​$ 成立，我们称 $k​$ 是合法的。&lt;/p&gt;
&lt;p&gt;你要做的是寻找一个 $a_{i,j}$ 的行的排列顺序，使得最大的合法的 $k​$ 值最大。&lt;/p&gt;
&lt;p&gt;数据范围：$1\le n\le 16​$，$1\le m\le 10^4​$，$2\le nm​$，$1\le a_{i,j}\le 10^9​$&lt;/p&gt;
    
    </summary>
    
    
      <category term="动态规划" scheme="http://hydingsy.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="Codeforces" scheme="http://hydingsy.github.io/tags/Codeforces/"/>
    
      <category term="状压 DP" scheme="http://hydingsy.github.io/tags/%E7%8A%B6%E5%8E%8B-DP/"/>
    
      <category term="哈密顿回路" scheme="http://hydingsy.github.io/tags/%E5%93%88%E5%AF%86%E9%A1%BF%E5%9B%9E%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>「Codeforces 786A」Berzerk</title>
    <link href="http://hydingsy.github.io/articles/problem-Codeforces-786A-Berzerk/"/>
    <id>http://hydingsy.github.io/articles/problem-Codeforces-786A-Berzerk/</id>
    <published>2019-01-30T16:00:00.000Z</published>
    <updated>2019-02-03T02:30:25.516Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://codeforces.com/contest/786/problem/A" target="_blank" rel="noopener">Codeforces 786A</a></p></blockquote><p>Rick 和 Morty 在玩一个版本的 Berzerk 游戏。这个游戏需要很大的空间，所以他们使用电脑玩这个游戏。</p><p>游戏中有 $n​$ 个标号从 $1\sim n​$ 的物体围成一个圆圈（顺时针标号）， 物体 $1​$ 表示黑洞，其它物体表示星球，且某一个星球上有一个怪物，Rick 和 Morty 不知道这个怪物在哪个星球上，只知道这个怪物在游戏开始时没有进入黑洞。但就目前而言，他们希望为每种可能的情况做好准备。</p><p>Rick 和 Monty 每人有一个数的集合，集合中的数在 $[1,n-1]$ 之间。Rick 的集合是 $s_1$，其中有 $k_1$ 个数，Morty 的集合是 $s_2$，其中有 $k_2$ 个数。 游戏开始后，两人轮流操作。在操作中，玩家必须从他的集合中选出一个数 $x$， 怪物将从当前位置顺时针移动 $x$ 个位置，如果怪物移动后进入了黑洞，则该玩家获胜。</p><p>你的任务是对于每一个怪物的位置以及玩家先后手顺序，判断游戏先手获胜、后手获胜、无限循环。（每个玩家都采取最优操作）</p><p>数据范围：$2\le n\le 7000$，$1\le k_1,k_2\le n-1$，$1\le s_{i,j}\le n-1$</p><a id="more"></a><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p><strong>博弈论</strong>有一个经典的结论：</p><blockquote><p><strong>能转移到必败态的状态就是必胜态，只能转移到必胜态的状态就是必败态。</strong></p></blockquote><p>现在我们知道 $1$ 是<strong>必败态</strong>，那么我们通过 $\text{DFS}$ 可以判断每个点的胜负情况、是否有解。</p><p>我们考虑<strong>逆向思维</strong>，对每个玩家在 $1$ 时的先手状态向前转移，具体过程如下：</p><ol><li>定义 $\text{DFS}(v,now)$ 表示现在是 $now$ 的位置，玩家 $v$ 先手。</li><li>枚举上一次玩家 $u$ 的操作 $x$，那么可以从 $now-x$ 的位置转移到 $now$ 的位置（注意这里的 $now-x$ 不能等于 $1$）。</li><li>如果 $now$ 的位置是<strong>必败态</strong>，那么根据结论：<strong>能转移到必败态的状态就是必胜态</strong>，可以得到 $now-x$ 的位置是必胜态。</li><li>如果 $now$ 的位置是<strong>必胜态</strong>，那么根据结论：<strong>只能转移到必胜态的状态就是必败态</strong>。我们记 $cnt_{u,i}$ 表示在 $i$ 这个位置且 $u$ 先手可以转移到的必胜态数量。当 $cnt_{u,now-x}+1=k_u$ 时，意味着从 $(u,now-x)$ 转移到的所有状态都是必胜态，那么意味着从 $(u,now-x)$ 这个状态为必败态。</li><li>继续 $\text{DFS}(u,now-x)​$ 进行转移即可。</li></ol><p><strong>时间复杂度</strong>：$O(n^2)​$</p><hr><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">7e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,k[<span class="number">2</span>],a[<span class="number">2</span>][N],cnt[<span class="number">2</span>][N];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">2</span>][N],win[<span class="number">2</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[v][now]) <span class="keyword">return</span>;</span><br><span class="line">    vis[v][now]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> u=v^<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k[u];++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> pre=(now-a[u][i]+n<span class="number">-1</span>)%n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pre==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!win[v][now]) &#123;</span><br><span class="line">            win[u][pre]=<span class="number">1</span>;</span><br><span class="line">            dfs(u,pre);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(++cnt[u][pre]==k[u]) &#123;</span><br><span class="line">            win[u][pre]=<span class="number">0</span>;</span><br><span class="line">            dfs(u,pre);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> o=<span class="number">0</span>;o&lt;=<span class="number">1</span>;++o) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k[o]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k[o];++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[o][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>,<span class="number">1</span>),dfs(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> o=<span class="number">0</span>;o&lt;=<span class="number">1</span>;++o) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s%c"</span>,vis[o][i]?win[o][i]?<span class="string">"Win"</span>:<span class="string">"Lose"</span>:<span class="string">"Loop"</span>,<span class="string">" \n"</span>[i==n]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://codeforces.com/contest/786/problem/A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Codeforces 786A&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Rick 和 Morty 在玩一个版本的 Berzerk 游戏。这个游戏需要很大的空间，所以他们使用电脑玩这个游戏。&lt;/p&gt;
&lt;p&gt;游戏中有 $n​$ 个标号从 $1\sim n​$ 的物体围成一个圆圈（顺时针标号）， 物体 $1​$ 表示黑洞，其它物体表示星球，且某一个星球上有一个怪物，Rick 和 Morty 不知道这个怪物在哪个星球上，只知道这个怪物在游戏开始时没有进入黑洞。但就目前而言，他们希望为每种可能的情况做好准备。&lt;/p&gt;
&lt;p&gt;Rick 和 Monty 每人有一个数的集合，集合中的数在 $[1,n-1]$ 之间。Rick 的集合是 $s_1$，其中有 $k_1$ 个数，Morty 的集合是 $s_2$，其中有 $k_2$ 个数。 游戏开始后，两人轮流操作。在操作中，玩家必须从他的集合中选出一个数 $x$， 怪物将从当前位置顺时针移动 $x$ 个位置，如果怪物移动后进入了黑洞，则该玩家获胜。&lt;/p&gt;
&lt;p&gt;你的任务是对于每一个怪物的位置以及玩家先后手顺序，判断游戏先手获胜、后手获胜、无限循环。（每个玩家都采取最优操作）&lt;/p&gt;
&lt;p&gt;数据范围：$2\le n\le 7000$，$1\le k_1,k_2\le n-1$，$1\le s_{i,j}\le n-1$&lt;/p&gt;
    
    </summary>
    
    
      <category term="Codeforces" scheme="http://hydingsy.github.io/tags/Codeforces/"/>
    
      <category term="搜索" scheme="http://hydingsy.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="博弈论" scheme="http://hydingsy.github.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>「Codeforces 1034A」Enlarge GCD</title>
    <link href="http://hydingsy.github.io/articles/problem-Codeforces-1034A-Enlarge-GCD/"/>
    <id>http://hydingsy.github.io/articles/problem-Codeforces-1034A-Enlarge-GCD/</id>
    <published>2019-01-30T16:00:00.000Z</published>
    <updated>2019-01-31T03:31:28.981Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://codeforces.com/contest/1034/problem/A" target="_blank" rel="noopener">Codeforces 1034A</a></p></blockquote><p>Mr. F 现在有 $n$ 个正整数 $a_i$。</p><p>他认为这些数的最大公因数太小了，所以他想通过删除其中的一些数来增大这个最大公因数。你的任务是计算出最少的需要删除的数的个数，使得删除之后剩余数的最大公约数大于删除之前的最大公约数。无解输出 $-1$。</p><p>数据范围：$2\le n\le 3\times 10^5$，$1\le a_i\le 1.5\times 10^7$</p><a id="more"></a><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="朴素思路"><a href="#朴素思路" class="headerlink" title="朴素思路"></a>朴素思路</h3><p>对于最大公约数，我们可以模拟计算的过程，我们写出所有数字的质因子分解式，对于每个小于 $\sqrt{a_i}\approx 4000$ 的质因子，求出其在 $n​$ 个数中最小的指数。</p><p>那么要使得 $\gcd$ 增大，必须使得其中一个质因子的指数变大，因此我们对于每个质因子，统计等于最小指数的数的个数，答案即为最小值。</p><p>但是我们并没有考虑大于 $\sqrt{a_i}$ 的质因子，由于每个数至多只有一个 $&gt;\sqrt {a_i}$ 的质因子，那么我们统计每个大于 $\sqrt{a_i}$ 的质因子个数，记为 $c_i$。如果要使得质因子变大，只需要对 $n-c_i$ 取最小值即可（这里的 $c_i$ 必须满足 $c_i&lt;n$，即 $c_i$ 对原来的最大公约数没有贡献）。</p><p>如果 $ans$ 的值为极大值，那么无解。</p><p>由于小于 $\sqrt{a_i}$ 的质数个数为 $O\left(\frac{\sqrt{a_i}}{\log a_i}\right)$ 个，分解质因子的复杂度为 $O(\log a_i)$，故总复杂度为 $O(n\sqrt{a_i})$。</p><p><strong>时间复杂度</strong>：$O(n\sqrt{a_i})$</p><h3 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h3><p>我们发现，如果把 $a_i$ 都除以 $\gcd(a_1,a_2,\dots,a_n)$，那么此时 $\gcd(a_1,a_2,\dots,a_n)$ 的值就是 $1$ 了，我们的就是使得此时的 $a_i$ 的最大公约数大于 $1$。</p><p>很自然地，我们想到可以枚举 $\gcd(a_1,a_2,\dots,a_n)=d$，然后统计这些 $a_i$ 中有多少个 $d$ 的倍数即可。</p><p>由于质数的个数有 $O\left(\frac{a_i}{\log a_i}\right)$ 个，枚举倍数的复杂度是调和级数，均摊为 $O(\log a_i)$，那么复杂度为 $O(a_i)$（计算 $\gcd$ 需要 $\log a_i​$ 的复杂度）。</p><p><strong>时间复杂度</strong>：$O(a_i)$</p><hr><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><h3 id="朴素思路-1"><a href="#朴素思路-1" class="headerlink" title="朴素思路"></a>朴素思路</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],tot,p[N],mn[N],cnt[N],rcnt[N];</span><br><span class="line"><span class="keyword">bool</span> flg[N];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!flg[i]) p[++tot]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot&amp;&amp;i*p[j]&lt;=n;++j) &#123;</span><br><span class="line">            flg[i*p[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%p[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getcnt</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x%p==<span class="number">0</span>) x/=p,++ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(mn,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(mn));</span><br><span class="line">    <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot;++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> c=getcnt(a[i],p[j]);</span><br><span class="line">            <span class="keyword">if</span>(mn[j]&gt;c) mn[j]=c,cnt[j]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mn[j]==c) ++cnt[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!mp[a[i]]) mp[a[i]]=++idx;</span><br><span class="line">            ++rcnt[mp[a[i]]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;++i) ans=<span class="built_in">std</span>::min(ans,cnt[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=idx;++i) ans=<span class="built_in">std</span>::min(ans,n-rcnt[i]&gt;<span class="number">0</span>?n-rcnt[i]:n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans==n?<span class="number">-1</span>:ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sieve(<span class="number">4000</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化思路-1"><a href="#优化思路-1" class="headerlink" title="优化思路"></a>优化思路</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3e5</span>+<span class="number">5</span>,M=<span class="number">1.5e7</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,tot,a[N],p[M/<span class="number">10</span>],cnt[M];</span><br><span class="line"><span class="keyword">bool</span> flg[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!flg[i]) p[++tot]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot&amp;&amp;i*p[j]&lt;=n;++j) &#123;</span><br><span class="line">            flg[i*p[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%p[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y?gcd(y,x%y):x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> d=<span class="number">0</span>,mx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]),d=gcd(d,a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) a[i]/=d,mx=<span class="built_in">std</span>::max(mx,a[i]),++cnt[a[i]];</span><br><span class="line">    sieve(mx);</span><br><span class="line">    <span class="keyword">int</span> ans=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x=p[i],num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=x;j&lt;=mx;j+=x) num+=cnt[j];</span><br><span class="line">        <span class="keyword">if</span>(num) ans=<span class="built_in">std</span>::min(ans,n-num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans==n?<span class="number">-1</span>:ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://codeforces.com/contest/1034/problem/A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Codeforces 1034A&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Mr. F 现在有 $n$ 个正整数 $a_i$。&lt;/p&gt;
&lt;p&gt;他认为这些数的最大公因数太小了，所以他想通过删除其中的一些数来增大这个最大公因数。你的任务是计算出最少的需要删除的数的个数，使得删除之后剩余数的最大公约数大于删除之前的最大公约数。无解输出 $-1$。&lt;/p&gt;
&lt;p&gt;数据范围：$2\le n\le 3\times 10^5$，$1\le a_i\le 1.5\times 10^7$&lt;/p&gt;
    
    </summary>
    
    
      <category term="线性筛" scheme="http://hydingsy.github.io/tags/%E7%BA%BF%E6%80%A7%E7%AD%9B/"/>
    
      <category term="贪心" scheme="http://hydingsy.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="GCD" scheme="http://hydingsy.github.io/tags/GCD/"/>
    
      <category term="Codeforces" scheme="http://hydingsy.github.io/tags/Codeforces/"/>
    
  </entry>
  
  <entry>
    <title>「Codeforces 776E」The Holmes Children</title>
    <link href="http://hydingsy.github.io/articles/problem-Codeforces-776E-The-Holmes-Children/"/>
    <id>http://hydingsy.github.io/articles/problem-Codeforces-776E-The-Holmes-Children/</id>
    <published>2019-01-29T16:00:00.000Z</published>
    <updated>2019-01-31T02:20:16.269Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://codeforces.com/contest/776/problem/E" target="_blank" rel="noopener">Codeforces 776E</a></p></blockquote><p>Holmes 的孩子们在争论谁才是他们中最聪明的。</p><p>Mycroft 提出了如下的函数求值问题：已知 $f(1)=1​$，且当 $n\ge 2​$ 时，$f(n)​$ 表示满足 $x+y=n​$ 的互质的正整数对 $(x,y)​$ 的对数，$g(n)=\sum_{d\mid n}f\left(\frac{n}{d}\right)​$。</p><p>她定义了一个函数 $F_k(n)$，其值可以通过如下式子递归求解：</p><script type="math/tex; mode=display">F_k(n)=\begin{cases}f(g(n)) & k=1 \\g(F_{k-1}(n)) & k>1,k\bmod 2=0 \\f(F_{k-1}(n)) & k>1,k\bmod 2 =1\end{cases}</script><p>现在她希望你对于给定 $n,k$，求出 $F_k(n)\bmod 1000000007$ 的值。</p><p>数据范围：$1\le n,k\le 10^{12}$</p><a id="more"></a><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>我们先推导一下 $f(n)$ 和 $g(n)$ 函数到底长成什么样子：</p><script type="math/tex; mode=display">\begin{aligned}f(n) & =\sum_{i=1}^{n-1} [\gcd(i,n-i)=1] \\&=\sum_{i=1}^{n-1}[\gcd(i,n)=1] \\&=\varphi(n)\end{aligned}</script><p>由于 $f(n)$ 就是 $\varphi(n)$ 函数，那么 $g(n)$ 函数可以通过如下式子表示：</p><script type="math/tex; mode=display">\begin{aligned}g(n) & =\sum_{d\mid n} f\left(\frac{n}{d}\right) \\& = \sum_{d\mid n} \varphi\left(\frac{n}{d}\right)\end{aligned}</script><p>显然这是一个卷积的形式：</p><script type="math/tex; mode=display">g=\varphi\ast 1=\texttt{ID}</script><p>因此 $g(n)=n$！</p><p>那么递归式变为：</p><script type="math/tex; mode=display">F_k(n)=\begin{cases}\varphi(n) & k=1 \\F_{k-1}(n) & k>1,k\bmod 2=0 \\\varphi(F_{k-1}(n)) & k>1,k\bmod 2 =1\end{cases}</script><p>我们可以找规律发现，$F_k(n)$ 的值就是对 $n$ 求 $\left\lfloor\frac{k+1}{2}\right\rfloor$ 次 $\varphi$ 函数。</p><p>显然我们不能真的求 $O(k)​$ 次 $\varphi​$，由于 $n​$ 求 $O(\log n)​$ 次 $\varphi​$ 的值就是 $1​$，此时再求 $\varphi​$ 就没有意义了。故我们只需要求 $\max\left(\log n,\left\lfloor\frac{k+1}{2}\right\rfloor\right)​$ 次 $\varphi​$ 即可。</p><p><strong>时间复杂度</strong>：$O\left(\max\left(\log n,\left\lfloor\frac{k+1}{2}\right\rfloor\right)\sqrt n\right)​$</p><hr><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> tot,p[N];</span><br><span class="line"><span class="keyword">bool</span> flg[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!flg[i]) p[++tot]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot&amp;&amp;i*p[j]&lt;=n;++j) &#123;</span><br><span class="line">            flg[i*p[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%p[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">phi</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot&amp;&amp;<span class="number">1L</span>L*p[i]*p[i]&lt;=x;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(x%p[i]) <span class="keyword">continue</span>;</span><br><span class="line">        ans=ans/p[i]*(p[i]<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">while</span>(x%p[i]==<span class="number">0</span>) x/=p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">1</span>) ans=ans/x*(x<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sieve(N<span class="number">-5</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;k);</span><br><span class="line">    k=(k+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=k&amp;&amp;n&gt;<span class="number">1</span>;++i) &#123;</span><br><span class="line">        n=phi(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,n%<span class="number">1000000007</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://codeforces.com/contest/776/problem/E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Codeforces 776E&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Holmes 的孩子们在争论谁才是他们中最聪明的。&lt;/p&gt;
&lt;p&gt;Mycroft 提出了如下的函数求值问题：已知 $f(1)=1​$，且当 $n\ge 2​$ 时，$f(n)​$ 表示满足 $x+y=n​$ 的互质的正整数对 $(x,y)​$ 的对数，$g(n)=\sum_{d\mid n}f\left(\frac{n}{d}\right)​$。&lt;/p&gt;
&lt;p&gt;她定义了一个函数 $F_k(n)$，其值可以通过如下式子递归求解：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
F_k(n)=\begin{cases}
f(g(n)) &amp; k=1 \\
g(F_{k-1}(n)) &amp; k&gt;1,k\bmod 2=0 \\
f(F_{k-1}(n)) &amp; k&gt;1,k\bmod 2 =1
\end{cases}&lt;/script&gt;&lt;p&gt;现在她希望你对于给定 $n,k$，求出 $F_k(n)\bmod 1000000007$ 的值。&lt;/p&gt;
&lt;p&gt;数据范围：$1\le n,k\le 10^{12}$&lt;/p&gt;
    
    </summary>
    
    
      <category term="欧拉函数" scheme="http://hydingsy.github.io/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"/>
    
      <category term="线性筛" scheme="http://hydingsy.github.io/tags/%E7%BA%BF%E6%80%A7%E7%AD%9B/"/>
    
      <category term="Codeforces" scheme="http://hydingsy.github.io/tags/Codeforces/"/>
    
  </entry>
  
  <entry>
    <title>「BZOJ 3813」奇数国</title>
    <link href="http://hydingsy.github.io/articles/problem-BZOJ-3813-Odd-Number-Country/"/>
    <id>http://hydingsy.github.io/articles/problem-BZOJ-3813-Odd-Number-Country/</id>
    <published>2019-01-28T16:00:00.000Z</published>
    <updated>2019-02-07T04:13:40.118Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3813" target="_blank" rel="noopener">BZOJ 3813</a></p></blockquote><p>在一片美丽的大陆上有 $100000$ 个国家，每个国家有一个银行。某大公司的领袖在这 $100000$ 个银行开户时都存了 $3$ 大洋，他惜财如命，因此会不时地派小弟 GFS 清点一些银行的存款或者让 GFS 改变某个银行的存款。这里发行的软妹面额是最小的 $60$ 个素数，任何人的财产都只能由这 $60​$ 个基本面额表示。</p><p>领袖习惯将一段编号连续的银行里的存款拿到一个账房去清点。如果领袖选择清点编号在 $[a,b]$ 内的银行财产，他会先对 $[a,b]$ 的财产求和（计为 $\text{product}$），然后在编号属于 $[1,\text{product}]$ 的账房中选择一个去清点存款。一个账房 $\text{number}$ 可能被选中当且仅当 $\gcd(\text{product},\text{number})=1$。当领袖又赚大钱了的时候，他会在某个银行改变存款，但是领袖不会在某个银行的存款总数超过 $10^6$。</p><p>现在 GFS 预先知道了领袖的清点存款与变动存款的 $x$ 次计划，想请你告诉他，每次清点存款时领袖有多少个账房可以供他选择，当然这个值可能非常大，GFS 只想知道对 $19961993$ 取模后的答案。</p><p>数据范围：$1\le x\le 10^5$</p><a id="more"></a><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>我们注意到，每个数的标准分解形式中只有可能出现前 $60​$ 个数字，那么我们考虑用<strong>线段树</strong>维护区间内<strong>每个质因子是否出现过</strong>（笔者使用压位，用 $\text{long long}​$ 储存，操作起来较为简单），并维护<strong>区间内的乘积</strong>。统计答案时，我们只需要求出区间的乘积的 $\varphi​$ 函数值即可。</p><p><strong>时间复杂度</strong>：$O(60\cdot m\log n)​$</p><hr><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson p&lt;&lt;1|1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> prime[]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">37</span>,<span class="number">41</span>,<span class="number">43</span>,<span class="number">47</span>,<span class="number">53</span>,<span class="number">59</span>,<span class="number">61</span>,<span class="number">67</span>,<span class="number">71</span>,<span class="number">73</span>,<span class="number">79</span>,<span class="number">83</span>,<span class="number">89</span>,<span class="number">97</span>,<span class="number">101</span>,<span class="number">103</span>,<span class="number">107</span>,<span class="number">109</span>,<span class="number">113</span>,<span class="number">127</span>,<span class="number">131</span>,<span class="number">137</span>,<span class="number">139</span>,<span class="number">149</span>,<span class="number">151</span>,<span class="number">157</span>,<span class="number">163</span>,<span class="number">167</span>,<span class="number">173</span>,<span class="number">179</span>,<span class="number">181</span>,<span class="number">191</span>,<span class="number">193</span>,<span class="number">197</span>,<span class="number">199</span>,<span class="number">211</span>,<span class="number">223</span>,<span class="number">227</span>,<span class="number">229</span>,<span class="number">233</span>,<span class="number">239</span>,<span class="number">241</span>,<span class="number">251</span>,<span class="number">257</span>,<span class="number">263</span>,<span class="number">269</span>,<span class="number">271</span>,<span class="number">277</span>,<span class="number">281</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> invpr[]=&#123;<span class="number">9980997</span>,<span class="number">6653998</span>,<span class="number">11977196</span>,<span class="number">8555140</span>,<span class="number">5444180</span>,<span class="number">1535538</span>,<span class="number">10568114</span>,<span class="number">14708837</span>,<span class="number">3471651</span>,<span class="number">11701858</span>,<span class="number">17386252</span>,<span class="number">1618540</span>,<span class="number">16066970</span>,<span class="number">2321162</span>,<span class="number">18263100</span>,<span class="number">16948862</span>,<span class="number">12518538</span>,<span class="number">15380552</span>,<span class="number">10725847</span>,<span class="number">1686929</span>,<span class="number">13399146</span>,<span class="number">17182475</span>,<span class="number">12025297</span>,<span class="number">15924736</span>,<span class="number">13582387</span>,<span class="number">395287</span>,<span class="number">6395590</span>,<span class="number">15857658</span>,<span class="number">16299242</span>,<span class="number">6359573</span>,<span class="number">3300802</span>,<span class="number">18742940</span>,<span class="number">6702567</span>,<span class="number">10914471</span>,<span class="number">16210746</span>,<span class="number">11765678</span>,<span class="number">5340151</span>,<span class="number">18247466</span>,<span class="number">7769638</span>,<span class="number">8077107</span>,<span class="number">11932588</span>,<span class="number">6506948</span>,<span class="number">1985748</span>,<span class="number">6619521</span>,<span class="number">5877135</span>,<span class="number">4413707</span>,<span class="number">9744480</span>,<span class="number">10115270</span>,<span class="number">14597757</span>,<span class="number">16475182</span>,<span class="number">18334191</span>,<span class="number">5011379</span>,<span class="number">18885205</span>,<span class="number">7555336</span>,<span class="number">621385</span>,<span class="number">11309266</span>,<span class="number">12170137</span>,<span class="number">12006660</span>,<span class="number">18304499</span>,<span class="number">11153142</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">19961993</span>;</span><br><span class="line"><span class="keyword">int</span> n=<span class="number">100000</span>,m,a[N],mul[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> seg[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    seg[p]=seg[lson]|seg[rson];</span><br><span class="line">    mul[p]=<span class="number">1L</span>L*mul[lson]*mul[rson]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">long</span> <span class="keyword">long</span> f,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">        seg[p]^=f,mul[p]=v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) modify(x,lson,l,mid,f,v);</span><br><span class="line">    <span class="keyword">else</span> modify(x,rson,mid+<span class="number">1</span>,r,f,v);</span><br><span class="line">    pushup(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">queryFac</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y) <span class="keyword">return</span> seg[p];</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) ans|=queryFac(x,y,lson,l,mid);</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;y) ans|=queryFac(x,y,rson,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queryMul</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y) <span class="keyword">return</span> mul[p];</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) ans=<span class="number">1L</span>L*ans*queryMul(x,y,lson,l,mid)%mod;</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;y) ans=<span class="number">1L</span>L*ans*queryMul(x,y,rson,mid+<span class="number">1</span>,r)%mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=queryMul(l,r,<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> f=queryFac(l,r,<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">60</span>;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(f&amp;(<span class="number">1L</span>L&lt;&lt;i)) ans=<span class="number">1L</span>L*ans*invpr[i]%mod*(prime[i]<span class="number">-1</span>)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">60</span>;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(val%prime[i]==<span class="number">0</span>) f^=<span class="number">1L</span>L&lt;&lt;i;#</span><br><span class="line">    &#125;</span><br><span class="line">    modify(x,<span class="number">1</span>,<span class="number">1</span>,n,f,val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) a[i]=<span class="number">3</span>,modify(i,<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">2</span>,a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);m--;) &#123;</span><br><span class="line">        <span class="keyword">int</span> o,x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;o,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(o==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query(x,y));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ins(x,a[x]),ins(x,a[x]=y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=3813&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ 3813&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在一片美丽的大陆上有 $100000$ 个国家，每个国家有一个银行。某大公司的领袖在这 $100000$ 个银行开户时都存了 $3$ 大洋，他惜财如命，因此会不时地派小弟 GFS 清点一些银行的存款或者让 GFS 改变某个银行的存款。这里发行的软妹面额是最小的 $60$ 个素数，任何人的财产都只能由这 $60​$ 个基本面额表示。&lt;/p&gt;
&lt;p&gt;领袖习惯将一段编号连续的银行里的存款拿到一个账房去清点。如果领袖选择清点编号在 $[a,b]$ 内的银行财产，他会先对 $[a,b]$ 的财产求和（计为 $\text{product}$），然后在编号属于 $[1,\text{product}]$ 的账房中选择一个去清点存款。一个账房 $\text{number}$ 可能被选中当且仅当 $\gcd(\text{product},\text{number})=1$。当领袖又赚大钱了的时候，他会在某个银行改变存款，但是领袖不会在某个银行的存款总数超过 $10^6$。&lt;/p&gt;
&lt;p&gt;现在 GFS 预先知道了领袖的清点存款与变动存款的 $x$ 次计划，想请你告诉他，每次清点存款时领袖有多少个账房可以供他选择，当然这个值可能非常大，GFS 只想知道对 $19961993$ 取模后的答案。&lt;/p&gt;
&lt;p&gt;数据范围：$1\le x\le 10^5$&lt;/p&gt;
    
    </summary>
    
    
      <category term="数论" scheme="http://hydingsy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="数据结构" scheme="http://hydingsy.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="线段树" scheme="http://hydingsy.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="欧拉函数" scheme="http://hydingsy.github.io/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"/>
    
      <category term="BZOJ" scheme="http://hydingsy.github.io/tags/BZOJ/"/>
    
  </entry>
  
  <entry>
    <title>「Luogu 5179」Fraction</title>
    <link href="http://hydingsy.github.io/articles/problem-Luogu-5179-Fraction/"/>
    <id>http://hydingsy.github.io/articles/problem-Luogu-5179-Fraction/</id>
    <published>2019-01-28T16:00:00.000Z</published>
    <updated>2019-02-07T04:13:40.218Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://www.luogu.org/problemnew/show/P5179" target="_blank" rel="noopener">Luogu 5179</a></p></blockquote><p>给你四个正整数 $a,b,c,d$，求一个最简分数 $\frac{p}{q}$ 满足 $\frac{a}{b}&lt;\frac{p}{q}&lt;\frac{c}{d}​$。</p><p>若有多组解，输出 $q$ 最小的一组，若仍有多组解，输出 $p$ 最小的一组。数据保证至少存在一个最简分数符合条件。</p><p>本题 $T$ 组数据。</p><p>数据范围：$1\le T\le 500$，$1\le a,b,c,d\le 10^9$</p><a id="more"></a><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>其实这个问题的本质是<strong>类欧几里德算法</strong>。我们分为如下 $3$ 种情况考虑：</p><ol><li><p>$\left\lfloor\frac{a}{b}\right\rfloor+1\le\left\lceil\frac{c}{d}\right\rceil-1​$</p><p>这意味着 $\left(\frac{a}{b},\frac{c}{d}\right)$ 之间存在一个整数，我们直接让 $p=1,p=\left\lfloor\frac{a}{b}\right\rfloor+1$ 即可。</p></li><li><p>$a=0$</p><p>这意味着只需要满足 $\frac{p}{q}&lt;\frac{c}{d}​$，即为 $q&gt;\frac{pd}{c}​$。我们为了取得最优解，可以直接取 $p=1,q=\left\lfloor\frac{d}{c}\right\rfloor+1​$。</p></li><li><p>$a\le b$ 且 $c\le d$</p><p>这意味着我们无法直接求解，需要进行一个<strong>转化</strong>：将原式 $\frac{a}{b}&lt;\frac{p}{q}&lt;\frac{c}{d}​$ 的每个分数都取倒数，由于每个数都是正数，那么可以得到 $\frac{d}{c}&lt;\frac{q}{p}&lt;\frac{b}{a}​$，直接<strong>递归处理</strong>即可。</p></li><li><p>$a\ge b$</p><p>这意味着第 $1$ 个分数和第 $3$ 个分数的整数部分都大于 $0$。接下来要进行一个<strong>重要的转化</strong>：我们可以将每个分数减去 $\left\lfloor\frac{a}{b}\right\rfloor$，直接递归处理 $\frac{a\bmod b}{b}&lt;\frac{p}{q}-\left\lfloor\frac{a}{b}\right\rfloor&lt;\frac{c}{d}-\left\lfloor\frac{a}{b}\right\rfloor$ 即可。注意递归处理完后，需要将 $p$ 加上 $q\times \left\lfloor\frac{a}{b}\right\rfloor$。</p></li></ol><p>这个过程中形式上极其类似于欧几里德算法，将 $(a,b)$ 转化为 $(a\bmod b,b)$ 正是其精髓所在。</p><hr><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL x,LL y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y?gcd(y,x%y):x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sim</span><span class="params">(LL &amp;x,LL &amp;y)</span> </span>&#123;</span><br><span class="line">    LL d=gcd(x,y); x/=d,y/=d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(LL a,LL b,LL c,LL d,LL &amp;p,LL &amp;q)</span> </span>&#123;</span><br><span class="line">    sim(a,b),sim(c,d);</span><br><span class="line">    LL x=a/b+<span class="number">1</span>,y=(c<span class="number">-1</span>)/d;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=y) p=x,q=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!a) p=<span class="number">1</span>,q=d/c+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a&lt;=b&amp;&amp;c&lt;=d) solve(d,c,b,a,q,p);</span><br><span class="line">    <span class="keyword">else</span> solve(a%b,b,c-d*(a/b),d,p,q),p+=q*(a/b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LL a,b,c,d,p,q;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>,&amp;a,&amp;b,&amp;c,&amp;d)) &#123;</span><br><span class="line">        solve(a,b,c,d,p,q);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld/%lld\n"</span>,p,q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.luogu.org/problemnew/show/P5179&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Luogu 5179&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;给你四个正整数 $a,b,c,d$，求一个最简分数 $\frac{p}{q}$ 满足 $\frac{a}{b}&amp;lt;\frac{p}{q}&amp;lt;\frac{c}{d}​$。&lt;/p&gt;
&lt;p&gt;若有多组解，输出 $q$ 最小的一组，若仍有多组解，输出 $p$ 最小的一组。数据保证至少存在一个最简分数符合条件。&lt;/p&gt;
&lt;p&gt;本题 $T$ 组数据。&lt;/p&gt;
&lt;p&gt;数据范围：$1\le T\le 500$，$1\le a,b,c,d\le 10^9$&lt;/p&gt;
    
    </summary>
    
    
      <category term="类欧几里德算法" scheme="http://hydingsy.github.io/tags/%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7%E7%AE%97%E6%B3%95/"/>
    
      <category term="Luogu" scheme="http://hydingsy.github.io/tags/Luogu/"/>
    
  </entry>
  
  <entry>
    <title>「BZOJ 4804」欧拉心算</title>
    <link href="http://hydingsy.github.io/articles/problem-BZOJ-4804-Euler-Mental-Arithmetic/"/>
    <id>http://hydingsy.github.io/articles/problem-BZOJ-4804-Euler-Mental-Arithmetic/</id>
    <published>2019-01-28T16:00:00.000Z</published>
    <updated>2019-02-07T04:13:40.128Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4804" target="_blank" rel="noopener">BZOJ 4804</a></p></blockquote><p>求如下式子的值：</p><script type="math/tex; mode=display">\sum_{i=1}^n\sum_{j=1}^n\varphi(\gcd(i,j))</script><p>本题 $T$ 组数据。</p><p>数据范围：$1\le T\le 5000$，$1\le n\le 10^7$</p><a id="more"></a><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>我们直接拆式子：</p><script type="math/tex; mode=display">\begin{aligned}\text{原式}&=\sum_{i=1}^n\sum_{j=1}^n\varphi(\gcd(i,j)) \\&=\sum_{d=1}^n\varphi(d)\sum_{i=1}^n\sum_{j=1}^n \left[\gcd(i,j)=d\right] \\&=\sum_{d=1}^n\varphi(d)\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\left[\gcd(i,j)=1\right]\\&=\sum_{d=1}^n\varphi(d)\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}2\times\varphi(i)-1\end{aligned}</script><p>我们记 $sum(k)=\sum_{i=1}^k\varphi(i)$，那么有：</p><script type="math/tex; mode=display">\begin{aligned}\text{原式}&=\sum_{d=1}^n\varphi(d)\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}2\times\varphi(i)-1 \\&=\sum_{d=1}^n\varphi(d)(2\times sum\left(\left\lfloor\frac{n}{d}\right\rfloor\right)-1)\end{aligned}</script><p>我们发现这里的 $\left\lfloor\frac{n}{d}\right\rfloor$ 只有 $\sqrt n$ 种取值，因此我们可以<strong>数论分块</strong>求解。</p><p><strong>时间复杂度</strong>：$O(T\sqrt n)​$</p><hr><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e7</span>+<span class="number">5</span>,M=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,tot,p[M],phi[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[N];</span><br><span class="line"><span class="keyword">bool</span> flg[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!flg[i]) p[++tot]=i,phi[i]=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot&amp;&amp;i*p[j]&lt;=n;++j) &#123;</span><br><span class="line">            flg[i*p[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%p[j]==<span class="number">0</span>) &#123;</span><br><span class="line">                phi[i*p[j]]=phi[i]*p[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                phi[i*p[j]]=phi[i]*phi[p[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) sum[i]=sum[i<span class="number">-1</span>]+phi[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sieve(N<span class="number">-5</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);T--;) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j;i&lt;=n;i=j+<span class="number">1</span>) &#123;</span><br><span class="line">            j=n/(n/i);</span><br><span class="line">            ans+=(<span class="number">2L</span>L*sum[n/i]<span class="number">-1</span>)*(sum[j]-sum[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=4804&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ 4804&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;求如下式子的值：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\sum_{i=1}^n\sum_{j=1}^n\varphi(\gcd(i,j))&lt;/script&gt;&lt;p&gt;本题 $T$ 组数据。&lt;/p&gt;
&lt;p&gt;数据范围：$1\le T\le 5000$，$1\le n\le 10^7$&lt;/p&gt;
    
    </summary>
    
    
      <category term="数论" scheme="http://hydingsy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="欧拉函数" scheme="http://hydingsy.github.io/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"/>
    
      <category term="BZOJ" scheme="http://hydingsy.github.io/tags/BZOJ/"/>
    
      <category term="数论分块" scheme="http://hydingsy.github.io/tags/%E6%95%B0%E8%AE%BA%E5%88%86%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>「HDU 1299」Diophantus of Alexandria</title>
    <link href="http://hydingsy.github.io/articles/problem-HDU-1299-Diophantus-of-Alexandria/"/>
    <id>http://hydingsy.github.io/articles/problem-HDU-1299-Diophantus-of-Alexandria/</id>
    <published>2019-01-28T16:00:00.000Z</published>
    <updated>2019-02-07T04:13:40.168Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1299" target="_blank" rel="noopener">HDU 1299</a></p></blockquote><p>求解如下丢番图方程的正整数解个数：</p><script type="math/tex; mode=display">\frac{1}{x}+\frac{1}{y}=\frac{1}{n}\quad (x,y,n\in\mathbb{N}^+,x\le y)</script><p>本题 $T$ 组数据。</p><p>数据范围：$1\le n\le 10^9$</p><a id="more"></a><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>我们先将方程消去分母：</p><script type="math/tex; mode=display">xy-n(x+y)=0</script><p>由于 $xy$ 中 $x$ 和 $y$ 都是二次的，那么我们使用<strong>十字相乘法</strong>，将未知数放在方程左侧：</p><script type="math/tex; mode=display">(x-n)(y-n)=n^2</script><p>此时我们发现 $x$ 和 $y$ 都是一次的了，只需要将 $n^2$ 分解质因子，用<strong>约数和定理</strong>来计算答案即可。</p><script type="math/tex; mode=display">\sigma(n)=\prod(c_i+1)</script><p><strong>时间复杂度</strong>：$O(T\sqrt n)​$</p><hr><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T,cs=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);T--;) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=n;++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(n%i==<span class="number">0</span>) n/=i,++cnt;</span><br><span class="line">            ans*=<span class="number">2</span>*cnt+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n&gt;<span class="number">1</span>) ans*=<span class="number">3</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Scenario #%d:\n%d\n\n"</span>,++cs,(ans+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=1299&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HDU 1299&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;求解如下丢番图方程的正整数解个数：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\frac{1}{x}+\frac{1}{y}=\frac{1}{n}\quad (x,y,n\in\mathbb{N}^+,x\le y)&lt;/script&gt;&lt;p&gt;本题 $T$ 组数据。&lt;/p&gt;
&lt;p&gt;数据范围：$1\le n\le 10^9$&lt;/p&gt;
    
    </summary>
    
    
      <category term="数论" scheme="http://hydingsy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="HDU" scheme="http://hydingsy.github.io/tags/HDU/"/>
    
      <category term="约数和定理" scheme="http://hydingsy.github.io/tags/%E7%BA%A6%E6%95%B0%E5%92%8C%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>「Codeforces 724C」Ray Tracing</title>
    <link href="http://hydingsy.github.io/articles/problem-Codeforces-724C-Ray-Tracing/"/>
    <id>http://hydingsy.github.io/articles/problem-Codeforces-724C-Ray-Tracing/</id>
    <published>2019-01-28T16:00:00.000Z</published>
    <updated>2019-02-07T04:13:40.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://codeforces.com/contest/724/problem/C" target="_blank" rel="noopener">Codeforces 724C</a></p></blockquote><p>有一个 $n\times m$ 的矩形，四周有围墙围起来，其左上角和右下角的坐标分别为 $(0,0)$ 和 $(n,m)$。从 $(0,0)$ 开始以 $\sqrt 2$ 个单位每秒的速度向 $(1,1)$ 的方向发射一束光线，每次遇到墙都正常反射（符合物理的反射），光线射到顶点会被吸收。在这个矩形内有 $k$ 个点，坐标分别为 $(x_i,y_i)$，求每个点第一次被光线经过的时刻。</p><p>数据范围：$2\le n,m\le 10^5$，$1\le k\le 10^5$，$1\le x_i&lt;n$，$1\le y_i&lt;m$</p><a id="more"></a><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>对于这类矩形内上的反射问题，我们可以将矩形<strong>无限展开</strong>，那么相当于我们把点按照矩形边界<strong>对称</strong>，光线也就边成了<strong>一条直线</strong>。</p><p>我们考虑对称后的点的坐标是什么。如果原来的坐标为 $(x,y)$，那么按照第 $k$ 条横轴展开的坐标为 $(x,2km-y)$，按照第 $k$ 条纵轴展开的左边为 $(kn-x,y)$。因此，如果我们沿着若干条轴展开后，坐标一定可以写成 $(k_1n\pm x,k_2m\pm y)$ 的形式。</p><p>由于我们知道了展开后的坐标，那么有如下方程：</p><script type="math/tex; mode=display">k_1n\pm x=k_2m\pm y\Longrightarrow k_1n-k_2m=\pm x\pm y</script><p>发现这是一个<strong>丢番图方程</strong>，我们可以直接解出 $(k_1,k_2)$ 的通解。</p><p>但是，题目中规定光线在矩形顶点位置会被吸收，那么我们就要保证<strong>坐标的绝对值小于等于 $\operatorname{lcm}(n,m)$</strong>，否则光线一定会经过 $\operatorname{lcm}(n,m)$ 这个点而被吸收。</p><p>因此，我们对 $4$ 种情况分别求解，找到一组解使得 $k_1n\pm x$ 的值尽量小且大于 $0$。形象地说，就是使得 $k_1n\pm x$ 最小并满足 $0&lt;k_1n\pm x&lt;\operatorname{lcm}(n,m)​$。</p><p>这个最小的符合条件的解就是答案。</p><p><strong>时间复杂度</strong>：$O(k\log n)$</p><hr><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LL INF=<span class="number">1L</span>L&lt;&lt;<span class="number">60</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line">LL mx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b?gcd(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) &#123;x=<span class="number">1</span>,y=<span class="number">0</span>;<span class="keyword">return</span> a;&#125;</span><br><span class="line">    <span class="keyword">int</span> d=exgcd(b,a%b,y,x);</span><br><span class="line">    y-=a/b*x; <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(<span class="keyword">int</span> dx,<span class="keyword">int</span> dy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">2</span>*n,b=<span class="number">-2</span>*m,c=dy-dx,x,y;</span><br><span class="line">    <span class="keyword">int</span> d=exgcd(a,b,x,y);</span><br><span class="line">    <span class="keyword">if</span>(c%d) <span class="keyword">return</span> INF;</span><br><span class="line">    a/=d,b/=d,c/=d,b=<span class="built_in">std</span>::<span class="built_in">abs</span>(b),x=(x*c%b+b)%b;</span><br><span class="line">    LL ans=<span class="number">2L</span>L*n*x+dx;</span><br><span class="line">    <span class="keyword">if</span>(ans&lt;=<span class="number">0</span>||ans&gt;=mx) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    mx=<span class="number">1L</span>L*n*m/gcd(n,m);</span><br><span class="line">    <span class="keyword">while</span>(k--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x0,y0;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x0,&amp;y0);</span><br><span class="line">        LL ans=INF;</span><br><span class="line">        ans=<span class="built_in">std</span>::min(ans,solve(+x0,+y0));</span><br><span class="line">        ans=<span class="built_in">std</span>::min(ans,solve(+x0,-y0));</span><br><span class="line">        ans=<span class="built_in">std</span>::min(ans,solve(-x0,+y0));</span><br><span class="line">        ans=<span class="built_in">std</span>::min(ans,solve(-x0,-y0));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans==INF?<span class="number">-1</span>:ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://codeforces.com/contest/724/problem/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Codeforces 724C&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有一个 $n\times m$ 的矩形，四周有围墙围起来，其左上角和右下角的坐标分别为 $(0,0)$ 和 $(n,m)$。从 $(0,0)$ 开始以 $\sqrt 2$ 个单位每秒的速度向 $(1,1)$ 的方向发射一束光线，每次遇到墙都正常反射（符合物理的反射），光线射到顶点会被吸收。在这个矩形内有 $k$ 个点，坐标分别为 $(x_i,y_i)$，求每个点第一次被光线经过的时刻。&lt;/p&gt;
&lt;p&gt;数据范围：$2\le n,m\le 10^5$，$1\le k\le 10^5$，$1\le x_i&amp;lt;n$，$1\le y_i&amp;lt;m$&lt;/p&gt;
    
    </summary>
    
    
      <category term="数论" scheme="http://hydingsy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="同余" scheme="http://hydingsy.github.io/tags/%E5%90%8C%E4%BD%99/"/>
    
      <category term="exGCD" scheme="http://hydingsy.github.io/tags/exGCD/"/>
    
      <category term="Codeforces" scheme="http://hydingsy.github.io/tags/Codeforces/"/>
    
  </entry>
  
</feed>
