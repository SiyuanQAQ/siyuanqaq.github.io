<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[「HNOI 2010」弹飞绵羊]]></title>
    <url>%2Farticles%2Fproblem-HNOI-2010-Bounce-Sheep%2F</url>
    <content type="text"><![CDATA[Description 题目链接：BZOJ 2002 某天，Lostmonkey 发明了一种超级弹力装置，为了在他的绵羊朋友面前显摆，他邀请小绵羊一起玩个游戏。游戏一开始，Lostmonkey 在地上沿着一条直线摆上 $n$ 个装置，每个装置设定初始弹力系数 $k_i$，当绵羊达到第 $i$ 个装置时，它会往后弹 $k_i$ 步，达到第 $i+k_i$ 个装置，若不存在第 $i+k_i$ 个装置，则绵羊被弹飞。绵羊想知道当它从第 $i$ 个装置起步时，被弹几次后会被弹飞。为了使得游戏更有趣，Lostmonkey 可以修改某个弹力装置的弹力系数，任何时候弹力系数均为正整数。 数据范围：$1\le n\le 2\times 10^5$，$1\le m\le 10^5$ Solution解法 1（LCT）首先我们建立一个虚点 $n+1$，意味着绵羊到达这个点就被弹飞。 对于每个装置，如果 $i+k_i\le n$，那么我们连边 $(i,i+k_i)$，否则连边 $(i,n+1)$。 对于修改操作，显然我们需要断开原来的边 $(i,i+k_i)$ 或 $(i,n+1)$，连上新的边 $(i,i+k)$ 或 $(i,n+1)$。由于要动态连边和删边，我们可以很自然地想到 $\text{LCT}$。 接下来我们考虑询问操作。对于询问 $x$，我们要查询的就是 $x$ 到 $n+1$ 这条链上的边的数量。于是我们就可以用 $\text{LCT}$ 的 $\text{split}$ 操作，得到 $x$ 到 $n+1$ 这条链的 $\text{Splay}$。我们只要维护 $\text{Splay}$ 中的节点个数，那么答案就是 $size_{n+1}-1$ 了。 时间复杂度：$O(m\log n)$ 解法 2（分块）考虑 $\sqrt n$ 分块。我们维护每个点它在块内可以往后跳动的次数，记为 $cnt_i$；跳动后到达块内最远点的位置（如果直接跳出块，那么记录跳动一次到达的位置），记为 $pos_i$。 对于修改操作，我们对 $x$ 所在块的信息暴力重新计算，复杂度为 $O(\sqrt n)$。 对于查询操作，我们从 $x$ 往后暴力跳，因为每个块内经过的次数是 $O(1)$ 的，那么复杂度为 $O(\sqrt n)$。 时间复杂度：$O(m\sqrt n)$（由于常数问题，分块比 $\text{LCT}$ 跑的要快 QAQ） Code解法 1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define ls(x) ch[x][0]#define rs(x) ch[x][1]const int N=2e5+5;int n,m,k[N],fa[N],ch[N][2],sz[N],st[N];bool rev[N];bool get(int x) &#123; return rs(fa[x])==x;&#125;bool isroot(int x) &#123; return ls(fa[x])!=x&amp;&amp;rs(fa[x])!=x;&#125;void pushup(int x) &#123; sz[x]=sz[ls(x)]+sz[rs(x)]+1;&#125;void pushdown(int x) &#123; if(rev[x]) &#123; std::swap(ls(x),rs(x)); rev[ls(x)]^=1,rev[rs(x)]^=1,rev[x]=0; &#125;&#125;void rotate(int x) &#123; int y=fa[x],z=fa[y],k=get(x); !isroot(y)&amp;&amp;(ch[z][get(y)]=x),fa[x]=z; ch[y][k]=ch[x][k^1],fa[ch[x][k^1]]=y; ch[x][k^1]=y,fa[y]=x; pushup(y),pushup(x);&#125;void splay(int x) &#123; int u=x,tp=0; st[++tp]=u; while(!isroot(u)) st[++tp]=u=fa[u]; while(tp) pushdown(st[tp--]); while(!isroot(x)) &#123; int y=fa[x]; if(!isroot(y)) rotate(get(x)==get(y)?y:x); rotate(x); &#125;&#125;void access(int x) &#123; for(int y=0;x;x=fa[y=x]) splay(x),rs(x)=y,pushup(x);&#125;void makeroot(int x) &#123; access(x),splay(x),rev[x]^=1;&#125;int findroot(int x) &#123; access(x),splay(x); pushdown(x); while(ls(x)) pushdown(x=ls(x)); return x;&#125;void split(int x,int y) &#123; makeroot(x),access(y),splay(y);&#125;void link(int x,int y) &#123; makeroot(x); if(findroot(y)!=x) fa[x]=y;&#125;void cut(int x,int y) &#123; makeroot(x); if(findroot(y)==x&amp;&amp;fa[x]==y&amp;&amp;!rs(x)) fa[x]=ls(y)=0,pushup(y);&#125;int main() &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;++i) &#123; scanf("%d",&amp;k[i]); link(i,i+k[i]&lt;=n?i+k[i]:n+1); &#125; for(scanf("%d",&amp;m);m--;) &#123; int opt,x; scanf("%d%d",&amp;opt,&amp;x),++x; if(opt==1) &#123; split(x,n+1); printf("%d\n",sz[n+1]-1); &#125; else &#123; int v; scanf("%d",&amp;v); cut(x,x+k[x]&lt;=n?x+k[x]:n+1); link(x,x+v&lt;=n?x+v:n+1); k[x]=v; &#125; &#125; return 0;&#125; 解法 2123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cmath&gt;const int N=2e5+5,M=500;int n,m,len,num,bl[N],l[M],r[M],k[N],cnt[N],pos[N];void build() &#123; len=sqrt(n),num=(n-1)/len+1; for(int i=1;i&lt;=n;++i) bl[i]=(i-1)/len+1; for(int i=1;i&lt;=num;++i) l[i]=(i-1)*len+1,r[i]=i*len; r[num]=n;&#125;void modify(int x,int y) &#123; for(int i=y;i&gt;=x;--i) &#123; int j=i+k[i]; if(j&gt;r[bl[i]]) &#123; cnt[i]=1,pos[i]=j; &#125; else &#123; cnt[i]=cnt[j]+1,pos[i]=pos[j]; &#125; &#125;&#125;int query(int x) &#123; int ans=0; while(x&lt;=n) ans+=cnt[x],x=pos[x]; return ans;&#125;int main() &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;++i) scanf("%d",&amp;k[i]); build(); modify(1,n); for(scanf("%d",&amp;m);m--;) &#123; int opt,x; scanf("%d%d",&amp;opt,&amp;x),++x; if(opt==1) &#123; printf("%d\n",query(x)); &#125; else &#123; int v; scanf("%d",&amp;v); k[x]=v,modify(l[bl[x]],r[bl[x]]); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>LCT</tag>
        <tag>分块</tag>
        <tag>根号分治</tag>
        <tag>BZOJ</tag>
        <tag>HNOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu 1501」Tree II]]></title>
    <url>%2Farticles%2Fproblem-Luogu-1501-Tree-II%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Luogu 1501 一棵 $n$ 个点的树，每个点的初始权值为 $1$。对于这棵树有 $q$ 个操作，每个操作为以下四种操作之一： + u v c：将 $u$ 到 $v$ 的路径上的点的权值都加上 $c​$。 - u1 v1 u2 v2：将树中原有的边 $(u_1,v_1)$ 删除，加入一条新边 $(u_2,v_2)$，保证操作完之后仍然是一棵树。 * u v c：将 $u$ 到 $v$ 的路径上的点的权值都乘上 $c$。 / u v：询问u到v的路径上的点的权值和，求出答案对于 $51061$ 的余数。 数据范围：$1\le n,q\le 10^5$，$0\le c\le 10^4$ Solution其实 $\text{LCT}​$ 中的懒标记下传和线段树中的是一样的，并且都是按照乘法比加法优先的原则进行的。 这里主要提几个坑点： 我们发现 $\text{mod}=51061$，但是 $\text{mod}^2=2607225721&gt;2147483647$，因此我们要开 $\text{unsigned int}$ 或者 $\text{long long}$。 题目中没有保证操作都是合法的！也就是说 $\text{link}$ 或 $\text{cut}$ 时可能不合法，需要判断不合法情况。 时间复杂度：$O(q\log n)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define ls(x) ch[x][0]#define rs(x) ch[x][1]const int N=1e5+5;const unsigned int mod=51061;int n,m,fa[N],ch[N][2],sz[N],st[N];unsigned int val[N],sum[N],add[N],mul[N];bool r[N];char getc() &#123; char ch=getchar(); while(ch&lt;'*') ch=getchar(); return ch;&#125;bool get(int x) &#123; return rs(fa[x])==x;&#125;bool isroot(int x) &#123; return ls(fa[x])!=x&amp;&amp;rs(fa[x])!=x;&#125;void rev(int x) &#123; std::swap(ls(x),rs(x)),r[x]^=1;&#125;void Mul(int x,int v) &#123; (sum[x]*=v)%=mod,(val[x]*=v)%=mod,(add[x]*=v)%=mod,(mul[x]*=v)%=mod;&#125;void Add(int x,int v) &#123; (sum[x]+=1LL*v*sz[x]%mod)%=mod,(val[x]+=v)%=mod,(add[x]+=v)%=mod;&#125;void pushup(int x) &#123; sz[x]=sz[ls(x)]+sz[rs(x)]+1; sum[x]=(sum[ls(x)]+sum[rs(x)]+val[x])%mod;&#125;void pushdown(int x) &#123; if(r[x]) rev(ls(x)),rev(rs(x)),r[x]=0; if(mul[x]!=1) Mul(ls(x),mul[x]),Mul(rs(x),mul[x]),mul[x]=1; if(add[x]!=0) Add(ls(x),add[x]),Add(rs(x),add[x]),add[x]=0;&#125;void rotate(int x) &#123; int y=fa[x],z=fa[y],k=get(x); !isroot(y)&amp;&amp;(ch[z][get(y)]=x),fa[x]=z; ch[y][k]=ch[x][k^1],fa[ch[x][k^1]]=y; ch[x][k^1]=y,fa[y]=x; pushup(y),pushup(x);&#125;void splay(int x) &#123; int u=x,tp=0; st[++tp]=u; while(!isroot(u)) st[++tp]=u=fa[u]; while(tp) pushdown(st[tp--]); while(!isroot(x)) &#123; int y=fa[x]; if(!isroot(y)) rotate(get(x)==get(y)?y:x); rotate(x); &#125;&#125;void access(int x) &#123; for(int y=0;x;x=fa[y=x]) splay(x),rs(x)=y,pushup(x);&#125;void makeroot(int x) &#123; access(x),splay(x),rev(x);&#125;int findroot(int x) &#123; access(x),splay(x); pushdown(x); while(ls(x)) pushdown(x=ls(x)); return x;&#125;void split(int x,int y) &#123; makeroot(x),access(y),splay(y);&#125;void link(int x,int y) &#123; makeroot(x); if(findroot(y)!=x) fa[x]=y;&#125;void cut(int x,int y) &#123; makeroot(x); if(findroot(y)==x&amp;&amp;fa[x]==y&amp;&amp;!rs(x)) fa[x]=ls(y)=0,pushup(y);&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) sz[i]=val[i]=mul[i]=1; for(int i=1;i&lt;n;++i) &#123; int u,v; scanf("%d%d",&amp;u,&amp;v); link(u,v); &#125; while(m--) &#123; char ch=getc(); int u,v,c; if(ch=='+') &#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;c); split(u,v),Add(v,c%mod); &#125; if(ch=='-') &#123; scanf("%d%d",&amp;u,&amp;v),cut(u,v); scanf("%d%d",&amp;u,&amp;v),link(u,v); &#125; if(ch=='*') &#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;c); split(u,v),Mul(v,c%mod); &#125; if(ch=='/') &#123; scanf("%d%d",&amp;u,&amp;v); split(u,v); printf("%u\n",sum[v]); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>LCT</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「IOI 2007」矿工配餐]]></title>
    <url>%2Farticles%2Fproblem-IOI-2007-Miners%2F</url>
    <content type="text"><![CDATA[Description 题目链接：BZOJ 1806 现有两个煤矿，每个煤矿都雇用一组矿工。采煤工作很辛苦，所以矿工们需要良好饮食。每当一辆食品车到达煤矿时，矿工们便会产出一定数量的煤。 $n​$ 辆食品车分为三种类型：肉车，鱼车和面包车。矿工们喜欢变化的食谱。如果提供的食品能够不断变化，他们的产煤量将会增加。每当一个新的食品车到达煤矿时，矿工们就会比较这种新的食品和前两次（或者少于两次，如果前面运送食品的次数不足两次）的食品，并且： 如果这几次食品车都是同一类型的食品，则矿工们产出一个单位的煤。 如果这几次食品车中有两种不同类型的食品，则矿工们产出两个单位的煤。 如果这几次食品车中有三种不同类型的食品，则矿工们产出三个单位的煤。 预先已知食品车的类型及其被配送的顺序。食品车不能被拆分，每个食品车必须被全部送到一个或另一个煤矿。求出两个煤矿的产煤量的总和的最大值。 数据范围：$1\le n\le 10^5$ Solution我们定义 $\text{DP}$ 状态 $f_{i,a,b,c,d}$：考虑完第 $i$ 个食品车，第一个煤矿前 $2$ 个食品车为 $a,b$，第二个煤矿前 $2$ 个食品车为 $c,d$。我们可以枚举写一个食品车 $x​$ 到达哪个煤矿，直接转移即可。对于三个食品的贡献，我们可以写一个函数分类讨论。 注意：$\text{DP}$ 转移过程中，可能会遇到不合法的状态（比如 $a=0,b&gt;0$，我们可以通过 $f​$ 数组的值来判断状态是否合法）。 对于 $\text{DP}$ 的写法，可能递归写起来更简短。但是本题卡空间（$18\text{MB}$）！只能写递推并使用滚动数组。 时间复杂度：$O(4^4\cdot n)$ Code递推（MLE）123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int N=1e5+5;char s[N];int n,p[N],f[N][4][4][4][4];int get(int a,int b,int c) &#123; if(!a&amp;&amp;!b) return 1; if(!a) return b!=c?2:1; return a==b&amp;&amp;b==c?1:(a!=b)+(b!=c)+(c!=a);&#125;int dfs(int x,int a,int b,int c,int d) &#123; if(x&gt;n) return 0; int &amp;ans=f[x][a][b][c][d]; if(ans) return ans; return ans=std::max(dfs(x+1,b,p[x],c,d)+get(a,b,p[x]),dfs(x+1,a,b,d,p[x])+get(c,d,p[x]));&#125;int main() &#123; scanf("%d%s",&amp;n,s+1); for(int i=1;i&lt;=n;++i) p[i]=s[i]=='M'?1:s[i]=='F'?2:3; printf("%d\n",dfs(1,0,0,0,0)); return 0;&#125; 递推123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define FOR(i,a,b) for(int i=a;i&lt;=b;++i)const int N=1e5+5;char s[N];int n,f[4][4][4][4];int get(int a,int b,int c) &#123; if(!a&amp;&amp;!b) return 1; if(!a) return b!=c?2:1; return a==b&amp;&amp;b==c?1:(a!=b)+(b!=c)+(c!=a);&#125;void chkmax(int &amp;x,int y) &#123; x=x&gt;y?x:y;&#125;int main() &#123; scanf("%d%s",&amp;n,s+1); memset(f,-1,sizeof(f)); f[0][0][0][0]=0; FOR(_,1,n) &#123; int g[4][4][4][4],o=(s[_]=='M'?1:s[_]=='F'?2:3); memset(g,-1,sizeof(g)); FOR(i,0,3) FOR(j,0,3) FOR(k,0,3) FOR(l,0,3) &#123; if(f[i][j][k][l]&lt;0) continue; chkmax(g[j][o][k][l],f[i][j][k][l]+get(i,j,o)); chkmax(g[i][j][l][o],f[i][j][k][l]+get(k,l,o)); &#125; memcpy(f,g,sizeof(g)); &#125; int ans=0; FOR(i,0,3) FOR(j,0,3) FOR(k,0,3) FOR(l,0,3) chkmax(ans,f[i][j][k][l]); printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>BZOJ</tag>
        <tag>IOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 1110E」Magic Stones]]></title>
    <url>%2Farticles%2Fproblem-Codeforces-1110E-Magic-Stones%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Codeforces 1110E Grigory 有 $n​$ 个魔法石，标号为 $1​$ 到 $n​$。第 $i​$ 个石头的电荷量为 $c_i​$。有时 Grigory 会选择一些内部的石头（第 $i​$ 个石头满足 $2\le i\le n-1​$），使得它失去自己的电荷，得到相邻的石头的电荷。也就是说，它的电荷 $c_i​$ 变为 $c_i’=c_{i+1}+c_{i-1}-c_i​$。 Grigory 的朋友 Andrew 也有 $n$ 个电荷量为 $t_i$ 的石头。Grigory 想知道是否存在一系列操作，将 Grigory 的石头的电荷量和 Andrew 的石头的电荷量相同。如果存在操作，那么输出 Yes 否则输出 No。 数据范围：$2\le n\le 10^5​$，$0\le c_i,t_i\le 2\times 10^9​$ Solution我们定义差分数组 $d_i=c_{i+1}-c_i$，如果我们此时对 $c_i$ 进行操作，即 $c_i’=c_{i+1}+c_{i-1}-c_i$，那么我们将得到： $d_{i-1}’=c_i’-c_{i-1}=(c_{i+1}+c_{i-1}-c_i)-c_{i-1}=c_{i+1}-c_i=d_i$ $d_i’=c_{i+1}-c_i’=c_{i+1}-(c_{i+1}+c_{i-1}-c_i)=c_i-c_{i-1}=d_{i-1}$ 也就是说，我们对 $c_i$ 进行一次操作，在差分数组中的体现，只不过是将 $d_{i-1}$ 和 $d_i$ 的值交换了。这意味着，如果我们把差分数组看做是无序的，那么它将是永远不会变化的。 因此，我们只要把 $c$ 和 $t$ 数组的差分数组求出来，如果排序后两个数组完全相同那么意味着有解（注意：我们首先要判断 $c_1=t_1,c_n=t_n$）；否则就是无解。 时间复杂度：$O(n\log n)$ Code1234567891011121314151617#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int N=1e5+5;int n,a[N],b[N];int main() &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;++i) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=n;++i) scanf("%d",&amp;b[i]); if(a[1]!=b[1]||a[n]!=b[n]) return puts("No"),0; for(int i=n;i&gt;=1;--i) a[i]-=a[i-1]; for(int i=n;i&gt;=1;--i) b[i]-=b[i-1]; std::sort(a+1,a+n+1),std::sort(b+1,b+n+1); for(int i=1;i&lt;=n;++i) if(a[i]!=b[i]) return puts("No"),0; return puts("Yes"),0;&#125;]]></content>
      <tags>
        <tag>结论</tag>
        <tag>差分</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 1110C」Meaningless Operations]]></title>
    <url>%2Farticles%2Fproblem-Codeforces-1110C-Meaningless-Operations%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Codeforces 1110C 定义函数 $f(a)$ 的值为： f(a)=\max_{0]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>位运算</tag>
        <tag>Codeforces</tag>
        <tag>打表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法笔记」Link-Cut Tree]]></title>
    <url>%2Farticles%2Falgorithm-Link-Cut-Tree%2F</url>
    <content type="text"><![CDATA[动态树问题，即要求我们维护一个由若干棵子结点无序的有根树组成的森林。要求这个数据结构支持对树的分割、合并，对某个点到它的根的路径的某些操作。 前置知识$\text{Splay}​$：博客文章详见「算法笔记」Splay 维护二叉查找树 链剖分重链剖分我们所谓的树剖，就是重链剖分的常用称呼。对于每个点，我们选择其最大的子树，将这条连边划分为重边，连向其余子树的边化为分轻边。 长链剖分对每个点选择其深度最大的儿子作为重儿子，连边即为重边，其余作为轻儿子，连边即为轻边。由此得到了若干条互不相交的长链。 实链剖分同样将某一个儿子的连边为实边，其余儿子的连边为虚边。只不过虚实是可以动态变化的，因此我们需要用更高级、更灵活的数据结构 $\text{Splay}$ 来维护每一条实链。 基于性质更加优秀的实链剖分，$\text{LCT}$（$\text{Link-Cut Tree}$）应运而生。 性质 每一个 $\text{Splay}$ 维护的是一条从上到下在原树中深度严格递增的链，且中序遍历 $\text{Splay}$ 得到的点的深度严格递增。 每个节点包含且仅包含在一个 $\text{Splay}$ 中。 边分为且仅分为实边和虚边，所有实边包含在 $\text{Splay}$ 中，而虚边总是由一棵 $\text{Splay}$ 指向另一个节点（指向该 $\text{Splay}​$ 中序遍历最靠前的节点在原树中的父亲）。 为了保持树的形态，我们要让它到其他儿子的边变为虚边，由对应儿子所属的 $\text{Splay}​$ 的根节点的父亲指向该点，而该点不能直接访问该儿子（认父不认子）。 操作我们首先认识一下 $\text{LCT}$ 支持的操作类型： 查询、修改链上的信息。 对某一个树进行换根操作。 动态连边、删边。 动态维护连通性。 其他神奇的操作。 access(x)功能：将根节点到 $x$ 上的边都变为实边。 假如我们有一棵树，实边和虚边一开始是这样划分的（图片引用于 YangZhe 的论文 和 FlashHu 的博客）： 那么构成的 $\text{LCT}$ 可能长成这样（绿框中为一个 $\text{Splay}​$，形态不唯一，但是只要满足中序遍历按照深度递增，对结果就没有影响）： 现在我们要执行 $\text{access}(N)$ 操作，把 $A\sim N$ 路径上的边都变成实边，形成一个 $\text{Splay}$。由于性质 $2$，那么肯定有些实边要变为虚边。我们可以得到这样的重新划分： 那么如何实现 $\text{access}(N)$ 的操作呢？ 我们从 $N$ 这个点一步步往上进行操作。首先把 $N$ 进行 $\text{splay}$ 操作，使得它变成这个 $\text{Splay}​$ 中的根节点。 为了满足性质 $2​$，那么 $(N,O)​$ 这条边需要从实边变为虚边。由于 $O​$ 的深度比 $N​$ 大，在 $\text{Splay}​$ 中的表现形式就是 $O​$ 在 $N​$ 的右子树中，那么直接把 $N​$ 的右儿子变为空（认父不认子）。得到如图形式： 接着我们把 $N$ 所属的 $\text{Splay}$ 的虚边指向的 $I$（在原树上 $I$ 是 $L$ 的父亲）也转到所属的 $\text{Splay}$ 的根节点，那么边 $(I,K)$ 边需要变为虚边，同时去掉右儿子。这时候把 $(I,N)​$ 变成实边即可。 接下来同理进行一系列操作： 由于 $I$ 所属 $\text{Splay}$ 指向 $H$，故 $\text{splay(H)}$，将 $H$ 的右儿子变为 $I​$。 由于 $H$ 所属 $\text{Splay}$ 指向 $A$，故 $\text{splay(A)}$，将 $A$ 的右儿子变为 $H$。 至此，$A\sim N$ 的路径上的边都变成实边了，而总结整个过程，我们发现只有如下 $4$ 步： 将节点转到所属 $\text{Splay}$ 的根。 将其右儿子删除，变为删一个 $\text{Splay}​$ 的根节点。 更新节点信息。 将当前点变为虚边所指的父亲，转到步骤 $1$。 代码 123void access(int x) &#123; for(int y=0;x;x=fa[y=x]) splay(x),ch[x][1]=y,pushup(x);&#125; makeroot(x)功能：将 $x​$ 成为原树的根节点。 我们首先进行 $\text{access}(x)$ 操作，这样一来我们得到了一条从根节点到 $x$ 的链，$x$ 一定是这个 $\text{Splay}$ 中深度最大的点。根据性质 $1$，在这个 $\text{Splay}$ 中 $x$ 一定没有右子树（没有比 $x$ 深度更大的点）。我们直接翻转整个 $\text{Splay}$，使得所有点的深度都倒过来，$x$ 就没有了左子树，成为了深度最小的点，也就成为了根节点。注意要给这个 $\text{Splay}​$ 打上翻转懒标记。 代码 123void makeroot(int x) &#123; access(x),splay(x),rev(x);&#125; findroot(x)功能：找到 $x$ 所在的树的根，主要用来判断两点之间的连通性。 我们利用这样一个性质：一棵树的根节点一定是深度最小的点。那么我们先用 $\text{access}(x)$ 把 $x$ 先和根连成一条链，然后用 $\text{splay}(x)$ 将 $x$ 旋转到 $\text{Splay}$ 的根节点。之后根节点一定是 $x​$ 不断往左走得到的（越往左深度越小）。注意在往左走的过程中一定要下传标记！ 代码 123456int findroot(int x) &#123; access(x),splay(x); pushdown(x); while(ch[x][0]) pushdown(x=ch[x][0]); return x;&#125; split(x,y)功能：得到 $x$ 到 $y$ 的一条路径，其中 $y$ 是为路径所在 $\text{Splay}$ 的根节点。 我们可以通过上面的函数直接写出 $\text{split}$ 函数。先把 $x$ 作为根节点，然后得到根节点到 $y$ 的链，将 $y$ 旋转到 $\text{Splay}$ 的根即可。 代码 123void split(int x,int y) &#123; makeroot(x),access(y),splay(y);&#125; link(x,y)功能：连一条虚边 $(x,y)$（如果已经连通则不操作）。 我们将 $x$ 变成原树的根，然后将 $x$ 的父节点直接设为 $y$ 即可。因为在 $\text{findroot}(y)$ 中已经执行了 $\text{access}(y)$ 和 $\text{splay}(y)$，则 $y$ 成为了所在 $\text{Splay}​$ 的根节点。 连通性的检查：$x$ 成为根节点后，如果 $\text{findroot}(y)=x$ 则说明 $x,y$ 连通。 代码 1234void link(int x,int y) &#123; makeroot(x); if(findroot(y)!=x) fa[x]=y;&#125; cut(x,y)功能：切断边 $(x,y)$（如果没有边则不进行操作） 首先我们把 $x$ 变成根节点，如果存在边 $(x,y)$，那么 $x$ 的深度一定比 $y$ 浅，则 $x$ 是 $y$ 的左儿子，$y$ 是 $x​$ 的父节点。 但是如果不保证操作合法呢？我们需要很多条件来判断 $(x,y)$ 这条边是不存在的。不存在边 $(x,y)​$ 的条件（满足一者即可）： 如果 $x,y$ 不在同一棵树内，那么不存在边。 如果 $x$ 的父亲不是 $y$，则意味着 $x,y$ 虽然在同一个 $\text{Splay}$ 中却没有连边。 如果 $x$ 的右子树非空，那么意味着以 $y$ 为根的中序遍历中 $x$ 和 $y​$ 不相邻，则没有边相连。 代码 1234void cut(int x,int y) &#123; makeroot(x); if(findroot(y)==x&amp;&amp;fa[x]==y&amp;&amp;!ch[x][1]) fa[x]=ch[y][0]=0,pushup(y);&#125; 区别rotate(x)功能：将 $x​$ 向上旋转。 和普通 $\text{Splay}​$ 不同的是，我们在修改 $x​$ 的祖父的儿子时，必须判断 $x​$ 的父亲是否为所在 $\text{Splay}​$ 的根。因为如果不判断的话，$0​$ 的儿子就会被定义为 $x​$，而 $x​$ 则永远不可能成为根节点，在 $\text{splay}​$ 函数中将会无限循环。 代码 1234567void rotate(int x) &#123; int y=fa[x],z=fa[y],k=get(x); !isroot(y)&amp;&amp;(ch[z][get(y)]=x),fa[x]=z; ch[y][k]=ch[x][k^1],fa[ch[x][k^1]]=y; ch[x][k^1]=y,fa[y]=x; pushup(y),pushup(x);&#125; splay(x)功能：将 $x​$ 旋转到 $\text{Splay}​$ 的根节点。 由于 $\text{LCT}$ 中对 $\text{Splay}$ 有翻转操作，那么我们在 $\text{splay}(x)$ 之前，必须将 $x$ 的所有祖先的标记下放，我们用一个栈来保存所有的祖先并依次下放标记。 代码 1234567891011void splay(int x) &#123; int u=x,tp=0; st[++tp]=u; while(!isroot(u)) st[++tp]=u=fa[u]; while(tp) pushdown(st[tp--]); while(!isroot(x)) &#123; int y=fa[x]; if(!isroot(y)) rotate(get(x)==get(y)?y:x); rotate(x); &#125;&#125; 代码以「Luogu 3690」Link Cut Tree 为例。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define ls(x) ch[x][0]#define rs(x) ch[x][1]const int N=3e5+5;int n,m,fa[N],ch[N][2],val[N],sum[N],st[N];bool r[N];bool get(int x) &#123; return rs(fa[x])==x;&#125;bool isroot(int x) &#123; return ls(fa[x])!=x&amp;&amp;rs(fa[x])!=x;&#125;void rev(int x) &#123; r[x]^=1,std::swap(ls(x),rs(x));&#125;void pushup(int x) &#123; sum[x]=sum[ls(x)]^sum[rs(x)]^val[x];&#125;void pushdown(int x) &#123; if(r[x]) rev(ls(x)),rev(rs(x)),r[x]=0;&#125;void rotate(int x) &#123; int y=fa[x],z=fa[y],k=get(x); !isroot(y)&amp;&amp;(ch[z][get(y)]=x),fa[x]=z; ch[y][k]=ch[x][k^1],fa[ch[x][k^1]]=y; ch[x][k^1]=y,fa[y]=x; pushup(y),pushup(x);&#125;void splay(int x) &#123; int u=x,tp=0; st[++tp]=u; while(!isroot(u)) st[++tp]=u=fa[u]; while(tp) pushdown(st[tp--]); while(!isroot(x)) &#123; int y=fa[x]; if(!isroot(y)) rotate(get(x)==get(y)?y:x); rotate(x); &#125;&#125;void access(int x) &#123; for(int y=0;x;x=fa[y=x]) splay(x),rs(x)=y,pushup(x);&#125;void makeroot(int x) &#123; access(x),splay(x),rev(x);&#125;int findroot(int x) &#123; access(x),splay(x); pushdown(x); while(ls(x)) pushdown(x=ls(x)); return x;&#125;void split(int x,int y) &#123; makeroot(x),access(y),splay(y);&#125;void link(int x,int y) &#123; makeroot(x); if(findroot(y)!=x) fa[x]=y;&#125;void cut(int x,int y) &#123; makeroot(x); if(findroot(y)==x&amp;&amp;fa[x]==y&amp;&amp;!rs(x)) fa[x]=ls(y)=0,pushup(y);&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) scanf("%d",&amp;val[i]); while(m--) &#123; int opt,x,y; scanf("%d%d%d",&amp;opt,&amp;x,&amp;y); if(opt==0) split(x,y),printf("%d\n",sum[y]); if(opt==1) link(x,y); if(opt==2) cut(x,y); if(opt==3) splay(x),val[x]=y; &#125; return 0;&#125; 习题 本文题单摘录自 FlashHu 的博客 维护链信息 &#9745; 「Luogu 3690」Link Cut Tree（题解） &#9745; 「HNOI 2010」弹飞绵羊（题解） &#9745; 「Luogu 1501」Tree II（题解） &#9745; 「SDOI 2011」染色 &#9744; 「SHOI 2014」三叉神经树 维护连通性 &#9745; 「SDOI 2008」洞穴勘测 &#9745; 「Luogu 3950」部落冲突 &#9744; 「AHOI 2005」航线规划 &#9744; 「BZOJ 4998」星球联盟 &#9744; 「BZOJ 2959」长跑 维护边权 &#9745; 「WC 2006」水管局长（加强版） &#9745; 「UOJ 274」温暖会指引我们前行 &#9745; 「BZOJ 1977」次小生成树 &#9745; 「Luogu 4234」最小差值生成树 &#9745; 「NOI 2014」魔法森林 维护子树信息 &#9745; 「COGS 2701」动态树 &#9745; 「BJOI 2014」大融合 &#9744; 「Luogu U19464」山村游历 &#9744; 「Luogu 4299」首都 &#9744; 「SPOJ 2939」QTREE5 - Query on a tree V &#9744; 「LOJ 558」我们的 CPU 遭到攻击 维护树上染色连通块 &#9744; 「ZJOI 2012」网络 &#9744; 「SDOI 2017」树点涂色 &#9744; 「SPOJ 16549」QTREE6 - Query on a tree VI &#9744; 「SPOJ 16580」QTREE7 - Query on a tree VII &#9744; 「BZOJ 3914」Jabby’s shadows 特殊题型 &#9744; 「Luogu 3613」睡觉困难综合征 &#9744; 「UOJ 207」共价大爷游长沙 &#9744; 「ZJOI 2016」大森林 &#9744; 「ZJOI 2018」历史 &#9744; 「Luogu 4546」在美妙的数学王国中畅游]]></content>
      <tags>
        <tag>算法笔记</tag>
        <tag>数据结构</tag>
        <tag>LCT</tag>
        <tag>Splay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 1110D」Jongmah]]></title>
    <url>%2Farticles%2Fproblem-Codeforces-1110D-Jongmah%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Codeforces 1110D 你在玩一个叫做 Jongmah 的游戏，你手上有 $n$ 个麻将，每个麻将上有一个在 $1$ 到 $m$ 范围内的整数 $a_i$。 为了赢得游戏，你需要将这些麻将排列成一些三元组，每个三元组中的元素是相同的或者连续的。如 $7,7,7$ 和 $12,13,14$ 都是合法的。你只能使用手中的麻将，并且每个麻将只能使用一次。 请求出你最多可以形成多少个三元组。 数据范围：$1\le n,m\le 10^6$，$1\le a_i\le m$ Solution首先我们必须注意到：相同的 $3​$ 个 $[x,x+1,x+2]​$ 三元组，可以变成 $[x,x,x]​$，$[x+1,x+1,x+1]​$，$[x+2,x+2,x+2]​$ 这样 $3​$ 个三元组，而并没有改变三元组的数量。这样一来，我们就可以假设，对于每个 $x​$，形如 $[x,x+1,x+2]​$ 的三元组最多只有 $2​$ 个！ 我们可以直接定义 $\text{DP}$ 状态：$f_{x,i,j}$ 表示考虑到前 $x$ 种数字，有 $i$ 个 $[x-1,x,x+1]$，$j$ 个 $[x,x+1,x+2]$，我们枚举有 $k$ 个 $[x+1,x+2,x+3]$，状态转移方程如下（我们记 $cnt_i$ 表示数字 $i$ 的数量）： f_{x,j,k}=\max\left\{f_{x-1,i,j}+\left\lfloor\frac{cnt_x-i-j-k}{3}\right\rfloor+k\right\}\quad(0\le k\le 2,i+j+k\le cnt_x)其中 $i,j,k$ 分别表示：有 $i$ 个 $[x-2,x-1,x]$，有 $j$ 个 $[x-1,x,x+1]$，有 $k$ 个 $[x,x+1,x+2]$，那么肯定有 $i+j+k$ 个数字 $x​$，得到约束条件和贡献后直接转移。 时间复杂度：$O(3^3\cdot m)$ Code12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;const int N=1e6+5,M=3;int n,m,a[N],f[M][M],g[M][M];int main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int x,i=1;i&lt;=n;++i) scanf("%d",&amp;x),++a[x]; memset(f,-0x3f,sizeof(f)); f[0][0]=0; for(int p=1;p&lt;=m;++p) &#123; memcpy(g,f,sizeof(f)); memset(f,-0x3f,sizeof(f)); for(int i=0;i&lt;3;++i) for(int j=0;j&lt;3;++j) for(int k=0;k&lt;3;++k) &#123; if(i+j+k&lt;=a[p]) f[j][k]=std::max(f[j][k],g[i][j]+(a[p]-i-j-k)/3+k); &#125; &#125; printf("%d\n",f[0][0]); return 0;&#125;]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>贪心</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 1110F」Nearest Leaf]]></title>
    <url>%2Farticles%2Fproblem-Codeforces-1110F-Nearest-Leaf%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Codeforces 1110F 给你一棵带权有根树，根节点为 $1​$，且保证每个点的父亲 $p_i&lt;i​$，其中 $(p_i,i)​$ 的边权为 $w_i​$。这棵树有个性质：如果我们 $\text{DFS}​$ 这棵树，对于每个点都递增枚举儿子节点，每访问到一个节点就记录其编号，那么得到的序列刚好为 $1​$ 到 $n​$。 现在有 $q​$ 次询问，每次给出 $v_i,l_i,r_i​$，求从 $v_i​$ 出发到 $[l_i,r_i]​$ 中的其中一个叶子节点的最短距离（保证 $[l_i,r_i]​$ 中至少有一个叶子节点）。 数据范围：$3\le n\le 5\times 10^5​$，$1\le q\le 5\times 10^5​$，$1\le p_i&lt;i​$，$1\le w_i\le 10^9​$ Solution考虑都没有修改操作，我们可以把询问离线下来。按照询问的节点分类。 我们首先观察一个性质：由于 $\text{DFS}$ 序就是 $1$ 到 $n$，那么意味着每棵子树内的编号都是连续的，记子树 $i$ 内点的最大编号为 $k_i​$。 我们再考虑一个问题：如果从 $u​$ 到达 $v​$（我们记这条边为 $(u,v,w)​$），其中 $v​$ 的深度大于 $u​$，那么到达每个叶子的路径长度会发生什么变化？ 对于在 $v​$ 子树内的叶子，到他们的距离减少 $w​$。 其余叶子节点，到他们的距离增加 $w​$。 根据之前的性质，我们发现 $v$ 子树内的节点编号连续，可以直接用线段树修改。具体的修改方法为：我们将线段树内 $[1,n]$ 的节点的值增加 $w$，将 $[v,k_v]$ 的节点的值减少 $2w​$。 为了防止对线段树中非叶子节点的影响，我们应该要将他们的值初始化为 $\text{INF}$，使得无论如何修改都不会影响答案。 这样一来，我们可以得到一个简单的算法流程： 将 $1$ 到所有叶子节点的距离放到线段树中，非叶子节点的距离定义为 $\text{INF}$。 直接 $\text{DFS}$ 整棵树，将询问节点为当前节点的询问统计答案。 枚举当前节点 $u$ 的儿子节点 $v$，在线段树上修改 $[v,k_v]$ 的值并递归求解 $v$ 的值；递归后记得回溯消去影响！ 时间复杂度：$O((n+q)\log n)$ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#define lson p&lt;&lt;1#define rson p&lt;&lt;1|1const int N=5e5+5;const long long INF=1LL&lt;&lt;60;int n,m,tot,l[N],r[N],mx[N],lnk[N],ter[N],nxt[N],val[N];long long seg[N&lt;&lt;2],tag[N&lt;&lt;2],dis[N],ans[N];std::vector&lt;int&gt; q[N];void pushup(int p) &#123; seg[p]=std::min(seg[lson],seg[rson]);&#125;void pushdown(int p) &#123; if(!tag[p]) return; long long v=tag[p]; seg[lson]+=v,tag[lson]+=v,seg[rson]+=v,tag[rson]+=v,tag[p]=0;&#125;void modify(int x,int y,int p,int l,int r,long long v) &#123; if(x&lt;=l&amp;&amp;r&lt;=y) &#123; seg[p]+=v,tag[p]+=v; return; &#125; pushdown(p); int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) modify(x,y,lson,l,mid,v); if(mid&lt;y) modify(x,y,rson,mid+1,r,v); pushup(p);&#125;long long query(int x,int y,int p,int l,int r) &#123; if(x&lt;=l&amp;&amp;r&lt;=y) return seg[p]; pushdown(p); int mid=(l+r)&gt;&gt;1; long long ans=INF; if(x&lt;=mid) ans=std::min(ans,query(x,y,lson,l,mid)); if(mid&lt;y) ans=std::min(ans,query(x,y,rson,mid+1,r)); return ans;&#125;void add(int u,int v,int w) &#123; ter[++tot]=v,nxt[tot]=lnk[u],lnk[u]=tot,val[tot]=w;&#125;void dfs1(int u) &#123; mx[u]=u; for(int i=lnk[u];i;i=nxt[i]) &#123; int v=ter[i]; dis[v]=dis[u]+val[i]; dfs1(v); mx[u]=std::max(mx[u],mx[v]); &#125;&#125;void dfs2(int u) &#123; for(int i:q[u]) ans[i]=query(l[i],r[i],1,1,n); for(int i=lnk[u];i;i=nxt[i]) &#123; int v=ter[i],w=val[i]; modify(1,n,1,1,n,w),modify(v,mx[v],1,1,n,-w-w); dfs2(v); modify(1,n,1,1,n,-w),modify(v,mx[v],1,1,n,w+w); &#125;&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=2;i&lt;=n;++i) &#123; int p,w; scanf("%d%d",&amp;p,&amp;w),add(p,i,w); &#125; dfs1(1); for(int i=1;i&lt;=n;++i) &#123; modify(i,i,1,1,n,i==mx[i]?dis[i]:INF); &#125; for(int i=1;i&lt;=m;++i) &#123; int v; scanf("%d%d%d",&amp;v,&amp;l[i],&amp;r[i]),q[v].push_back(i); &#125; dfs2(1); for(int i=1;i&lt;=m;++i) printf("%lld\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>Codeforces</tag>
        <tag>离线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法笔记」Splay 维护序列]]></title>
    <url>%2Farticles%2Falgorithm-Splay-2%2F</url>
    <content type="text"><![CDATA[$\text{Splay}$ 是一种二叉查找树，它通过不断将某个节点旋转到根节点，使得整棵树仍然满足二叉查找树的性质，并且保持平衡而不至于退化为链。 例题我们以「Luogu 3391」文艺平衡树 作为例题：你需要维护一个有序数列，支持翻转区间操作。 分析总体思路我们还是用 $\text{Splay}$ 来维护这个序列，但是不用权值维护，而是用节点在序列中的位置为关键字维护，显然一个子树对应一个区间。 每次提取区间 $[l,r]$ 然后将左右子树全部交换。这正是利用了 $\text{Splay}$ 在旋转过程中不会改变中序遍历。那么原来的左根右在交换后变为右根左，实现了区间翻转。 提取区间根据 $\text{Splay}$ 的特性（具体介绍详见「算法笔记」Splay 维护二叉查找树），对于区间 $[l,r]$，我们可以把 $l-1$ 旋转到根，$r+1$ 旋转到根的儿子（显然是右儿子）。那么根的右儿子的左子树就是区间 $[l,r]$。 对于这里的 $l-1$ 和 $r+1$，指的是序列中第 $l-1$ 和第 $r+1$ 个元素对应的节点，而不是下标为 $l-1$ 和 $r+1$ 的节点。因此我们要调用 $\text{Splay}​$ 基本操作中的 kth(l-1) 和 kth(r+1) 找到对应的节点编号。 交换子树我们这里要使用一个和线段树很相似的懒标记，我们对于每个节点记录一个 $\text{rev}​$ 标记，标记这个区间是否被翻转。每次 kth 操作时将标记下传、交换左右子树、清空自身标记。 时间复杂度：$O(n\log n)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int N=1e5+5;const int INF=1&lt;&lt;30;int n,m,rt,idx,ch[N][2],fa[N],sz[N],cnt[N],val[N],rev[N];void pushup(int x) &#123; sz[x]=sz[ch[x][0]]+sz[ch[x][1]]+cnt[x];&#125;void pushdown(int x) &#123; if(rev[x]) &#123; std::swap(ch[x][0],ch[x][1]); rev[ch[x][0]]^=1; rev[ch[x][1]]^=1; rev[x]=0; &#125;&#125;bool get(int x) &#123; return ch[fa[x]][1]==x;&#125;void rotate(int x) &#123; int y=fa[x],z=fa[y],k=get(x); ch[z][get(y)]=x,fa[x]=z; ch[y][k]=ch[x][k^1],fa[ch[x][k^1]]=y; ch[x][k^1]=y,fa[y]=x; pushup(y),pushup(x);&#125;void splay(int x,int g) &#123; while(fa[x]!=g) &#123; int y=fa[x]; if(fa[y]!=g) rotate(get(x)==get(y)?y:x); rotate(x); &#125; if(!g) rt=x;&#125;int kth(int x) &#123; ++x; int u=rt; while(1) &#123; pushdown(u); if(x&gt;sz[ch[u][0]]+cnt[u]) x-=sz[ch[u][0]]+cnt[u],u=ch[u][1]; else if(x&lt;=sz[ch[u][0]]) u=ch[u][0]; else return u; &#125;&#125;void ins(int x) &#123; int u=rt,f=0; while(x!=val[u]&amp;&amp;u) f=u,u=ch[u][x&gt;val[u]]; if(u) ++cnt[u]; else &#123; u=++idx; if(f) ch[f][x&gt;val[f]]=u; ch[u][0]=ch[u][1]=0,fa[u]=f,val[u]=x,sz[u]=cnt[u]=1; &#125; splay(u,0);&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); ins(-INF),ins(INF); for(int i=1;i&lt;=n;++i) ins(i); while(m--) &#123; int l,r; scanf("%d%d",&amp;l,&amp;r); splay(kth(l-1),0),splay(kth(r+1),rt); rev[ch[ch[rt][1]][0]]^=1; &#125; for(int i=1;i&lt;=n;++i) &#123; printf("%d%c",val[kth(i)]," \n"[i==n]); &#125; return 0;&#125; 习题详见「算法笔记」Splay 维护二叉查找树。]]></content>
      <tags>
        <tag>算法笔记</tag>
        <tag>数据结构</tag>
        <tag>Splay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 594D」REQ]]></title>
    <url>%2Farticles%2Fproblem-Codeforces-594D-REQ%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Codeforces 594D 今天的数学课上，老师告诉 Vovochka 正整数的欧拉函数 $\varphi(n)​$ 是计算小于等于 $n​$ 且与 $n​$ 互质的正整数的函数，$1​$ 和任意正整数互质所以 $\varphi(1)=1​$。 现在老师给了 Vovochka 一个数列 $a_1,a_2,\dots,a_n​$，要求回答 $q​$ 个询问 $l_i,r_i​$，计算 $\varphi\left(\prod_{i=l}^r a_i\right)​$ 的值，答案对 $10^9 + 7​$ 取模。这个问题对二年级学生来说太难了，所以你决定帮助 Vovochka。 数据范围：$1\le n,q\le 2\times 10^5​$，$1\le a_i\le 10^6​$ Solution由于只有询问操作，因此我们首先想到离线后用莫队解决。但是莫队的复杂度为 $O(q\sqrt n\log a_i)$（其中 $\log a_i$ 指每个数的本质不同的质因子个数），显然无法通过本题（我卡了半个小时常数还是 $\text{TLE}$ 出题人毒瘤）。 还是考虑离线，我们将询问按照右端点排序，维护一个右指针，将每个 $a_i​$ 逐个加入。用树状数组维护每个位置对答案的贡献。 我们考虑 $a_i​$ 的其中一个质因子 $p​$（其他的质因子同理）。由于我们把询问按照右端点排序了，而每个质因子只能对答案有一次贡献，那么我们把 $p​$ 的贡献放到区间 $[1,i]​$ 的最右边，即进行操作 $add(i,p-1)​$ 和 $add(i,p^{-1})​$。如果 $p​$ 已经出现过了，那么我们需要防止区间左端点左侧产生贡献，维护一个 $lst[i]​$ 表示 $i​$ 这个质因子上次出现的位置，将 $lst[p]​$ 位置的贡献消去即可。 对于如何快速分解每个数的质因子，我们可以根据线性筛的本质：每个数只会被其最小质因子筛去，在筛的过程中直接记录每个数的最小质因子即可！ 时间复杂度：$O((n+q)\log n\log a_i)$ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int N=2e5+5,M=1e6+5;const int mod=1e9+7;int n,m,tot,a[N],b[N],p[M/10],f[M],pre[N],lst[M],ans[N];bool flg[M];struct Data &#123; int l,r,id; bool operator &lt; (const Data &amp;rhs) const &#123; return r&lt;rhs.r; &#125;&#125; q[N];void sieve(int n) &#123; for(int i=2;i&lt;=n;++i) &#123; if(!flg[i]) p[++tot]=i,f[i]=i; for(int j=1;j&lt;=tot&amp;&amp;i*p[j]&lt;=n;++j) &#123; flg[i*p[j]]=1,f[i*p[j]]=p[j]; if(i%p[j]==0) break; &#125; &#125;&#125;int pow(int x,int p) &#123; int ret=1; for(;p;p&gt;&gt;=1,x=1LL*x*x%mod) if(p&amp;1) ret=1LL*ret*x%mod; return ret;&#125;int inv(int x) &#123; return pow(x,mod-2);&#125;void add(int x,int val) &#123; for(;x&lt;=n;x+=x&amp;-x) b[x]=1LL*b[x]*val%mod;&#125;int query(int x) &#123; int ret=1; for(;x;x^=x&amp;-x) ret=1LL*ret*b[x]%mod; return ret;&#125;void update(int i) &#123; for(int x=a[i],p=f[x];x&gt;1;p=f[x]) &#123; add(i,p-1),add(i,inv(p)); if(lst[p]) add(lst[p],inv(p-1)),add(lst[p],p); lst[p]=i; while(x%p==0) x/=p; &#125;&#125;int main() &#123; sieve(M-5); scanf("%d",&amp;n); pre[0]=1; for(int i=1;i&lt;=n;++i) scanf("%d",&amp;a[i]),pre[i]=1LL*pre[i-1]*a[i]%mod; scanf("%d",&amp;m); for(int i=1;i&lt;=m;++i) scanf("%d%d",&amp;q[i].l,&amp;q[i].r),q[i].id=i; std::sort(q+1,q+m+1); for(int i=0;i&lt;=n;++i) b[i]=1; for(int i=1,j=0;i&lt;=m;++i) &#123; int x=q[i].l,y=q[i].r; while(j&lt;y) update(++j); ans[q[i].id]=1LL*pre[y]*inv(pre[x-1])%mod*query(y)%mod*inv(query(x-1))%mod; &#125; for(int i=1;i&lt;=m;++i) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>欧拉函数</tag>
        <tag>Codeforces</tag>
        <tag>离线</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 900D」Unusual Sequences]]></title>
    <url>%2Farticles%2Fproblem-Codeforces-900D-Unusual-Sequences%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Codeforces 900D 求满足下面两个条件的数列 $a_1,a_2,\dots,a_n(1\le a_i)​$ 的个数（答案对 $10^9+7​$ 取模）： $\gcd(a_1,a_2,\dots,a_n)=x$ $\sum_{i=1}^n a_i=y​$ 数据范围：$1\le x.y\le 10^9​$ Solution如果在 $x\nmid y​$ 的情况下，显然无解。 我们令 $m=\frac{y}{x}​$，那么问题转化为：求满足 $\gcd(a_1,a_2,\dots,a_n)=1​$ 且 $\sum_{i=1}^n a_i=m​$ 的数列个数。 我们先不考虑 $\gcd=1$ 的限制，设 $g(x)$ 表示 $\sum_{i=1}^n a_i=x$ 的数列个数。 对于 $g(x)​$ 的值，我们可以使用隔板法求解： g(x)=\sum_{i=1}^x \binom{x-1}{i-1}=2^{x-1}我们发现，$g(x)$ 的值又可以通过 $f(x)​$ 求得： g(x)=\sum_{d\mid x} f(d)接下来介绍两种做法： 递推我们可以考虑容斥原理：所有序列数量减去不合法的序列数量。我们枚举不合法的序列的 $\gcd$ 记为 $d$，显然 $d$ 必须满足 $d\mid x,d&gt;1$，这样的序列数量为 $f\left(\frac{x}{d}\right)$（当然也可以通过 $g$ 和 $f$ 的关系得到）。 \begin{aligned} f(x)&=g(x)-\sum_{d\mid x,d>1} f\left(\frac{x}{d}\right) \\ &=2^{x-1}-\sum_{d\mid x,d>1} f\left(\frac{x}{d}\right) \end{aligned}由于一个数的因子的因子也一定是这个数的因子，所以我们发现需要的 $x​$ 为 $d(m)​$ 个，即不超过 $O(\sqrt m)​$ 个，可以直接递归求解。 时间复杂度：$O(d(m)\sqrt m\log m)​$ 反演我们发现： g(x)=\sum_{d\mid x} f(d)这个式子的本质是 $g=f\ast 1$，通过莫比乌斯反演可以得到： f(x)=\sum_{d\mid x} \mu\left(\frac{x}{d}\right)g(d)这样一来我们就可以直接暴力求解了。 时间复杂度：$O\left(\frac{m}{\log m}\right)​$ Code递推1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;map&gt;const int mod=1e9+7;std::map&lt;int,int&gt; mp;int pow(int x,int p) &#123; int ret=1; for(;p;p&gt;&gt;=1,x=1LL*x*x%mod) if(p&amp;1) ret=1LL*ret*x%mod; return ret;&#125;void upd(int &amp;x,int y) &#123; (x+=y)&gt;=mod&amp;&amp;(x-=mod);&#125;int solve(int n) &#123; if(n==1) return 1; if(mp.count(n)) return mp[n]; int ans=0; for(int i=2;i*i&lt;=n;++i) &#123; if(n%i==0) &#123; upd(ans,solve(i)); if(i*i!=n) upd(ans,solve(n/i)); &#125; &#125; upd(ans,solve(1)); ans=(pow(2,n-1)-ans+mod)%mod; return mp[n]=ans;&#125;int main() &#123; int x,y; scanf("%d%d",&amp;x,&amp;y); if(y%x) return puts("0"),0; printf("%d\n",solve(y/x)); return 0;&#125; 反演1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;const int N=1e5+5;const int mod=1e9+7;int x,y,tot,p[N];bool flg[N];void sieve(int n) &#123; for(int i=2;i&lt;=n;++i) &#123; if(!flg[i]) p[++tot]=i; for(int j=1;j&lt;=tot&amp;&amp;i*p[j]&lt;=n;++j) &#123; flg[i*p[j]]=1; if(i%p[j]==0) break; &#125; &#125;&#125;int mu(int n) &#123; int cnt=0; for(int i=1;i&lt;=tot&amp;&amp;1LL*p[i]*p[i]&lt;=n;++i) &#123; if(n%p[i]) continue; int now=0; while(n%p[i]==0) n/=p[i],++now; if(now&gt;1) return 0; ++cnt; &#125; if(n&gt;1) ++cnt; return cnt%2==0?1:mod-1;&#125;int pow(int x,int p) &#123; int ret=1; for(;p;p&gt;&gt;=1,x=1LL*x*x%mod) if(p&amp;1) ret=1LL*ret*x%mod; return ret;&#125;void upd(int &amp;x,int y) &#123; (x+=y)&gt;=mod&amp;&amp;(x-=mod);&#125;int main() &#123; sieve(N-5); scanf("%d%d",&amp;x,&amp;y); if(y%x) return puts("0"),0; int n=y/x,ans=0; for(int i=1;1LL*i*i&lt;=n;++i) &#123; if(n%i==0) &#123; upd(ans,1LL*mu(n/i)*pow(2,i-1)%mod); if(i*i!=n) upd(ans,1LL*mu(i)*pow(2,n/i-1)%mod); &#125; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>莫比乌斯反演</tag>
        <tag>动态规划</tag>
        <tag>容斥</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 1102F」Elongated Matrix]]></title>
    <url>%2Farticles%2Fproblem-Codeforces-1102F-Elongated-Matrix%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Codeforces 1102F 给你一个 $n​$ 行 $m​$ 列的矩阵 $a_{i,j}​$，其中每个元素都是正整数 。 你可以任意改变行的顺序，但是不能改变同一行中元素的顺序。确定行的顺序后，你可以通过以下方式遍历整个矩阵：首先访问从顶行到底部的第一列的所有元素，然后对第二列进行相同的操作，依此类推。在遍历期间，按照访问它们的顺序记下元素，得到一个序列 $s_i​$。设这个序列为 $s_1,s_2,\dots,s_{nm}​$。 如果对于任意的 $i(1\le i&lt;nm)​$，有 $\vert s_i-s_{i+1}\vert\ge k​$ 成立，我们称 $k​$ 是合法的。 你要做的是寻找一个 $a_{i,j}$ 的行的排列顺序，使得最大的合法的 $k​$ 值最大。 数据范围：$1\le n\le 16​$，$1\le m\le 10^4​$，$2\le nm​$，$1\le a_{i,j}\le 10^9​$ Solution我们发现行的排列顺序的本质是：哈密顿回路，即第 $i​$ 行接着第 $i+1​$ 行并产生贡献，第 $n​$ 行接着第 $1​$ 行并产生贡献。注意到 $n​$ 的范围很小，我们可以考虑状态压缩。 由于第一行（哈密顿回路中的起点）是不确定的，因此我们首先要枚举起点。定义状态 $f_{i,j}$ 表示已经考虑了 $i$ 集合内的行，最后一行是 $j$ 时，不考虑第一行和最后一行的贡献的最大贡献（要求 $\vert s_i-s_{i+1}\vert$ 的最小值最大）。其中第 $i$ 行和第 $j$ 的贡献是指：同一列的元素的的差的绝对值的最小值。 状态转移方程如下： f_{S\cup j,j}=\max\{\min(f_{S,i},\text{cost}(i,j))\}\quad (i\in S,j\not\in S)其中 $\text{cost}(i,j)​$ 表示第 $i​$ 行和第 $j​$ 行相邻的贡献。 统计答案时，我们枚举结束点 $i​$，根据起点 $k​$ 可以得到答案为： \text{Ans}=\max\{\min(f_{2^n-1,i},\text{cost}'(k,i))\}其中 $2^n-1$ 为全集，$\text{cost}’(i,j)$ 表示第 $i$ 行为第一行，第 $j$ 行为最后一行时，第一行和最后一行之间的贡献。 时间复杂度：$O(2^nn^3)$ Code1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;const int N=17,M=1e4+5;const int INF=1&lt;&lt;30;int n,m,a[N][M],f[1&lt;&lt;N][N],g[N][N],h[N][N];void init() &#123; for(int i=0;i&lt;n;++i) for(int j=0;j&lt;n;++j) &#123; g[i][j]=INF,h[i][j]=INF; for(int k=1;k&lt;=m;++k) g[i][j]=std::min(g[i][j],std::abs(a[i][k]-a[j][k])); for(int k=2;k&lt;=m;++k) h[i][j]=std::min(h[i][j],std::abs(a[i][k-1]-a[j][k])); &#125;&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;n;++i) for(int j=1;j&lt;=m;++j) scanf("%d",&amp;a[i][j]); init(); int ans=0; for(int k=0;k&lt;n;++k) &#123; memset(f,0,sizeof(f)); f[1&lt;&lt;k][k]=INF; for(int S=0;S&lt;(1&lt;&lt;n);++S) for(int i=0;i&lt;n;++i) if(S&amp;(1&lt;&lt;i)) &#123; for(int j=0;j&lt;n;++j) &#123; if(!(S&amp;(1&lt;&lt;j))) f[S|(1&lt;&lt;j)][j]=std::max(f[S|(1&lt;&lt;j)][j],std::min(f[S][i],g[i][j])); &#125; &#125; for(int i=0;i&lt;n;++i) &#123; ans=std::max(ans,std::min(f[(1&lt;&lt;n)-1][i],h[k][i])); &#125; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>Codeforces</tag>
        <tag>状压 DP</tag>
        <tag>哈密顿回路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 786A」Berzerk]]></title>
    <url>%2Farticles%2Fproblem-Codeforces-786A-Berzerk%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Codeforces 786A Rick 和 Morty 在玩一个版本的 Berzerk 游戏。这个游戏需要很大的空间，所以他们使用电脑玩这个游戏。 游戏中有 $n​$ 个标号从 $1\sim n​$ 的物体围成一个圆圈（顺时针标号）， 物体 $1​$ 表示黑洞，其它物体表示星球，且某一个星球上有一个怪物，Rick 和 Morty 不知道这个怪物在哪个星球上，只知道这个怪物在游戏开始时没有进入黑洞。但就目前而言，他们希望为每种可能的情况做好准备。 Rick 和 Monty 每人有一个数的集合，集合中的数在 $[1,n-1]$ 之间。Rick 的集合是 $s_1$，其中有 $k_1$ 个数，Morty 的集合是 $s_2$，其中有 $k_2$ 个数。 游戏开始后，两人轮流操作。在操作中，玩家必须从他的集合中选出一个数 $x$， 怪物将从当前位置顺时针移动 $x$ 个位置，如果怪物移动后进入了黑洞，则该玩家获胜。 你的任务是对于每一个怪物的位置以及玩家先后手顺序，判断游戏先手获胜、后手获胜、无限循环。（每个玩家都采取最优操作） 数据范围：$2\le n\le 7000$，$1\le k_1,k_2\le n-1$，$1\le s_{i,j}\le n-1$ Solution博弈论有一个经典的结论： 能转移到必败态的状态就是必胜态，只能转移到必胜态的状态就是必败态。 现在我们知道 $1$ 是必败态，那么我们通过 $\text{DFS}$ 可以判断每个点的胜负情况、是否有解。 我们考虑逆向思维，对每个玩家在 $1$ 时的先手状态向前转移，具体过程如下： 定义 $\text{DFS}(v,now)$ 表示现在是 $now$ 的位置，玩家 $v$ 先手。 枚举上一次玩家 $u$ 的操作 $x$，那么可以从 $now-x$ 的位置转移到 $now$ 的位置（注意这里的 $now-x$ 不能等于 $1$）。 如果 $now$ 的位置是必败态，那么根据结论：能转移到必败态的状态就是必胜态，可以得到 $now-x$ 的位置是必胜态。 如果 $now$ 的位置是必胜态，那么根据结论：只能转移到必胜态的状态就是必败态。我们记 $cnt_{u,i}$ 表示在 $i$ 这个位置且 $u$ 先手可以转移到的必胜态数量。当 $cnt_{u,now-x}+1=k_u$ 时，意味着从 $(u,now-x)$ 转移到的所有状态都是必胜态，那么意味着从 $(u,now-x)$ 这个状态为必败态。 继续 $\text{DFS}(u,now-x)​$ 进行转移即可。 时间复杂度：$O(n^2)​$ Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int N=7e3+5;int n,k[2],a[2][N],cnt[2][N];bool vis[2][N],win[2][N];void dfs(int v,int now) &#123; if(vis[v][now]) return; vis[v][now]=1; int u=v^1; for(int i=1;i&lt;=k[u];++i) &#123; int pre=(now-a[u][i]+n-1)%n+1; if(pre==1) continue; if(!win[v][now]) &#123; win[u][pre]=1; dfs(u,pre); &#125; else if(++cnt[u][pre]==k[u]) &#123; win[u][pre]=0; dfs(u,pre); &#125; &#125;&#125;int main() &#123; scanf("%d",&amp;n); for(int o=0;o&lt;=1;++o) &#123; scanf("%d",&amp;k[o]); for(int i=1;i&lt;=k[o];++i) scanf("%d",&amp;a[o][i]); &#125; dfs(0,1),dfs(1,1); for(int o=0;o&lt;=1;++o) &#123; for(int i=2;i&lt;=n;++i) &#123; printf("%s%c",vis[o][i]?win[o][i]?"Win":"Lose":"Loop"," \n"[i==n]); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Codeforces</tag>
        <tag>搜索</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 1034A」Enlarge GCD]]></title>
    <url>%2Farticles%2Fproblem-Codeforces-1034A-Enlarge-GCD%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Codeforces 1034A Mr. F 现在有 $n$ 个正整数 $a_i$。 他认为这些数的最大公因数太小了，所以他想通过删除其中的一些数来增大这个最大公因数。你的任务是计算出最少的需要删除的数的个数，使得删除之后剩余数的最大公约数大于删除之前的最大公约数。无解输出 $-1$。 数据范围：$2\le n\le 3\times 10^5$，$1\le a_i\le 1.5\times 10^7$ Solution朴素思路对于最大公约数，我们可以模拟计算的过程，我们写出所有数字的质因子分解式，对于每个小于 $\sqrt{a_i}\approx 4000$ 的质因子，求出其在 $n​$ 个数中最小的指数。 那么要使得 $\gcd$ 增大，必须使得其中一个质因子的指数变大，因此我们对于每个质因子，统计等于最小指数的数的个数，答案即为最小值。 但是我们并没有考虑大于 $\sqrt{a_i}$ 的质因子，由于每个数至多只有一个 $&gt;\sqrt {a_i}$ 的质因子，那么我们统计每个大于 $\sqrt{a_i}$ 的质因子个数，记为 $c_i$。如果要使得质因子变大，只需要对 $n-c_i$ 取最小值即可（这里的 $c_i$ 必须满足 $c_i&lt;n$，即 $c_i$ 对原来的最大公约数没有贡献）。 如果 $ans$ 的值为极大值，那么无解。 由于小于 $\sqrt{a_i}$ 的质数个数为 $O\left(\frac{\sqrt{a_i}}{\log a_i}\right)$ 个，分解质因子的复杂度为 $O(\log a_i)$，故总复杂度为 $O(n\sqrt{a_i})$。 时间复杂度：$O(n\sqrt{a_i})$ 优化思路我们发现，如果把 $a_i$ 都除以 $\gcd(a_1,a_2,\dots,a_n)$，那么此时 $\gcd(a_1,a_2,\dots,a_n)$ 的值就是 $1$ 了，我们的就是使得此时的 $a_i$ 的最大公约数大于 $1$。 很自然地，我们想到可以枚举 $\gcd(a_1,a_2,\dots,a_n)=d$，然后统计这些 $a_i$ 中有多少个 $d$ 的倍数即可。 由于质数的个数有 $O\left(\frac{a_i}{\log a_i}\right)$ 个，枚举倍数的复杂度是调和级数，均摊为 $O(\log a_i)$，那么复杂度为 $O(a_i)$（计算 $\gcd$ 需要 $\log a_i​$ 的复杂度）。 时间复杂度：$O(a_i)$ Code朴素思路12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;map&gt;const int N=3e5+5;int n,a[N],tot,p[N],mn[N],cnt[N],rcnt[N];bool flg[N];std::map&lt;int,int&gt; mp;void sieve(int n) &#123; for(int i=2;i&lt;=n;++i) &#123; if(!flg[i]) p[++tot]=i; for(int j=1;j&lt;=tot&amp;&amp;i*p[j]&lt;=n;++j) &#123; flg[i*p[j]]=1; if(i%p[j]==0) break; &#125; &#125;&#125;int getcnt(int &amp;x,int p) &#123; int ans=0; while(x%p==0) x/=p,++ans; return ans;&#125;void solve() &#123; memset(mn,0x3f,sizeof(mn)); int idx=0; for(int i=1;i&lt;=n;++i) &#123; for(int j=1;j&lt;=tot;++j) &#123; int c=getcnt(a[i],p[j]); if(mn[j]&gt;c) mn[j]=c,cnt[j]=1; else if(mn[j]==c) ++cnt[j]; &#125; if(a[i]&gt;1) &#123; if(!mp[a[i]]) mp[a[i]]=++idx; ++rcnt[mp[a[i]]]; &#125; &#125; int ans=n; for(int i=1;i&lt;=tot;++i) ans=std::min(ans,cnt[i]); for(int i=1;i&lt;=idx;++i) ans=std::min(ans,n-rcnt[i]&gt;0?n-rcnt[i]:n); printf("%d\n",ans==n?-1:ans);&#125;int main() &#123; sieve(4000); scanf("%d",&amp;n); for(int i=1;i&lt;=n;++i) scanf("%d",&amp;a[i]); solve(); return 0;&#125; 优化思路12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int N=3e5+5,M=1.5e7+5;int n,tot,a[N],p[M/10],cnt[M];bool flg[M];void sieve(int n) &#123; for(int i=2;i&lt;=n;++i) &#123; if(!flg[i]) p[++tot]=i; for(int j=1;j&lt;=tot&amp;&amp;i*p[j]&lt;=n;++j) &#123; flg[i*p[j]]=1; if(i%p[j]==0) break; &#125; &#125;&#125;int gcd(int x,int y) &#123; return y?gcd(y,x%y):x;&#125;int main() &#123; scanf("%d",&amp;n); int d=0,mx=0; for(int i=1;i&lt;=n;++i) scanf("%d",&amp;a[i]),d=gcd(d,a[i]); for(int i=1;i&lt;=n;++i) a[i]/=d,mx=std::max(mx,a[i]),++cnt[a[i]]; sieve(mx); int ans=n; for(int i=1;i&lt;=tot;++i) &#123; int x=p[i],num=0; for(int j=x;j&lt;=mx;j+=x) num+=cnt[j]; if(num) ans=std::min(ans,n-num); &#125; printf("%d\n",ans==n?-1:ans); return 0;&#125;]]></content>
      <tags>
        <tag>线性筛</tag>
        <tag>贪心</tag>
        <tag>GCD</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 776E」The Holmes Children]]></title>
    <url>%2Farticles%2Fproblem-Codeforces-776E-The-Holmes-Children%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Codeforces 776E Holmes 的孩子们在争论谁才是他们中最聪明的。 Mycroft 提出了如下的函数求值问题：已知 $f(1)=1​$，且当 $n\ge 2​$ 时，$f(n)​$ 表示满足 $x+y=n​$ 的互质的正整数对 $(x,y)​$ 的对数，$g(n)=\sum_{d\mid n}f\left(\frac{n}{d}\right)​$。 她定义了一个函数 $F_k(n)$，其值可以通过如下式子递归求解： F_k(n)=\begin{cases} f(g(n)) & k=1 \\ g(F_{k-1}(n)) & k>1,k\bmod 2=0 \\ f(F_{k-1}(n)) & k>1,k\bmod 2 =1 \end{cases}现在她希望你对于给定 $n,k$，求出 $F_k(n)\bmod 1000000007$ 的值。 数据范围：$1\le n,k\le 10^{12}$ Solution我们先推导一下 $f(n)$ 和 $g(n)$ 函数到底长成什么样子： \begin{aligned} f(n) & =\sum_{i=1}^{n-1} [\gcd(i,n-i)=1] \\ &=\sum_{i=1}^{n-1}[\gcd(i,n)=1] \\ &=\varphi(n) \end{aligned}由于 $f(n)$ 就是 $\varphi(n)$ 函数，那么 $g(n)$ 函数可以通过如下式子表示： \begin{aligned} g(n) & =\sum_{d\mid n} f\left(\frac{n}{d}\right) \\ & = \sum_{d\mid n} \varphi\left(\frac{n}{d}\right) \end{aligned}显然这是一个卷积的形式： g=\varphi\ast 1=\texttt{ID}因此 $g(n)=n$！ 那么递归式变为： F_k(n)=\begin{cases} \varphi(n) & k=1 \\ F_{k-1}(n) & k>1,k\bmod 2=0 \\ \varphi(F_{k-1}(n)) & k>1,k\bmod 2 =1 \end{cases}我们可以找规律发现，$F_k(n)$ 的值就是对 $n$ 求 $\left\lfloor\frac{k+1}{2}\right\rfloor$ 次 $\varphi$ 函数。 显然我们不能真的求 $O(k)​$ 次 $\varphi​$，由于 $n​$ 求 $O(\log n)​$ 次 $\varphi​$ 的值就是 $1​$，此时再求 $\varphi​$ 就没有意义了。故我们只需要求 $\max\left(\log n,\left\lfloor\frac{k+1}{2}\right\rfloor\right)​$ 次 $\varphi​$ 即可。 时间复杂度：$O\left(\max\left(\log n,\left\lfloor\frac{k+1}{2}\right\rfloor\right)\sqrt n\right)​$ Code123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;const int N=1e6+5;int tot,p[N];bool flg[N];void sieve(int n) &#123; for(int i=2;i&lt;=n;++i) &#123; if(!flg[i]) p[++tot]=i; for(int j=1;j&lt;=tot&amp;&amp;i*p[j]&lt;=n;++j) &#123; flg[i*p[j]]=1; if(i%p[j]==0) break; &#125; &#125;&#125;long long phi(long long x) &#123; long long ans=x; for(int i=1;i&lt;=tot&amp;&amp;1LL*p[i]*p[i]&lt;=x;++i) &#123; if(x%p[i]) continue; ans=ans/p[i]*(p[i]-1); while(x%p[i]==0) x/=p[i]; &#125; if(x&gt;1) ans=ans/x*(x-1); return ans;&#125;int main() &#123; sieve(N-5); long long n,k; scanf("%lld%lld",&amp;n,&amp;k); k=(k+1)/2; for(long long i=1;i&lt;=k&amp;&amp;n&gt;1;++i) &#123; n=phi(n); &#125; printf("%lld\n",n%1000000007); return 0;&#125;]]></content>
      <tags>
        <tag>欧拉函数</tag>
        <tag>线性筛</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 3813」奇数国]]></title>
    <url>%2Farticles%2Fproblem-BZOJ-3813-Odd-Number-Country%2F</url>
    <content type="text"><![CDATA[Description 题目链接：BZOJ 3813 在一片美丽的大陆上有 $100000$ 个国家，每个国家有一个银行。某大公司的领袖在这 $100000$ 个银行开户时都存了 $3$ 大洋，他惜财如命，因此会不时地派小弟 GFS 清点一些银行的存款或者让 GFS 改变某个银行的存款。这里发行的软妹面额是最小的 $60$ 个素数，任何人的财产都只能由这 $60​$ 个基本面额表示。 领袖习惯将一段编号连续的银行里的存款拿到一个账房去清点。如果领袖选择清点编号在 $[a,b]$ 内的银行财产，他会先对 $[a,b]$ 的财产求和（计为 $\text{product}$），然后在编号属于 $[1,\text{product}]$ 的账房中选择一个去清点存款。一个账房 $\text{number}$ 可能被选中当且仅当 $\gcd(\text{product},\text{number})=1$。当领袖又赚大钱了的时候，他会在某个银行改变存款，但是领袖不会在某个银行的存款总数超过 $10^6$。 现在 GFS 预先知道了领袖的清点存款与变动存款的 $x$ 次计划，想请你告诉他，每次清点存款时领袖有多少个账房可以供他选择，当然这个值可能非常大，GFS 只想知道对 $19961993$ 取模后的答案。 数据范围：$1\le x\le 10^5$ Solution我们注意到，每个数的标准分解形式中只有可能出现前 $60​$ 个数字，那么我们考虑用线段树维护区间内每个质因子是否出现过（笔者使用压位，用 $\text{long long}​$ 储存，操作起来较为简单），并维护区间内的乘积。统计答案时，我们只需要求出区间的乘积的 $\varphi​$ 函数值即可。 时间复杂度：$O(60\cdot m\log n)​$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define lson p&lt;&lt;1#define rson p&lt;&lt;1|1const int prime[]=&#123;2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281&#125;;const int invpr[]=&#123;9980997,6653998,11977196,8555140,5444180,1535538,10568114,14708837,3471651,11701858,17386252,1618540,16066970,2321162,18263100,16948862,12518538,15380552,10725847,1686929,13399146,17182475,12025297,15924736,13582387,395287,6395590,15857658,16299242,6359573,3300802,18742940,6702567,10914471,16210746,11765678,5340151,18247466,7769638,8077107,11932588,6506948,1985748,6619521,5877135,4413707,9744480,10115270,14597757,16475182,18334191,5011379,18885205,7555336,621385,11309266,12170137,12006660,18304499,11153142&#125;;const int N=1e5+5;const int mod=19961993;int n=100000,m,a[N],mul[N&lt;&lt;2];long long seg[N&lt;&lt;2];void pushup(int p) &#123; seg[p]=seg[lson]|seg[rson]; mul[p]=1LL*mul[lson]*mul[rson]%mod;&#125;void modify(int x,int p,int l,int r,long long f,int v) &#123; if(l==r) &#123; seg[p]^=f,mul[p]=v; return; &#125; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) modify(x,lson,l,mid,f,v); else modify(x,rson,mid+1,r,f,v); pushup(p);&#125;long long queryFac(int x,int y,int p,int l,int r) &#123; if(x&lt;=l&amp;&amp;r&lt;=y) return seg[p]; int mid=(l+r)&gt;&gt;1; long long ans=0; if(x&lt;=mid) ans|=queryFac(x,y,lson,l,mid); if(mid&lt;y) ans|=queryFac(x,y,rson,mid+1,r); return ans;&#125;int queryMul(int x,int y,int p,int l,int r) &#123; if(x&lt;=l&amp;&amp;r&lt;=y) return mul[p]; int mid=(l+r)&gt;&gt;1,ans=1; if(x&lt;=mid) ans=1LL*ans*queryMul(x,y,lson,l,mid)%mod; if(mid&lt;y) ans=1LL*ans*queryMul(x,y,rson,mid+1,r)%mod; return ans;&#125;int query(int l,int r) &#123; int ans=queryMul(l,r,1,1,n); long long f=queryFac(l,r,1,1,n); for(int i=0;i&lt;60;++i) &#123; if(f&amp;(1LL&lt;&lt;i)) ans=1LL*ans*invpr[i]%mod*(prime[i]-1)%mod; &#125; return ans;&#125;void ins(int x,int val) &#123; long long f=0; for(int i=0;i&lt;60;++i) &#123; if(val%prime[i]==0) f^=1LL&lt;&lt;i;# &#125; modify(x,1,1,n,f,val);&#125;int main() &#123; for(int i=1;i&lt;=n;++i) a[i]=3,modify(i,1,1,n,2,a[i]); for(scanf("%d",&amp;m);m--;) &#123; int o,x,y; scanf("%d%d%d",&amp;o,&amp;x,&amp;y); if(o==0) &#123; printf("%d\n",query(x,y)); &#125; else &#123; ins(x,a[x]),ins(x,a[x]=y); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>欧拉函数</tag>
        <tag>BZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu 5179」Fraction]]></title>
    <url>%2Farticles%2Fproblem-Luogu-5179-Fraction%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Luogu 5179 给你四个正整数 $a,b,c,d$，求一个最简分数 $\frac{p}{q}$ 满足 $\frac{a}{b}&lt;\frac{p}{q}&lt;\frac{c}{d}​$。 若有多组解，输出 $q$ 最小的一组，若仍有多组解，输出 $p$ 最小的一组。数据保证至少存在一个最简分数符合条件。 本题 $T$ 组数据。 数据范围：$1\le T\le 500$，$1\le a,b,c,d\le 10^9$ Solution其实这个问题的本质是类欧几里德算法。我们分为如下 $3$ 种情况考虑： $\left\lfloor\frac{a}{b}\right\rfloor+1\le\left\lceil\frac{c}{d}\right\rceil-1​$ 这意味着 $\left(\frac{a}{b},\frac{c}{d}\right)$ 之间存在一个整数，我们直接让 $p=1,p=\left\lfloor\frac{a}{b}\right\rfloor+1$ 即可。 $a=0$ 这意味着只需要满足 $\frac{p}{q}&lt;\frac{c}{d}​$，即为 $q&gt;\frac{pd}{c}​$。我们为了取得最优解，可以直接取 $p=1,q=\left\lfloor\frac{d}{c}\right\rfloor+1​$。 $a\le b$ 且 $c\le d$ 这意味着我们无法直接求解，需要进行一个转化：将原式 $\frac{a}{b}&lt;\frac{p}{q}&lt;\frac{c}{d}​$ 的每个分数都取倒数，由于每个数都是正数，那么可以得到 $\frac{d}{c}&lt;\frac{q}{p}&lt;\frac{b}{a}​$，直接递归处理即可。 $a\ge b$ 这意味着第 $1$ 个分数和第 $3$ 个分数的整数部分都大于 $0$。接下来要进行一个重要的转化：我们可以将每个分数减去 $\left\lfloor\frac{a}{b}\right\rfloor$，直接递归处理 $\frac{a\bmod b}{b}&lt;\frac{p}{q}-\left\lfloor\frac{a}{b}\right\rfloor&lt;\frac{c}{d}-\left\lfloor\frac{a}{b}\right\rfloor$ 即可。注意递归处理完后，需要将 $p$ 加上 $q\times \left\lfloor\frac{a}{b}\right\rfloor$。 这个过程中形式上极其类似于欧几里德算法，将 $(a,b)$ 转化为 $(a\bmod b,b)$ 正是其精髓所在。 Code12345678910111213141516171819202122232425#include &lt;cstdio&gt;typedef long long LL;LL gcd(LL x,LL y) &#123; return y?gcd(y,x%y):x;&#125;void sim(LL &amp;x,LL &amp;y) &#123; LL d=gcd(x,y); x/=d,y/=d;&#125;void solve(LL a,LL b,LL c,LL d,LL &amp;p,LL &amp;q) &#123; sim(a,b),sim(c,d); LL x=a/b+1,y=(c-1)/d; if(x&lt;=y) p=x,q=1; else if(!a) p=1,q=d/c+1; else if(a&lt;=b&amp;&amp;c&lt;=d) solve(d,c,b,a,q,p); else solve(a%b,b,c-d*(a/b),d,p,q),p+=q*(a/b);&#125;int main() &#123; LL a,b,c,d,p,q; while(~scanf("%lld%lld%lld%lld",&amp;a,&amp;b,&amp;c,&amp;d)) &#123; solve(a,b,c,d,p,q); printf("%lld/%lld\n",p,q); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>类欧几里德算法</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 4804」欧拉心算]]></title>
    <url>%2Farticles%2Fproblem-BZOJ-4804-Euler-Mental-Arithmetic%2F</url>
    <content type="text"><![CDATA[Description 题目链接：BZOJ 4804 求如下式子的值： \sum_{i=1}^n\sum_{j=1}^n\varphi(\gcd(i,j))本题 $T$ 组数据。 数据范围：$1\le T\le 5000$，$1\le n\le 10^7$ Solution我们直接拆式子： \begin{aligned} \text{原式}&=\sum_{i=1}^n\sum_{j=1}^n\varphi(\gcd(i,j)) \\ &=\sum_{d=1}^n\varphi(d)\sum_{i=1}^n\sum_{j=1}^n \left[\gcd(i,j)=d\right] \\ &=\sum_{d=1}^n\varphi(d)\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\left[\gcd(i,j)=1\right]\\ &=\sum_{d=1}^n\varphi(d)\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}2\times\varphi(i)-1 \end{aligned}我们记 $sum(k)=\sum_{i=1}^k\varphi(i)$，那么有： \begin{aligned} \text{原式}&=\sum_{d=1}^n\varphi(d)\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}2\times\varphi(i)-1 \\ &=\sum_{d=1}^n\varphi(d)(2\times sum\left(\left\lfloor\frac{n}{d}\right\rfloor\right)-1) \end{aligned}我们发现这里的 $\left\lfloor\frac{n}{d}\right\rfloor$ 只有 $\sqrt n$ 种取值，因此我们可以数论分块求解。 时间复杂度：$O(T\sqrt n)​$ Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;const int N=1e7+5,M=1e6+5;int n,tot,p[M],phi[N];long long sum[N];bool flg[N];void sieve(int n) &#123; phi[1]=1; for(int i=2;i&lt;=n;++i) &#123; if(!flg[i]) p[++tot]=i,phi[i]=i-1; for(int j=1;j&lt;=tot&amp;&amp;i*p[j]&lt;=n;++j) &#123; flg[i*p[j]]=1; if(i%p[j]==0) &#123; phi[i*p[j]]=phi[i]*p[j]; break; &#125; else &#123; phi[i*p[j]]=phi[i]*phi[p[j]]; &#125; &#125; &#125; for(int i=1;i&lt;=n;++i) sum[i]=sum[i-1]+phi[i];&#125;int main() &#123; sieve(N-5); int T; for(scanf("%d",&amp;T);T--;) &#123; int n; scanf("%d",&amp;n); long long ans=0; for(int i=1,j;i&lt;=n;i=j+1) &#123; j=n/(n/i); ans+=(2LL*sum[n/i]-1)*(sum[j]-sum[i-1]); &#125; printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>欧拉函数</tag>
        <tag>BZOJ</tag>
        <tag>数论分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HDU 1299」Diophantus of Alexandria]]></title>
    <url>%2Farticles%2Fproblem-HDU-1299-Diophantus-of-Alexandria%2F</url>
    <content type="text"><![CDATA[Description 题目链接：HDU 1299 求解如下丢番图方程的正整数解个数： \frac{1}{x}+\frac{1}{y}=\frac{1}{n}\quad (x,y,n\in\mathbb{N}^+,x\le y)本题 $T$ 组数据。 数据范围：$1\le n\le 10^9$ Solution我们先将方程消去分母： xy-n(x+y)=0由于 $xy$ 中 $x$ 和 $y$ 都是二次的，那么我们使用十字相乘法，将未知数放在方程左侧： (x-n)(y-n)=n^2此时我们发现 $x$ 和 $y$ 都是一次的了，只需要将 $n^2$ 分解质因子，用约数和定理来计算答案即可。 \sigma(n)=\prod(c_i+1)时间复杂度：$O(T\sqrt n)​$ Code123456789101112131415161718#include &lt;cstdio&gt;int main() &#123; int T,cs=0; for(scanf("%d",&amp;T);T--;) &#123; int n; scanf("%d",&amp;n); int ans=1; for(int i=2;i*i&lt;=n;++i) &#123; int cnt=0; while(n%i==0) n/=i,++cnt; ans*=2*cnt+1; &#125; if(n&gt;1) ans*=3; printf("Scenario #%d:\n%d\n\n",++cs,(ans+1)/2); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>HDU</tag>
        <tag>约数和定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 724C」Ray Tracing]]></title>
    <url>%2Farticles%2Fproblem-Codeforces-724C-Ray-Tracing%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Codeforces 724C 有一个 $n\times m$ 的矩形，四周有围墙围起来，其左上角和右下角的坐标分别为 $(0,0)$ 和 $(n,m)$。从 $(0,0)$ 开始以 $\sqrt 2$ 个单位每秒的速度向 $(1,1)$ 的方向发射一束光线，每次遇到墙都正常反射（符合物理的反射），光线射到顶点会被吸收。在这个矩形内有 $k$ 个点，坐标分别为 $(x_i,y_i)$，求每个点第一次被光线经过的时刻。 数据范围：$2\le n,m\le 10^5$，$1\le k\le 10^5$，$1\le x_i&lt;n$，$1\le y_i&lt;m$ Solution对于这类矩形内上的反射问题，我们可以将矩形无限展开，那么相当于我们把点按照矩形边界对称，光线也就边成了一条直线。 我们考虑对称后的点的坐标是什么。如果原来的坐标为 $(x,y)$，那么按照第 $k$ 条横轴展开的坐标为 $(x,2km-y)$，按照第 $k$ 条纵轴展开的左边为 $(kn-x,y)$。因此，如果我们沿着若干条轴展开后，坐标一定可以写成 $(k_1n\pm x,k_2m\pm y)$ 的形式。 由于我们知道了展开后的坐标，那么有如下方程： k_1n\pm x=k_2m\pm y\Longrightarrow k_1n-k_2m=\pm x\pm y发现这是一个丢番图方程，我们可以直接解出 $(k_1,k_2)$ 的通解。 但是，题目中规定光线在矩形顶点位置会被吸收，那么我们就要保证坐标的绝对值小于等于 $\operatorname{lcm}(n,m)$，否则光线一定会经过 $\operatorname{lcm}(n,m)$ 这个点而被吸收。 因此，我们对 $4$ 种情况分别求解，找到一组解使得 $k_1n\pm x$ 的值尽量小且大于 $0$。形象地说，就是使得 $k_1n\pm x$ 最小并满足 $0&lt;k_1n\pm x&lt;\operatorname{lcm}(n,m)​$。 这个最小的符合条件的解就是答案。 时间复杂度：$O(k\log n)$ Code12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;algorithm&gt;typedef long long LL;const LL INF=1LL&lt;&lt;60;int n,m,k;LL mx;int gcd(int a,int b) &#123; return b?gcd(b,a%b):a;&#125;int exgcd(int a,int b,int &amp;x,int &amp;y) &#123; if(!b) &#123;x=1,y=0;return a;&#125; int d=exgcd(b,a%b,y,x); y-=a/b*x; return d;&#125;LL solve(int dx,int dy) &#123; int a=2*n,b=-2*m,c=dy-dx,x,y; int d=exgcd(a,b,x,y); if(c%d) return INF; a/=d,b/=d,c/=d,b=std::abs(b),x=(x*c%b+b)%b; LL ans=2LL*n*x+dx; if(ans&lt;=0||ans&gt;=mx) return INF; return ans;&#125;int main() &#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); mx=1LL*n*m/gcd(n,m); while(k--) &#123; int x0,y0; scanf("%d%d",&amp;x0,&amp;y0); LL ans=INF; ans=std::min(ans,solve(+x0,+y0)); ans=std::min(ans,solve(+x0,-y0)); ans=std::min(ans,solve(-x0,+y0)); ans=std::min(ans,solve(-x0,-y0)); printf("%lld\n",ans==INF?-1:ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>同余</tag>
        <tag>exGCD</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI 2012」Longge 的问题]]></title>
    <url>%2Farticles%2Fproblem-SDOI-2012-Longge-Problem%2F</url>
    <content type="text"><![CDATA[Description 题目链接：BZOJ 2705 Longge 的数学成绩非常好，并且他非常乐于挑战高难度的数学问题。现在问题来了：给定一个整数 $n$，你需要求出： \sum_{i=1}^n\gcd(i,n)数据范围：$1\le n\le 2^{32}​$ Solution我们直接拆一下式子： \begin{aligned} \text{原式}&=\sum_{i=1}^n\gcd(i,n) \\ & =\sum_{d\mid n}d\times \sum_{i=1}^n [\gcd(i,n)=d] \\ & =\sum_{d\mid n}d\times \sum_{i=1}^{\frac{n}{d}} \left[\gcd\left(i,\frac{n}{d}\right)=1\right] \\ \\ & =\sum_{d\mid n}d\cdot \varphi(\frac{n}{d}) \\ \end{aligned}这个转化的过程非常套路，我们只要暴力枚举 $n$ 的因数并快速求出单个 $\varphi​$ 函数的值即可。 时间复杂度：$O(\text{因子个数}\times \sqrt n)​$（稳过 QAQ） Code123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cmath&gt;const int N=(1&lt;&lt;16)+5;int n,tot,p[N];bool flg[N];void sieve(int n) &#123; for(int i=2;i&lt;=n;++i) &#123; if(!flg[i]) p[++tot]=i; for(int j=1;j&lt;=tot&amp;&amp;i*p[j]&lt;=n;++j) &#123; flg[i*p[j]]=1; if(i%p[j]==0) break; &#125; &#125;&#125;long long phi(long long x) &#123; long long ans=x; for(int i=1;i&lt;=tot&amp;&amp;1LL*p[i]*p[i]&lt;=x;++i) &#123; if(x%p[i]) continue; ans=ans/p[i]*(p[i]-1); while(x%p[i]==0) x/=p[i]; &#125; if(x&gt;1) ans=ans/x*(x-1); return ans;&#125;int main() &#123; long long n,ans=0; scanf("%lld",&amp;n); sieve((int)sqrt(n)); for(long long i=1;i*i&lt;=n;++i) &#123; if(n%i==0) &#123; ans+=i*phi(n/i); if(i*i!=n) ans+=n/i*phi(i); &#125; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>欧拉函数</tag>
        <tag>BZOJ</tag>
        <tag>SDOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法笔记」欧拉函数]]></title>
    <url>%2Farticles%2Falgorithm-Euler-Function%2F</url>
    <content type="text"><![CDATA[欧拉函数是数论中的一个重要积性函数。 定义欧拉函数 $\varphi(n)$ 表示 $[1,n]$ 中与 $n$ 互质的正整数的个数。例如，$\varphi(p)=p-1,\varphi(1)=1$。 计算式首先我们证明如下公式（其中 $p$ 为质数）： \varphi(p^c)=p^c-p^{c-1}这个公式计算的证明十分简单，我们考虑容斥原理。$[1,p^c]$ 中与 $p^c$ 不互质的数的个数有 $\frac{p^c}{p}$ 个，即 $p^{c-1}$ 个，证明完毕。 有了这个式子，在加上欧拉函数是积性函数，我们可以得到计算式： \text{设}\ n\ \text{的质因子分解式为}\ \prod_{i=1}^k {p_i}^{c_i}\text{，则}\ \varphi(n)=n\prod_{i=1}^k\frac{p_i-1}{p_i} 性质欧拉函数有一个重要的性质： n=\sum_{d\mid n}\varphi(d)\Longleftrightarrow \varphi\ast 1=\operatorname{ID}这个证明过程在「算法笔记」莫比乌斯反演 中已经涉及，我们在此再次证明一遍： \begin{aligned} \varphi\ast 1 & =\sum_{d\mid n}\varphi(\frac{n}{d}) \\ & =\sum_{i=0}^c\varphi(p^i) \\ & =1+p^0\cdot(p-1)+p^1\cdot(p-1)+\cdots+p^{c-1}\cdot(p-1) \\ & =p^c \\ & =\operatorname{ID} \\ \end{aligned} 求值线性筛由于欧拉函数是积性函数，所以可以线性筛，代码如下： 123456789101112131415void sieve(int n) &#123; phi[1]=1; for(int i=2;i&lt;=n;++i) &#123; if(!flg[i]) p[++tot]=i,phi[i]=i-1; for(int j=1;j&lt;=tot&amp;&amp;i*p[j]&lt;=n;++j) &#123; flg[i*p[j]]=1; if(i%p[j]==0) &#123; phi[i*p[j]]=phi[i]*p[j]; break; &#125; else &#123; phi[i*p[j]]=phi[i]*phi[p[j]]; &#125; &#125; &#125;&#125; 单个求值此时我们只要按照定义来做就行啦！（把质数预处理出来可以加速） 12345678910int phi(int x) &#123; int ans=x; for(int i=1;i&lt;=tot&amp;&amp;p[i]*p[i]&lt;=x;++i) &#123; if(x%p[i]) continue; ans=ans/p[i]*(p[i]-1); while(x%p[i]==0) x/=p[i]; &#125; if(x&gt;1) ans=ans/x*(x-1); return ans;&#125; 欧拉定理当我们要求 $a^b\bmod p$ 时，显然指数不能直接对 $p​$ 取模，为此我们引入欧拉定理。 欧拉定理：若 $\gcd(a,p)=1$，则 $a^{\varphi(p)}\equiv 1\pmod p$。 扩展欧拉定理：若 $b&gt;\varphi(p)$，则 $a^b\equiv a^{b\bmod \varphi(p)+\varphi(p)}\pmod p​$。 因此我们可以得到如下公式： a^c=\begin{cases} a^{b\bmod\varphi(p)} & \gcd(a,p)=1 \\ a^b & \gcd(a,p)\neq 1,c]]></content>
      <tags>
        <tag>算法笔记</tag>
        <tag>数论</tag>
        <tag>欧拉函数</tag>
        <tag>欧拉定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI 2008」沙拉公主的困惑]]></title>
    <url>%2Farticles%2Fproblem-SDOI-2008-Princess-Confusion%2F</url>
    <content type="text"><![CDATA[Description 题目链接：BZOJ 2186 大富翁国因为通货膨胀，以及假钞泛滥，政府决定推出一项新的政策：现有钞票编号范围为 $[1,n!]$，但是，政府只发行编号与 $m!$ 互质的钞票。房地产第一大户沙拉公主决定预测一下大富翁国现在所有真钞票的数量。现在，请你帮助沙拉公主解决这个问题，由于可能张数非常大，你只需计算出对 $R$ 取模后的答案即可，保证 $R​$ 是一个质数。 本题 $T$ 组数据。 数据范围：$1\le T\le 10^4$，$1\le R\le 10^9+10$，$1\le m\le n\le 10^7$ Solution显然我们可以推导出答案为： \sum_{i=1}^{n!} [\gcd(i,m!)=1]首先我们有如下结论：当 $\gcd(x,y)=1$ 时，$\gcd(x+ky,y)$ 也等于 $1$。这个通过 $\gcd$ 的更相减损术很容易证明。 由于题目保证了 $n\ge m$，那么我们可以把 $[1,n!]$ 分成若干段： (0,m!],(m!,2m!],(2m!,3m!],\dots,(km!,n!]这样一来，每一段的答案一定是一样的。（当 $\gcd(x,m!)=1$ 时，一定有 $\gcd(x+km!,m!)=1$）。 那么我们可以变换求和上界： \frac{n!}{m!}\sum_{i=1}^{m!}[\gcd(i,m!)=1]很显然右侧的求和式的值为 $\varphi(m!)$。 我们根据 $\varphi(n)=x\prod \frac{p_i-1}{p_1}$ 的定义，设 $m!=\prod_{i=1}^k {p_i}^{c_i}$，可以得到： \varphi(m!)=m!\prod_{i=1}^k \frac{p_i-1}{p_i}那么我们的答案就是： n!\prod_{i=1}^k \frac{p_i-1}{p_i}于是我们只需要线性筛对于每个 $n$ 求出 $\prod \frac{p_i-1}{p_i}$ 的值即可。 线性筛的具体通过详见代码。 时间复杂度：$O(N+T)$ Code1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;const int N=1e7+5,M=N/10;int n,R,tot,p[M],ans[N],fac[N],inv[N];bool flg[N];void prework(int n) &#123; fac[0]=fac[1]=1,inv[0]=inv[1]=1,ans[0]=ans[1]=1; for(int i=2;i&lt;=n;++i) &#123; fac[i]=1LL*fac[i-1]*i%R,inv[i]=1LL*(R-R/i)*inv[R%i]%R; if(!flg[i]) p[++tot]=i; for(int j=1;j&lt;=tot&amp;&amp;i*p[j]&lt;=n;++j) &#123; flg[i*p[j]]=1; if(i%p[j]==0) break; &#125; &#125; for(int i=2;i&lt;=n;++i) &#123; ans[i]=ans[i-1]; if(!flg[i]) ans[i]=1LL*ans[i]*(i-1)%R*inv[i]%R; &#125;&#125;int main() &#123; int T; scanf("%d%d",&amp;T,&amp;R); prework(N-5); while(T--) &#123; int n,m; scanf("%d%d",&amp;n,&amp;m); printf("%lld\n",1LL*fac[n]*ans[m]%R); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>欧拉函数</tag>
        <tag>BZOJ</tag>
        <tag>SDOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2818」GCD]]></title>
    <url>%2Farticles%2Fproblem-BZOJ-2818-GCD%2F</url>
    <content type="text"><![CDATA[Description 题目链接：BZOJ 2818 给定整数 $n$，求 $1\le x,y\le n$ 且 $\gcd(x,y)$ 为素数的数对 $(x,y)$ 有多少对。 数据范围：$1\le n\le 10^7​$ Solution 本题和「Luogu 2257」YY 的 GCD（题解） 几乎完全一样，但是本题由于是单组询问，所以不需要 $O(n)​$ 的预处理和 $O(\sqrt n)​$ 的单次询问复杂度。 首先我们枚举质数： \sum_{p\in\text{prime}}\sum_{i=1}^n\sum_{j=1}^n[\gcd(i,j)=p]对 $\gcd$ 进行套路式的变形： \sum_{p\in\text{prime}}\sum_{i=1}^{\left\lfloor\frac{n}{p}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{n}{p}\right\rfloor} [\gcd(i,j)=1]接下来改变 $j$ 的枚举上界（其中 $-1$ 的原因是 $i=j=1$ 时的答案会被重复统计，因此注意这里的 $-1$ 是在 $\sum_{p\in\text{prime}}$ 中的，而不是在 $\sum_{i=1}^{\left\lfloor\frac{n}{p}\right\rfloor}$ 中的）： \sum_{p\in\text{prime}}\left(\sum_{i=1}^{\left\lfloor\frac{n}{p}\right\rfloor}\left(2\sum_{j=1}^i [\gcd(i,j)=1]\right)-1\right)此已经可以发现最后一个 $\sum$ 是的值就是 $\varphi(i)$，故原式化为： \sum_{p\in\text{prime}}\left(2\sum_{i=1}^{\left\lfloor\frac{n}{p}\right\rfloor}\varphi(i)-1\right)所以我们可以线性筛求出 $\varphi(i)​$ 的值并做前缀和，枚举 $p\in\text{prime}\ \text{and}\ p\le n​$ 并统计答案即可。 时间复杂度：$O(n)​$ Code12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;const int N=1e7+5,M=1e6+5;int n,tot,p[M],phi[N];long long sum[N];bool flg[N];void sieve(int n) &#123; phi[1]=1; for(int i=2;i&lt;=n;++i) &#123; if(!flg[i]) p[++tot]=i,phi[i]=i-1; for(int j=1;j&lt;=tot&amp;&amp;i*p[j]&lt;=n;++j) &#123; flg[i*p[j]]=1; if(i%p[j]==0) &#123; phi[i*p[j]]=phi[i]*p[j]; break; &#125; else &#123; phi[i*p[j]]=phi[i]*phi[p[j]]; &#125; &#125; &#125; for(int i=1;i&lt;=n;++i) sum[i]=sum[i-1]+phi[i];&#125;int main() &#123; scanf("%d",&amp;n); sieve(n); long long ans=0; for(int i=1;i&lt;=tot;++i) ans+=2*sum[n/p[i]]-1; printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>欧拉函数</tag>
        <tag>BZOJ</tag>
        <tag>线性筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HAOI 2012」外星人]]></title>
    <url>%2Farticles%2Fproblem-HAOI-2012-Extra-Terrestrial%2F</url>
    <content type="text"><![CDATA[Description 题目链接：BZOJ 2749 艾利欧在她的被子上发现了一个数字 $n$，她觉得只要找出最小的 $x$ 使得，$\varphi^x(n)=1$。根据这个 $x$ 她就能找到曾经绑架她的外星人的线索了。现在她给你这个数字 $n$ 的标准分解形式 $n=\prod_{i=1}^m {p_i}^{q_i}$，请你帮助她算出最小的 $x$。 本题 $T$ 组数据。 数据范围：$1\le T\le 50$，$1\le p_i\le 10^5$，$1\le q_i\le 10^9$ Solution读完题目之后一脸懵逼：求 $\varphi(n)$ 的 $x$ 阶导数？？？ 其实这题的题意是：给定 $n$，每次使 $n$ 等于 $\varphi(n)$，求最少几次操作后 $n=1$。 首先可以打表发现如下规律：只有 $1$ 和 $2$ 的 $\varphi$ 值才是 $1$！ 接下来我们根据 $\varphi(n)$ 的定义，有如下式子： \varphi\left(\prod_{i=1}^m {p_i}^{c_i}\right)=\prod_{i=1}^m (p_i-1)\times {p_i}^{c_i-1}那么意味着每次操作会把上一次操作的答案中的最多一个 $2$ 变为 $1$（注意：不可能同时变化多个 $2$）。 所以我们只要求出每个质因子在操作过程中会产生多少个 $2$ 即可。 具体的过程为：我们设 $f(i)$ 表示 $i$ 在操作过程中会产生多少个 $2$；那么有如下转移方程： 当 $i$ 为质数时，$f(i)=f(i-1)$，因为质数进行操作后变为 $i-1$ 而没有增加 $2$ 的个数，因此应该和 $f(i-1)$ 的答案相等。 当 $i=a\times b$ 时，$f(i)=f(a)+f(b)$ 因为 $i$ 可以表示为两个数相乘，那么其 $2$ 的次数应该为两者之和。 但是！我们发现直接这样写是会错的！考虑如下情况： 原数为 $3$，那么我们第一次操作不会把任何一个 $2$ 改为 $1$（因为 $3$ 中本来就没有任何一个因子 $2$）。所以需要 $2$ 次操作而不是 $3$ 次！ 因此我们需要处理一下细节问题：当原数中没有因子 $2$ 时，答案 $+1$。 时间复杂度：$O(p_i+Tn)$ Code123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;const int N=1e5+5;int n,tot,p[N],f[N];bool flg[N];void sieve(int n) &#123; f[1]=1; for(int i=2;i&lt;=n;++i) &#123; if(!flg[i]) p[++tot]=i,f[i]=f[i-1]; for(int j=1;j&lt;=tot&amp;&amp;i*p[j]&lt;=n;++j) &#123; flg[i*p[j]]=1,f[i*p[j]]=f[i]+f[p[j]]; if(i%p[j]==0) break; &#125; &#125;&#125;int main() &#123; sieve(N-5); int T; for(scanf("%d",&amp;T);T--;) &#123; scanf("%d",&amp;n); long long ans=0,flg=0; for(int i=1;i&lt;=n;++i) &#123; int p,c; scanf("%d%d",&amp;p,&amp;c); if(p==2) flg=1; ans+=1LL*f[p]*c; &#125; if(!flg) ++ans; printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>欧拉函数</tag>
        <tag>BZOJ</tag>
        <tag>线性筛</tag>
        <tag>HAOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法笔记」BSGS]]></title>
    <url>%2Farticles%2Falgorithm-BSGS%2F</url>
    <content type="text"><![CDATA[BSGS 用于解决高次同余方程的最小整数解，主要思想是分块。 引入求出下面方程的最小非负整数解 $x$： a^x\equiv b\pmod p\quad (\gcd(a,p)=1)此处的未知数 $x$ 在指数上，我们就要用到 $\text{BSGS}$（$\text{Baby Step Giant Step}$）算法。 思想$\text{BSGS}$ 的本质是分块的思想，我们设 $m=\left\lceil\sqrt p\right\rceil$（注意是上取整），又设 $x=i\times m-j$，其中 $0\le i\le m,0\le j&lt;m$；我们可以将原方程转化为： a^{i\times m-j}\equiv b\pmod p在 $x=i\times m-j​$ 中，$i​$ 即为大步，$j​$ 即为小步；我们将 $j​$ 移到方程的右边得到： a^{i\times m}\equiv b\times a^j\pmod p观察到 $j​$ 只有 $O(m)​$ 种取值，所以我们对于每个 $j​$，把 $b\times a^j\bmod p​$ 的值记录下来，存放在哈希表中（有没有一种分块打表的感觉？）。然后枚举左半边的 $i​$，将对应的值在哈希表中查找对应的 $j​$，如果能找到对应的 $j​$ 那么说明已经找到答案了。 对于插入哈希表中的 $j$ 的值，显然在同一个值时，$j$ 的值越大越好，那么直接覆盖即可，无需关注细节问题！ 注意：代码中必须要判断无解情况！（本来就无解，或者没有找到合法解） 时间复杂度：$O(\sqrt p)$ 代码12345678910int BSGS(int a,int b,int P) &#123; if(b%gcd(a,P)) return -1; a%=P,b%=P,mp.clear(); int m=ceil(sqrt(P)); for(int i=0;i&lt;m;++i,b=1LL*b*a%P) mp[b]=i; for(int i=0,j=a=pow(a,m,P);i&lt;=m;++i,j=1LL*j*a%P) &#123; if(mp.count(j)&amp;&amp;i*m&gt;=mp[j]) return i*m-mp[j]; &#125; return -1;&#125; 习题 「SDOI 2011」计算器 「SPOJ 3105」MOD - Power Modulo Inverted]]></content>
      <tags>
        <tag>算法笔记</tag>
        <tag>数论</tag>
        <tag>BSGS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 3884」上帝与集合的正确用法]]></title>
    <url>%2Farticles%2Fproblem-BZOJ-3884-God-and-Set%2F</url>
    <content type="text"><![CDATA[Description 题目链接：BZOJ 3884 求如下式子的值： 2^{2^{2\cdots}}\bmod p本题 $T$ 组数据。 数据范围：$1\le T\le 1000$，$1\le p\le 10^7$ Solution首先我们可以根据扩展欧拉定理： \text{当}\ b\ge \varphi(p)\ \text{时，有}\ a^b\equiv a^{b\bmod \varphi(p)+\varphi(p)}\pmod p得到： 2^{2^{2\cdots}}\bmod p=2^{(2^{2\cdots}\bmod \varphi(p)+\varphi(p))}\bmod p很显然这是一个递归式子，边界条件为 $p=1$，此时式子的值为 $0$。 对于 $\varphi(p)$，我们可以线性筛预处理。 时间复杂度：$O(P+T\log p)$ Code12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;const int N=1e7+5,M=N/10;int n,tot,p[M],phi[N];bool flg[N];void sieve(int n) &#123; phi[1]=1; for(int i=2;i&lt;=n;++i) &#123; if(!flg[i]) p[++tot]=i,phi[i]=i-1; for(int j=1;j&lt;=tot&amp;&amp;i*p[j]&lt;=n;++j) &#123; flg[i*p[j]]=1; if(i%p[j]==0) &#123; phi[i*p[j]]=phi[i]*p[j]; break; &#125; else &#123; phi[i*p[j]]=phi[i]*phi[p[j]]; &#125; &#125; &#125;&#125;int pow(int x,int p,int mod) &#123; int ret=1; for(;p;p&gt;&gt;=1,x=1LL*x*x%mod) if(p&amp;1) ret=1LL*ret*x%mod; return ret;&#125;int solve(int p) &#123; if(p==1) return 0; return pow(2,solve(phi[p])+phi[p],p);&#125;int main() &#123; sieve(N-5); int T; for(scanf("%d",&amp;T);T--;) &#123; int p; scanf("%d",&amp;p); printf("%d\n",solve(p)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>欧拉函数</tag>
        <tag>欧拉定理</tag>
        <tag>BZOJ</tag>
        <tag>线性筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法笔记」线性同余方程]]></title>
    <url>%2Farticles%2Falgorithm-Linear-Congruence-Theorem%2F</url>
    <content type="text"><![CDATA[线性同余方程是由一系列同余式组成的，本文主要讲解一元一次同余方程的求解。 基本算法丢番图方程丢番图方程是形如 $ax+by=c$ 的方程，$ax\equiv b\pmod m$ 也是其常见形式之一。 裴蜀定理：丢番图方程 $ax+by=c$ 有解当且仅当 $\gcd(a,b)\mid c$。 扩展欧几里德算法扩展欧几里德算法简称 $\text{exGCD}$，用于求解丢番图方程的整数解。 推导过程： \begin{cases} ax_1+by_1=\gcd(a,b) \\ bx_2+(a\bmod b)y_2=\gcd(b,a\bmod b) \end{cases}我们可以通过 $\gcd(a,b)=\gcd(b,a\bmod b)$ 得到： \begin{aligned} ax_1+by_1&=bx_2+(a\bmod b)y_2 \\ &=bx_2+(a-\left\lfloor\frac{a}{b}\right\rfloor\times b)y_2 \\ &=ay_2+b(x_2-\left\lfloor\frac{a}{b}\right\rfloor\times y_2) \end{aligned}所以： \begin{cases} x_1=y_2 \\ y_1=x_2-\left\lfloor\frac{a}{b}\right\rfloor\times y_2 \end{cases}很显然这是一个递归式，末状态为 $b=0,a=\gcd(a,b)$ 时，$x=1,y=0$。 扩展欧几里德的过程可以理解为从末状态向上不断回溯的过程，直到得到原方程的一组解。 方程通解设 $(x_0,y_0)$ 为方程 $ax+by=c$ 的一组特解，那么方程的通解为（其中 $K$ 为一个系数）： (x_0+K\frac{b}{\gcd(a,b)},y_0-K\frac{a}{\gcd(a,b)})将这个通解代入方程易证。 求方程组的解中国剩余定理（CRT）求解设 $M=\prod_{i=1}^n m_i$，并设 $M_i=\frac{M}{m_i}$，$t_i={M_i}^{-1}$ 为 $M_i$ 模 $m_i$ 的数论倒数（逆元），那么可以得到方程在模 $M$ 意义下的唯一解： x=\left(\sum_{i=1}^n r_it_iM_i\right)\bmod M时间复杂度：$O(n\log M)​$ 证明 x=\sum_{i=1}^n r_it_iM_i\equiv r_j\pmod m_j当 $i\neq j$ 时，$\gcd(M_i,m_j)=1,\gcd(t_i,m_j)=1$，显然不满足条件。 当 $i=j$ 时，显然满足条件。 故中国剩余定理的本质思想就是让每一项只对自己有贡献。 代码由于精度问题，这里的 $n$ 真的不能开得再大了…… 12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;typedef long long LL;const int N=105;int n;LL a[N],m[N];LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y) &#123; if(!b) &#123;x=1,y=0;return a;&#125; LL d=exgcd(b,a%b,y,x); y-=a/b*x; return d;&#125;LL China(int n) &#123; LL M=1,ans=0; for(int i=1;i&lt;=n;++i) M*=m[i]; for(int i=1;i&lt;=n;++i) &#123; LL k=M/m[i],x,y; exgcd(k,m[i],x,y); ans=(ans+x*k%M*a[i]%M)%M; &#125; return (ans+M)%M;&#125;int main() &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;++i) scanf("%lld%lld",&amp;m[i],&amp;a[i]); printf("%lld\n",China(n)); return 0;&#125; 扩展中国剩余定理（ExCRT）求解由于中国剩余定理有特殊限制：$m_i$ 必须两两互质。我们必须找到一个运用更广泛的算法来求出任意线性同余方程组的解。 我们这次直接考虑两个相邻的方程： \begin{cases} x\equiv r_1\pmod {m_1} \\ x\equiv r_2\pmod {m_2} \end{cases}我们把他们拆开得到：$x=k_1m_1+r_1=k_2m_2+r_2$（其中 $k_1$ 和 $k_2$ 均为系数）。 这个式子如果不看 $x$ 则变成： k_1m_1-k_2m_2=a_2-a_1我们把 $k_1$ 和 $k_2$ 看作未知数然后解该丢番图方程。 设 $k_1$ 的通解为 $k+K\frac{m_2}{\gcd(m_1,m_2)}$，那么带回到 $x=k_1m_1+r_1$ 中可以得到： x=km_1+r_1+K\frac{m_1m_2}{\gcd(m_1,m_2)}注意到上述式子中，$\frac{m_1m_2}{\gcd(m_1,m_2)}$ 就是 $\operatorname{lcm}(m_1,m_2)​$，那么我们根据模运算的性质可以得到一组新的同余方程： x\equiv km_1+r_1\pmod {\operatorname{lcm}(m_1,m_2)}我们用这样的方法把相邻的同余方程两两合并，每次消去一个方程，最终只会剩下一个同余方程，这个同余方程的余数 $r’$ 一定满足所有的同余方程。 时间复杂度：$O(n\log m_i)$ 代码12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;typedef long long LL;const int N=1e6+5;int n;LL r[N],m[N];LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y) &#123; if(!b) &#123;x=1,y=0;return a;&#125; LL d=exgcd(b,a%b,y,x); y-=a/b*x; return d;&#125;LL China(int n) &#123; LL M=m[1],R=r[1]; for(int i=2;i&lt;=n;++i) &#123; LL a=M,b=m[i],c=r[i]-R,x,y,d=exgcd(a,b,x,y); if(c%d) return -1; a/=d,b/=d,c/=d,x=(x*c%b+b)%b; R+=x*M,M*=m[i]/d,R=(R+M)%M; &#125; return R;&#125;int main(n) &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;++i) scanf("%lld%lld",&amp;m[i],&amp;r[i]); printf("%lld\n",exCRT()); return 0;&#125; 习题 「TJOI 2009」猜数字 「Luogu 4777」【模板】扩展中国剩余定理（EXCRT） 「Codeforces 338D」GCD Table 「SDOI 2010」古代猪文 「NOI 2018」屠龙勇士]]></content>
      <tags>
        <tag>算法笔记</tag>
        <tag>数论</tag>
        <tag>同余</tag>
        <tag>线性同余方程</tag>
        <tag>exGCD</tag>
        <tag>CRT</tag>
        <tag>exCRT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 338D」GCD Table]]></title>
    <url>%2Farticles%2Fproblem-Codeforces-338D-GCD-Table%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Codeforces 338D 有一张 $n\times m$ 的表格，第 $i$ 行第 $j$ 列的元素是 $\gcd(i,j)$。给定一个长度为 $k$ 的序列 $a_i$，询问是否存在 $x,y$，满足 $\forall i,1\le i\le k,\gcd(x,y+i-1)=a_i​$（即这个序列在表格的某一行出现过）。 数据范围：$1\le n,m\le 10^{12}$，$1\le k\le 10^4$，$1\le a_i\le 10^{12}$ Solution由于我们要保证 $\gcd(x,y)=a_i$，显然 $\operatorname{lcm}(a_1,a_2,\dots,a_k)\mid x$。 我们尝试证明：如果有解，那么 $x​$ 的值可以为 $\operatorname{lcm}(a_1,a_2,\dots,a_k)​$。 如果有解，且 $x=K\cdot\operatorname{lcm}(a_1,a_2,\dots,a_k)$，那么意味着 $\gcd(K,y)=0$，这样一来我们给 $y$ 平白无故地增加了限制。因此如果 $x=K\cdot\operatorname{lcm}(a_1,a_2,\dots,a_k)$ 时有解，那么在 $x=\operatorname{lcm}(a_1,a_2,\dots,a_k)$ 时一定也有解。 在确定了 $x$ 的值之后，还需要满足 $a_i\mid y+i-1$，即满足下列同余方程： \begin{cases} y=0\pmod{a_1} \\ y=-1\pmod{a_2} \\ \vdots \\ y=-k+1\pmod{a_k} \end{cases}这个方程显然可以通过扩展中国剩余定理来求解 $y$ 即可。 但是我们发现，求出 $y$ 之后的解 $(x,y)$ 不一定就是合法的，这是为什么呢？ 其实我们通过这样的思路，推导出解只满足必要性，而不满足充分性。因此我们还需要将 $(x,y)$ 代入 $\gcd(x,y+i-1)=a_i(1\le i\le k)$ 验证。 时间复杂度：$O(k\log a_i)​$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;typedef long long LL;const int N=1e4+5;int k;LL x,y,m[N],r[N];LL mul(LL x,LL p,LL mod) &#123; if(p&lt;0) x=-x,p=-p; LL ret=0; for(;p;p&gt;&gt;=1,x=(x+x)%mod) if(p&amp;1) ret=(ret+x)%mod; return ret;&#125;LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y) &#123; if(!b) &#123;x=1,y=0;return a;&#125; LL d=exgcd(b,a%b,y,x); y-=a/b*x; return d;&#125;LL gcd(LL x,LL y) &#123; return y?gcd(y,x%y):x;&#125;LL lcm(LL x,LL y) &#123; return x/gcd(x,y)*y;&#125;LL China(int n) &#123; LL M=m[1],R=r[1]; for(int i=2;i&lt;=n;++i) &#123; LL a=M,b=m[i],c=r[i]-R,x,y,d=exgcd(a,b,x,y); if(c%d) return -1; a/=d,b/=d,c/=d,x=(mul(x,c,b)+b)%b; R+=x*M,M*=m[i]/d,R=(R+M)%M; &#125; R=(R+M-1)%M+1; if(R&lt;1||R+k-1&gt;y) return -1; return R;&#125;int main() &#123; scanf("%lld%lld%d",&amp;x,&amp;y,&amp;k); LL xx=1; for(int i=1;i&lt;=k;++i) &#123; scanf("%lld",&amp;m[i]); if((xx=lcm(xx,m[i]))&gt;x) return puts("NO"),0; r[i]=((m[i]-i+1)%m[i]+m[i])%m[i]; &#125; LL yy=China(k); if(yy==-1) return puts("NO"),0; for(int i=1;i&lt;=k;++i) &#123; if(gcd(xx,yy+i-1)!=m[i]) return puts("NO"),0; &#125; return puts("YES"),0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>同余</tag>
        <tag>线性同余方程</tag>
        <tag>exGCD</tag>
        <tag>exCRT</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOI 2002」荒岛野人]]></title>
    <url>%2Farticles%2Fproblem-NOI-2002-Savage%2F</url>
    <content type="text"><![CDATA[Description 题目链接：BZOJ 1407 克里特岛以野人群居而著称。岛上有排列成环行的 $M$ 个山洞。这些山洞顺时针编号为 $1,2,\dots,M$。岛上住着 $n$ 个野人，一开始依次住在山洞 $C_1,C_2,\dots,C_n$ 中。以后每年，第 $i$ 个野人会沿顺时针向前走 $P_i$ 个洞住下来。每个野人i有一个寿命值 $L_i​$，即生存的年数。 奇怪的是，虽然野人有很多，但没有任何两个野人在有生之年处在同一个山洞中，使得小岛一直保持和平与宁静，这让科学家们很是惊奇。他们想知道，至少有多少个山洞，才能维持岛上的和平呢？数据保证有解，$M​$ 的值不大于 $10^6​$。 数据范围：$1\le n\le 15$，$1\le C_i,P_i\le 100$，$0\le L_i\le 10^6$ Solution我们形象化地描述题意： 求最小的 $M$ 使得对于任意的 $i,j$ 使得如下同余方程无解： C_i+xP_i\equiv C_j+xP_j\pmod M\quad (x>\min(L_i,L_j))我们发现题目中保证 $M\le 10^6​$，那么我们可以考虑枚举 $M​$ 并对这 $n^2​$ 个同余方程利用 $\text{exgcd}​$ 来求解并判断。 时间复杂度：$O(Mn^2\log C_i)$ Code12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int N=20;int n,s[N],p[N],l[N];int exgcd(int a,int b,int &amp;x,int &amp;y) &#123; if(!b) &#123;x=1,y=0;return a;&#125; int d=exgcd(b,a%b,y,x); y-=a/b*x; return d;&#125;bool check(int m) &#123; for(int i=1;i&lt;=n;++i) for(int j=i+1;j&lt;=n;++j) &#123; int a=p[i]-p[j],b=m,c=s[j]-s[i],x,y; int d=exgcd(a,b,x,y); if(c%d) continue; a/=d,b/=d,c/=d; if(b&lt;0) b=-b; x=(x*c%b+b)%b; if(x&lt;=l[i]&amp;&amp;x&lt;=l[j]) return 0; &#125; return 1;&#125;int main() &#123; scanf("%d",&amp;n); int mx=0; for(int i=1;i&lt;=n;++i) scanf("%d%d%d",&amp;s[i],&amp;p[i],&amp;l[i]),mx=std::max(mx,s[i]); for(int i=mx;;++i) if(check(i)) return printf("%d\n",i),0; return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>同余</tag>
        <tag>exGCD</tag>
        <tag>BZOJ</tag>
        <tag>贪心</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HDU 5391」Zball in Tina Town]]></title>
    <url>%2Farticles%2Fproblem-HDU-5391-Zball-in-Tina-Town%2F</url>
    <content type="text"><![CDATA[Description 题目链接：HDU 5391 一个球初始体积为 $1$，一天天变大，第一天变大 $1$ 倍，第二天变大 $2$ 倍，第 $n$ 天变大 $n$ 倍……问当第 $n−1$ 天的时候，体积变为多少。答案对 $n​$ 取模。 本题 $T$ 组数据。 数据范围：$1\le T\le 10^5$，$2\le n\le 10^9$ Solution显然题目让我们求的是： (n-1)!\bmod n看似无从下手，我们有这么一个神奇的定理：威尔逊定理。 (p-1)!\equiv -1\pmod p\quad (p\in\text{prime})考虑如何证明： 当 $p=2​$ 时式子显然成立。 当 $p&gt;2$ 时，由于每个数逆元的唯一性，当 $ab\equiv 1\pmod p$ 时，$a$ 和 $b$ 互为逆元。因此在 $[2,p-2]$ 中可以两两配对互为逆元。故 $(p-1)!\equiv -1\pmod p$。 很显然这个式子在 $n\not\in\text{prime}$ 时答案为 $0$。 当然这个定理有一个小坑点：当 $n=4$ 时答案为 $2$！ 时间复杂度：$O(T\sqrt n)$ Code12345678910111213141516#include &lt;cstdio&gt;bool check(int n) &#123; for(int i=2;i*i&lt;=n;++i) if(n%i==0) return 0; return 1;&#125;int main() &#123; int T; for(scanf("%d",&amp;T);T--;) &#123; int n; scanf("%d",&amp;n); if(!check(n)) puts("0"); else printf("%d\n",n-1); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>HDU</tag>
        <tag>威尔逊定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法笔记」类欧几里德算法]]></title>
    <url>%2Farticles%2Falgorithm-Similar-Euclidean-Algorithm%2F</url>
    <content type="text"><![CDATA[类欧几里德算法基于欧几里德算法，本质是通过取模缩小问题规模，递归求解。 1. $f(a,b,c,n)$定义 f(a,b,c,n)=\sum_{i=0}^n \left\lfloor\frac{ai+b}{c}\right\rfloor推导 当 $a\ge c​$ 或 $b\ge c​$ 时： \begin{align} f(a,b,c,n) & = \sum_{i=0}^n \left\lfloor\frac{ai+b}{c}\right\rfloor \\ & = \sum_{i=0}^n \left(i\left\lfloor\frac{a}{c}\right\rfloor+\left\lfloor\frac{b}{c}\right\rfloor\right)+\sum_{i=0}^n \left\lfloor\frac{a\bmod c\times i+b\bmod c}{c}\right\rfloor\tag 1 \\ & = \frac{n(n+1)}{2}\left\lfloor\frac{a}{c}\right\rfloor+(n+1)\left\lfloor\frac{b}{c}\right\rfloor + f(a\bmod c,b\bmod c,c,n)\tag 2 \end{align}式子 $(1)​$：我们把 $a​$ 拆成 $\left\lfloor\frac{a}{c}\right\rfloor\cdot c​$ 和 $a\bmod c​$ 两部分，$b​$ 同理。就可以将原式拆成两项了。 式子 $(2)$：第一项直接 $O(1)$ 计算，第二项递归计算。 当 $a&lt;c​$ 且 $b&lt;c​$ 时： 我们将 $\frac{ai+b}{c}​$ 看作是一条线段 $y=\frac{ax+b}{c}(x\in [0,n])​$，那么原式的本质就是求线段下方、$x​$ 轴上方有多少个整点（包括线段，不包括 $x​$ 轴）。 设 $m=\left\lfloor\frac{an+b}{c}\right\rfloor$，枚举所有点并判断是否在线段下方。 \begin{align} f(a,b,c,n) & = \sum_{i=0}^n \left\lfloor\frac{ai+b}{c}\right\rfloor \\ & = \sum_{i=0}^n \sum_{j=1}^m \left[j\le\frac{ai+b}{c}\right]\tag 1 \\ & = \sum_{i=0}^n \sum_{j=1}^m \left[ai> cj-b-1\right]\tag 2 \\ & = \sum_{j=1}^m \sum_{i=0}^n \left[i\ge \left\lfloor\frac{cj-b-1}{a}\right\rfloor+1\right]\tag 3 \\ & = \sum_{j=1}^m \left(n-\left\lfloor\frac{cj-b-1}{a}\right\rfloor\right)\tag 4 \\ & = nm-\sum_{j=0}^{m-1} \left\lfloor\frac{cj+c-b-1}{a}\right\rfloor\tag 5 \\ & = nm-f(c,c-b-1,a,m-1)\tag 6 \end{align}式子 $(1)​$：转化为线段下方的整点个数。 式子 $(2)​$：移项后再不等式右侧减去 $1​$ 使得 $\ge​$ 变为 $&gt;​$ 号。 式子 $(3)$：将 $&gt;$ 一个实数转化为 $\ge$ 一个整数。我们发现如果式子 $(2)$ 中不进行转化，那么就会出现 $i\ge \frac{cj-b}{a}$，这个式子是不能直接上取整的（比如 $\lceil3\rceil=4​$ 显然是一个反例）。 式子 $(4)​$：我们把 $\sum_{i=1}^n​$ 给去掉，直接变为一个整数。 式子 $(5)$：将 $\sum$ 给拆开，并改变求和下界和上界。 式子 $(6)$：直接将 $\sum$ 转化为 $f$ 函数，递归计算。 边界条件 $a=0$：答案为 $(n+1)\left\lfloor\frac{b}{c}\right\rfloor$。 伪代码123456int f(int a,int b,int c,int n) &#123; if(!a) return b/c*(n+1); if(a&gt;=c||b&gt;=c) return a/c*n*(n+1)/2+b/c*(n+1)+f(a%c,b%c,c,n); int m=(a*n+b)/c; return n*m-f(c,c-b-1,a,m-1);&#125; 2. $g(a,b,c,n)$定义 g(a,b,c,n)=\sum_{i=0}^n i\left\lfloor\frac{ai+b}{c}\right\rfloor推导 当 $a\ge c​$ 或 $b\ge c​$ 时： \begin{align} g(a,b,c,n) & =\sum_{i=0}^n i\left\lfloor\frac{ai+b}{c}\right\rfloor \\ & =\sum_{i=0}^n \left(i^2\left\lfloor\frac{a}{c}\right\rfloor+i\left\lfloor\frac{b}{c}\right\rfloor\right)+\sum_{i=0}^n i\left\lfloor\frac{a\bmod c\times i+b\bmod c}{c}\right\rfloor\tag 1 \\ & =\frac{n(n+1)(2n+1)}{6}\left\lfloor\frac{a}{c}\right\rfloor+\frac{n(n+1)}{2}\left\lfloor\frac{b}{c}\right\rfloor+g(a\bmod c,b\bmod c,c,n)\tag 2 \end{align}式子 $(1)$：我们还是仿照 $f$ 的过程拆成两项然后分别求和。 式子 $(2)$：根据平方和公式 $\sum_{i=1}^n i^2=\frac{n(n+1)(2n+1)}{6}$，我们可以 $O(1)$ 计算出第一项的值，第二项递归计算。 当 $a&lt;c​$ 且 $b&lt;c​$ 时： 总体思路还是和 $f​$ 函数一样，利用其几何意义来求解，设 $m=\left\lfloor\frac{an+b}{c}\right\rfloor​$。 \begin{align} g(a,b,c,n) & = \sum_{i=0}^n i\left\lfloor\frac{ai+b}{c}\right\rfloor \\ & = \sum_{i=0}^n i\times \sum_{j=1}^m \left[j\le\frac{ai+b}{c}\right]\tag 1 \\ & = \sum_{i=0}^n i\times \sum_{j=1}^m \left[ai> cj-b-1\right]\tag 2 \\ & = \sum_{j=1}^m \sum_{i=0}^n i\left[i\ge \left\lfloor\frac{cj-b-1}{a}\right\rfloor+1\right]\tag 3 \\ & = \sum_{j=1}^m \frac{1}{2}\left(n+\left\lfloor\frac{cj-b-1}{a}\right\rfloor+1\right)\left(n-\left\lfloor\frac{cj-b-1}{a}\right\rfloor\right)\tag 4 \\ & = \frac{mn(n+1)}{2}-\frac{1}{2}\sum_{j=0}^{m-1}\left\lfloor\frac{cj+c-b-1}{a}\right\rfloor-\frac{1}{2}\sum_{j=0}^{m-1}\left\lfloor\frac{cj+c-b-1}{a}\right\rfloor^2 \tag 5 \\ & = \frac{mn(n+1)}{2}-\frac{1}{2}f(c,c-b-1,a,m-1)-\frac{1}{2}h(c,c-b-1,a,m-1) \tag 6 \end{align}式子 $(1)$：转化为线段下方的整点个数。 式子 $(2)$：移项后再不等式右侧减去 $1$ 使得 $\ge$ 变为 $&gt;$ 号。 式子 $(3)$：依据还是和 $f$ 函数相同。 式子 $(4)​$：由于第二个 $\sum​$ 内就是对 $i\in \left[\left\lfloor\frac{cj-b-1}{a}\right\rfloor+1,n\right]​$ 求和，因此直接利用等差数列求和。 式子 $(5)$：将等差数列求和公式继续展开，转化为 $3​$ 项。 式子 $(6)​$：第一项可以 $O(1)​$ 计算，第二项和第三项发现是 $f​$ 和 $h​$ 函数，可以递归计算。 边界条件 $a=0​$：答案为 $\frac{n(n+1)}{2}\left\lfloor\frac{b}{c}\right\rfloor​$。 伪代码123456int g(int a,int b,int c,int n) &#123; if(!a) return b/c*n*(n+1)/2; if(a&gt;=c||b&gt;=c) return a/c*n*(n+1)*(2*n+1)/6+b/c*n*(n+1)/2+g(a%c,b%c,c,n); int m=(a*n+b)/c; return m*n*(n+1)/2-f(c,c-b-1,a,m-1)/2-h(c,c-b-1,a,m-1)/2;&#125; 3. $h(a,b,c,n)$定义 h(a,b,c,n)=\sum_{i=0}^n \left\lfloor\frac{ai+b}{c}\right\rfloor^2推导 当 $a\ge c​$ 或 $b\ge c​$ 时： \begin{align} h(a,b,c,n) & =\sum_{i=0}^n \left\lfloor\frac{ai+b}{c}\right\rfloor^2 \\ & = \sum_{i=0}^n \left(i\left\lfloor\frac{a}{c}\right\rfloor+\left\lfloor\frac{b}{c}\right\rfloor+\left\lfloor\frac{a\bmod c\times i+b\bmod c}{c}\right\rfloor\right)^2 \tag 1 \\ & = \sum_{i=0}^n \left(i^2\left\lfloor\frac{a}{c}\right\rfloor^2+\left\lfloor\frac{b}{c}\right\rfloor^2+\left\lfloor\frac{a\bmod c\times i+b\bmod c}{c}\right\rfloor^2+2i\left\lfloor\frac{a}{c}\right\rfloor\left\lfloor\frac{b}{c}\right\rfloor+2i\left\lfloor\frac{a}{c}\right\rfloor\left\lfloor\frac{a\bmod c\times i+b\bmod c}{c}\right\rfloor+2\left\lfloor\frac{b}{c}\right\rfloor\left\lfloor\frac{a\bmod c\times i+b\bmod c}{c}\right\rfloor\right) \tag 2 \\ & = \frac{n(n+1)(2n+1)}{6}\left\lfloor\frac{a}{c}\right\rfloor^2+(n+1)\left\lfloor\frac{b}{c}\right\rfloor^2+n(n+1)\left\lfloor\frac{a}{c}\right\rfloor\left\lfloor\frac{b}{c}\right\rfloor+h(a\bmod c,b\bmod c,c,n)+2\left\lfloor\frac{a}{c}\right\rfloor g(a\bmod c,b\bmod c,c,n)+2\left\lfloor\frac{b}{c}\right\rfloor f(a\bmod c,b\bmod c,c,n) \tag 3 \end{align}式子 $(1)$：把原式的 $a$ 和 $b$ 均拆成两个部分。 式子 $(2)​$：暴力展开平方项。 式子 $(3)$：将展开式中能 $O(1)$ 直接计算的提出，剩下的转化为 $f,g,h​$ 函数递归计算。 当 $a&lt;c$ 且 $b&lt;c$ 时： 我们试图把平方项用另一种形式表示出来：$n^2=2\sum_{i=1}^n i-n$。我们就根据这个公式进行转化（其中 $m$ 的值依旧是 $\left\lfloor\frac{an+b}{c}\right\rfloor​$。 \begin{align} h(a,b,c,n) & =\sum_{i=0}^n \left\lfloor\frac{ai+b}{c}\right\rfloor^2 \\ & = \sum_{i=0}^n \left(2\times\sum_{j=1}^{\left\lfloor\frac{ai+b}{c}\right\rfloor} j-\left\lfloor\frac{ai+b}{c}\right\rfloor\right) \tag 1 \\ & = 2\times \sum_{j=1}^m \sum_{i=0}^n j\times\left[j\le \frac{ai+b}{c}\right]-f(a,b,c,n) \tag 2 \\ & = 2\times \sum_{j=0}^{m-1} (j+1)\left(n-\left\lfloor\frac{cj+c-b-1}{a}\right\rfloor\right)-f(a,b,c,n)\tag 3 \\ & = 2\times\sum_{j=0}^{m-1} \left(n(j+1)-j\left\lfloor\frac{cj+c-b-1}{a}\right\rfloor-\left\lfloor\frac{cj+c-b-1}{a}\right\rfloor\right)-f(a,b,c,n) \tag 4 \\ & = nm(m+1)-2g(c,c-b-1,a,m-1)-2f(c,c-b-1,a,m-1)-f(a,b,c,n)\tag 5 \end{align}式子 $(1)$：我们按照上述公式将 $\left\lfloor\frac{ai+b}{c}\right\rfloor^2$ 进行变形。 式子 $(2)$：变换求和顺序，将 $j$ 的上界限定在 $\left\lfloor\frac{ai+b}{c}\right\rfloor$ 即 $\frac{ai+b}{c}$ 范围内。上述公式中多出来的一项转化为 $f​$ 函数。 式子 $(3)$：改变 $j$ 的上下界，并按照前文的方法（详见 $f$ 或 $g$ 函数的这部分内容）确定 $i$ 的范围。 式子 $(4)​$：将求和式展开。 式子 $(5)​$：将能够直接计算的提出，其余递归计算。 边界条件 $a=0$：答案为 $(n+1)\left\lfloor\frac{b}{c}\right\rfloor^2$。 伪代码123456int h(int a,int b,int c,int n) &#123; if(!a) return sqr(b/c)*(n+1); if(a&gt;=c||b&gt;=c) return sqr(a/c)*n*(n+1)*(2*n+1)/6+sqr(b/c)*(n+1)+(a/c)*(b/c)*n*(n+1)+h(a%c,b%c,c,n)+2*(a/c)*g(a%c,b%c,c,n)+2*(b/c)*f(a%c,b%c,c,n); int m=(a*n+b)/c; return n*m*(m+1)-f(a,b,c,n)-2*g(c,c-b-1,a,m-1)-2*f(c,c-b-1,a,m-1);&#125; 整体求解如果我们要对 $f,g,h$ 三个函数同时求解，显然是没法记忆化的。 注意到每个函数中都调用了 $(a\bmod c,b\bmod c,c,n)$ 和 $(c,c-b-1,a,m-1)$，那么我们考虑将 $3$ 个函数在同一个函数中同时求解。 时间复杂度：$O(\log n)$ 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;typedef long long LL;const int mod=998244353;const LL i2=499122177,i6=166374059;struct Ans &#123; LL f,g,h;&#125;;LL sqr(LL x) &#123; return x*x%mod;&#125;LL S2(LL n) &#123; return n*(n+1)%mod*i2%mod;&#125;LL S3(LL n) &#123; return n*(n+1)%mod*(n+n+1)%mod*i6%mod;&#125;Ans solve(LL a,LL b,LL c,LL n) &#123; Ans now; LL A=a/c,B=b/c; if(!a) &#123; now.f=(n+1)*B%mod; now.g=S2(n)*B%mod; now.h=(n+1)*sqr(B)%mod; return now; &#125; if(a&gt;=c||b&gt;=c) &#123; Ans nxt=solve(a%c,b%c,c,n); now.f=S2(n)*A%mod+(n+1)*B%mod+nxt.f; now.g=S3(n)*A%mod+S2(n)*B%mod+nxt.g; now.h=S3(n)*sqr(A)%mod+(n+1)*sqr(B)%mod+2*S2(n)*A%mod*B%mod+(B+B)*nxt.f%mod+(A+A)*nxt.g%mod+nxt.h; now.f%=mod,now.g%=mod,now.h%=mod; return now; &#125; LL m=(a*n+b)/c; Ans nxt=solve(c,c-b-1,a,m-1); now.f=n*m%mod-nxt.f; now.g=(m*n%mod*(n+1)%mod-nxt.f-nxt.h)*i2%mod; now.h=n*m%mod*(m+1)%mod-now.f-2*(nxt.f+nxt.g); now.f%=mod,now.g%=mod,now.h%=mod; return now;&#125;int main() &#123; int T; for(scanf("%d",&amp;T);T--;) &#123; LL a,b,c,n; scanf("%lld%lld%lld%lld",&amp;n,&amp;a,&amp;b,&amp;c); Ans ans=solve(a,b,c,n); ans.f=(ans.f%mod+mod)%mod; ans.g=(ans.g%mod+mod)%mod; ans.h=(ans.h%mod+mod)%mod; printf("%lld %lld %lld\n",ans.f,ans.g,ans.h); &#125; return 0;&#125; 习题 「Luogu 5170」【模板】类欧几里德算法 「Vijos 1504」强大的区间 「Luogu 5171」Earthquake 「TopCoder SRM 410」WifiPlanet 附：高次方和求法首先，我们有如下公式： \begin{aligned} &\sum_{i=1}^n i^1=\frac{n(n+1)}{2}\\ &\sum_{i=1}^n i^2=\frac{n(n+1)(2n+1)}{6}\\ &\sum_{i=1}^n i^3=\frac{n^2(n+1)^2}{4}\\ &\sum_{i=1}^n i^4=\cdots \end{aligned}接下来我们就分析一下这些公式是怎么得到的。 根据 \binom{n}{k}=\binom{n-1}{k-1}+\binom{n-1}{k}我们可以得到 \sum_{i=1}^n \binom{i}{k}=\binom{n+1}{k+1}具体证明只需要将右侧式子按照组合数的基本公式 $\binom{n}{k}=\binom{n-1}{k-1}+\binom{n-1}{k}​$ 暴力展开。 那么我们可以根据这个结论得到： \sum_{i=1}^n i^1 = \sum_{i=1}^n i=\sum_{i=1}^n \binom{i}{1}=\binom{n+1}{2}=\frac{n(n+1)}{2}对于平方求和，证明如下： \sum_{i=1}^n i^2 = \sum_{i=1}^n \left[i(i-1)+i\right]=2\sum_{i=1}^n \binom{i}{2}+\sum_{i=1}^n \binom{i}{1}=2\binom{n+1}{3}+\binom{n+1}{2}=\frac{n(n+1)(2n+1)}{6}再证明一下立方求和： \sum_{i=1}^n i^3=\sum_{i=1}^n \left[i(i-1)(i-2)+3i(i-1)+i\right]=6\sum_{i=1}^n\binom{i}{3}+6\sum_{i=1}^n\binom{i}{2}+\sum_{i=1}^n\binom{i}{1}=6\binom{n+1}{4}+6\binom{n+1}{3}+\binom{n+1}{2}=\frac{n^2(n+1)^2}{4}更高的次数也能按照以上规则写出求和式！ 如果用代码实现的话，时间复杂度最优可以达到 $O(k)$，其中 $k$ 为次数。]]></content>
      <tags>
        <tag>算法笔记</tag>
        <tag>数论</tag>
        <tag>类欧几里德算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法笔记」矩阵树定理]]></title>
    <url>%2Farticles%2Falgorithm-Matrix-Tree-Theorem%2F</url>
    <content type="text"><![CDATA[矩阵树定理用于计算无向图生成树个数，和基尔霍夫矩阵的行列式密切相关。 定义基尔霍夫矩阵在了解矩阵树定理前，我们先学习一下基尔霍夫矩阵的求法。 我们记基尔霍夫矩阵为 $K​$（$\text{Kirchhoff}​$ 的缩写），并直接计算出无向图 $G​$ 的度数矩阵 $D​$ 和邻接矩阵 $A​$，那么我们同通过 $K=D-A​$ 就可以计算出基尔霍夫矩阵。 主子式取出矩阵 $A$ 的 $k$ 行和 $k$ 列组成的新矩阵 $A’$ 叫做 $A$ 的 $k$ 阶主子式。 矩阵树定理用途矩阵树定理用于求解一个无向图的生成数个数，允许有重边和自环。 定理一个 $n​$ 个点的无向图的的生成树个数等于其基尔霍夫矩阵的任何一个 $n-1​$ 阶主子式的行列式。 证明由于笔者能力有限（太菜了不会证明），这里推荐一篇博客：生成树计数问题——矩阵树定理及其证明 - WerKeyTom_FTD 求解构造基尔霍夫矩阵，并求出其任何一个 $n-1$ 阶主子式的行列式即可。行列式的具体求法详见「算法笔记」行列式。 时间复杂度：$O(n^3\log n)$ 代码12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int N=305;const int mod=1e9+7;int n,m,a[N][N];int Gauss(int n) &#123; int ans=1; for(int i=1;i&lt;=n;++i) &#123; for(int k=i+1;k&lt;=n;++k) &#123; while(a[k][i]) &#123; int d=a[i][i]/a[k][i]; for(int j=i;j&lt;=n;++j) a[i][j]=(a[i][j]-1LL*d*a[k][j]%mod+mod)%mod; std::swap(a[i],a[k]),ans=-ans; &#125; &#125; ans=1LL*ans*a[i][i]%mod,ans=(ans+mod)%mod; &#125; return ans;&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); while(m--) &#123; int u,v; scanf("%d%d",&amp;u,&amp;v); --a[u][v],--a[v][u],++a[u][u],++a[v][v]; &#125; printf("%d\n",Gauss(n-1)); return 0;&#125; 习题 「HEOI 2015」小 Z 的房间 「JSOI 2008」最小生成树计数 「FJOI 2007」轮状病毒 「BZOJ 3659」Which Dreamed It]]></content>
      <tags>
        <tag>算法笔记</tag>
        <tag>数论</tag>
        <tag>行列式</tag>
        <tag>高斯消元</tag>
        <tag>生成树</tag>
        <tag>矩阵树定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu 2973」Dotp]]></title>
    <url>%2Farticles%2Fproblem-Luogu-2973-Dotp%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Luogu 2973 有一个 $n​$ 个点 $m​$ 条边的无向图，节点 $1​$ 有一个炸弹，在每个单位时间内，这个炸弹有 $\frac{P}{Q}​$ 的概率在这个节点炸掉，有 $1-\frac{P}{Q}​$ 的概率等概率选择一条与当前节点相连的边到其他的节点上。求炸弹在每个节点上爆炸的概率。 数据范围：$2\le n\le 300$，$1\le m\le 44850$，$1\le P,Q\le 10^6$ Solution很显然，如果我们设第 $i$ 个点的期望经过次数为 $f_i$，那么第 $i$ 个点的爆炸概率为 $f_i\times\frac{P}{Q}$。那么我们只需要求出这个 $f_i$ 即可。 对于 $f_i​$ 我们有如下关系式： f_u=\begin{cases} 1 & i=1 \\ \sum_{(u,v)\in E} (1-\frac{P}{Q})\times \frac{f_v}{deg_v} & \text{otherwise} \end{cases}其中 $deg_i​$ 表示第 $i​$ 个点的度数。这个式子的含义为：当到达 $u​$ 时，当且仅当在 $v​$ 的位置不爆炸并且有 $\frac{1}{deg_v}​$ 的概率从 $v​$ 走到 $u​$ 的位置。 我们直接高斯求和一波就好了。 时间复杂度：$O(n^3)$ Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;const int N=305;int n,m,p,q,e[N][N],deg[N];double a[N][N],b[N],x[N];void Gauss(int n) &#123; for(int i=1;i&lt;=n;++i) &#123; int p=i; for(int k=i+1;k&lt;=n;++k) if(fabs(a[k][i])&gt;fabs(a[p][i])) p=k; if(i!=p) std::swap(a[i],a[p]),std::swap(b[i],b[p]); for(int k=i+1;k&lt;=n;++k) &#123; double d=a[k][i]/a[i][i]; b[k]-=d*b[i]; for(int j=i;j&lt;=n;++j) a[k][j]-=d*a[i][j]; &#125; &#125; for(int i=n;i&gt;=1;--i) &#123; for(int j=i+1;j&lt;=n;++j) b[i]-=x[j]*a[i][j]; x[i]=b[i]/a[i][i]; &#125;&#125;int main() &#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;p,&amp;q); double P=1.0*p/q; while(m--) &#123; int u,v; scanf("%d%d",&amp;u,&amp;v); e[u][v]=e[v][u]=1,++deg[u],++deg[v]; &#125; for(int i=1;i&lt;=n;++i) &#123; a[i][i]=1.0; for(int j=1;j&lt;=n;++j) &#123; if(e[i][j]) a[i][j]-=(1.0-P)/deg[j]; &#125; &#125; b[1]=1.0; Gauss(n); for(int i=1;i&lt;=n;++i) printf("%.9lf\n",x[i]*P); return 0;&#125;]]></content>
      <tags>
        <tag>高斯消元</tag>
        <tag>动态规划</tag>
        <tag>Luogu</tag>
        <tag>概率期望</tag>
        <tag>带环 DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI 2008」GT 考试]]></title>
    <url>%2Farticles%2Fproblem-HNOI-2008-GT-Exam%2F</url>
    <content type="text"><![CDATA[Description 题目链接：BZOJ 1009 阿申准备报名参加 GT 考试，准考证号为 $n​$ 位数 $X_1,X_2,\dots,X_n​$，他不望准考证号上出现不吉利的数字。他的不吉利数学 $A_1,A_2,\dots,A_m​$ 有 $m​$ 位，不出现是指 $X_1,X_2,\dots,X_n​$ 中没有恰好一段等于 $A_1,A_2,\dots,A_m​$。注意 $A_1​$ 和 $X_1​$ 可以为 $0​$。 数据范围：$1\le n\le 10^9$，$1\le m\le 20$，$1\le k\le 1000$，$0\le X_i,A_i\le 9$ Solution我们定义 $\text{DP}$ 状态 $f_{i,j}$ 表示考虑到第 $i$ 个数，匹配到了 $X$ 中的第 $j$ 个字符时的方案数。显然 $i,j$ 的范围是 $0\le i\le n$，$0\le j&lt;m$。 转移方程为： f_{i,j}=\sum_{k=0}^{9} f_{i-1,p}其中的 $p$ 不一定是 $0$ 或者 $j-1$，因为加入字符 $k$ 后，有如下三种情况： 匹配到了 $X$ 中的下一个字符。 失配，无法匹配任何字符。 重新匹配到了 $X$ 的一个前缀。 这个式子看似无法优化了，我们换一种方式写出转移方程： f_{i,j}=\sum_{k=0}^{m-1} f_{i-1,k}\times g_{k,j}其中的 $g_{k,j}$ 表示一个匹配了长度为 $k$ 长度的串，有多少种加数字的方法，使得匹配长度变成 $j$。 由于我们知道原串，那么 $g_{i,j}$ 是固定的，我们可以预处理出这个数组。我们可以使用 $\text{KMP}$ 算法，求出 $\text{next}$ 数组后，枚举匹配长度 $k$ 和字符 $ch$，暴力计算能匹配到多长的前缀。 这样一来，我们得到了一个 $O(nm^2)$ 的算法。 再次观察这个 $\text{DP}$ 式子，可以轻松发现这个式子和矩阵乘法的式子非常相似，那么我们用矩阵快速幂优化 $\text{DP}$ 转移即可，求出 $g$ 矩阵的 $n$ 次幂。 时间复杂度：$O(m^3\log n)$ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;const int N=21;int n,m,mod,nxt[N];char s[N];void upd(int &amp;x,int y) &#123; (x+=y)&gt;=mod&amp;&amp;(x-=mod);&#125;struct Matrix &#123; int n,A[N][N]; Matrix(int _n=0) &#123;n=_n,memset(A,0,sizeof(A));&#125; void operator ~ () &#123; for(int i=0;i&lt;n;++i) A[i][i]=1; &#125; Matrix operator * (const Matrix &amp;b) const &#123; Matrix ret(n); for(int i=0;i&lt;n;++i) for(int j=0;j&lt;n;++j) for(int k=0;k&lt;n;++k) &#123; upd(ret.A[i][k],1LL*A[i][j]*b.A[j][k]%mod); &#125; return ret; &#125; Matrix operator ^ (const long long &amp;b) const &#123; Matrix ret(n),x=*this; ~ret; for(long long p=b;p;p&gt;&gt;=1,x=x*x) if(p&amp;1) ret=ret*x; return ret; &#125;&#125;;Matrix kmp() &#123; nxt[1]=0; for(int i=2,j=0;i&lt;=m;++i) &#123; while(j&amp;&amp;s[j+1]!=s[i]) j=nxt[j]; if(s[j+1]==s[i]) ++j; nxt[i]=j; &#125; Matrix a(m); for(int i=0;i&lt;m;++i) &#123; for(char ch='0';ch&lt;='9';++ch) &#123; int j=i; while(j&amp;&amp;s[j+1]!=ch) j=nxt[j]; if(s[j+1]==ch) ++j; ++a.A[i][j]; &#125; &#125; return a;&#125;int main() &#123; scanf("%d%d%d%s",&amp;n,&amp;m,&amp;mod,s+1); Matrix a=kmp(); a=a^n; int ans=0; for(int i=0;i&lt;m;++i) upd(ans,a.A[0][i]); printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>BZOJ</tag>
        <tag>HNOI</tag>
        <tag>线性递推</tag>
        <tag>矩阵快速幂</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法笔记」线性基]]></title>
    <url>%2Farticles%2Falgorithm-Linear-Base%2F</url>
    <content type="text"><![CDATA[线性基是一种特殊的基，它通常会在异或运算中出现。 定义对于自然数集 $S$，$S$ 的线性基被定义为最小的集合 $R$，使得 $S$ 的任何一个子集的 $S’$，都能找到一个 $R$ 中的子集 $R’$，$S’$ 中所有元素的异或和等于 $R’$ 中元素的异或和，且对于 $R$ 的所有子集 $R’$，也能找到对应的 $S’$。 形象地说，$R$ 内元素随意异或得到的集合等于 $S$ 内元素随意异或得到的集合。 性质 线性基能相互异或得到原集合的所有相互异或得到的值。 线性基是满足性质 $1​$ 的最小集合。 线性基内没有异或和为 $0$ 的子集（因为 $R$ 的空集的疑惑和为 $0$）。 线性组合我们从另一个角度来考虑问题，即 $x​$ 被表示为其他数的异或和代表什么。我们把 $x​$ 拆成一个向量 $x=\{a_0,a_1,\dots,a_{k-1}\}​$，$x=\sum{2^i\times a_i}​$，其中 $k​$ 是位数。 那么，$x​$ 能被表示成 $S​$ 的某个子集的异或和 转化为 $x​$ 能被表示成 $S​$ 中数所对应的向量在模 $2​$ 意义下的线性组合。这样一来，$R​$ 这个最的小能表示任何数的集合本质上就是 $S​$ 的最大线性无关集合。 注意：这里的最小和最大并不矛盾，最小意味着线性无关，最大意味着能表示任何一个数。 现在，我们把数的异或，转换成了向量的线性组合。 求解高斯消元时，如果某一行被前面的行消为 $0​$，那么代表它可以被表示成前面向量的线性组合，这也就是为什么： 方程组有解、系数矩阵行列式不为 $0$、系数矩阵满秩、系数矩阵的线性无关集合大小为 $n$ ——这四个命题等价。 对于新加入的数 $x$，如果它能被表示成 $R$，就代表它能被 $R$ 消成 $0​$。 我们把向量反过来写，把高位系数写在左边，低位系数写在右边，对所有数做高斯消元。最终矩阵会被消成一个上三角矩阵，剩下的不为 $0$ 的向量就是 $R$，而且每个向量（数）的最左边的非零数（最高位）都不相同。 因为矩阵行秩等于列秩，所以 $R$ 最多有 $k$（其中 $k$ 表示位数，一般为 $32$）个元素。 由于是在模 $2$ 的意义下，所以我们可以直接压位来做。记 $r_i$ 表示最高位为 $i$ 的线性基中的数。每次新加进来一个 $x$ 就从其最高位开始消去，如果某一位（假设为第 $i$ 位）无法消除了就把当前的 $x’$ 放进 $r_i$ 中，即 $x’$ 在线性基 $R$ 中。 代码12345678910111213141516171819202122#include &lt;cstdio&gt;const int N=1e6+5;int n;unsigned int a[N],r[32];void Gauss(int n) &#123; for(int i=1;i&lt;=n;++i) &#123; unsigned int x=a[i]; for(int k=31;~k;--k) if(x&amp;(1&lt;&lt;k)) &#123; if(r[k]) x^=r[k]; else &#123;r[k]=x;break;&#125; &#125; &#125;&#125;int main() &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;++i) scanf("%u",&amp;a[i]); Gauss(n); for(int i=0;i&lt;32;++i) if(r[i]) printf("%u\n",r[i]); return 0;&#125; 习题 「Luogu 3812」线性基 「TJOI 2008」彩灯 「BZOJ 2460」元素 「SCOI 2016」幸运数字 「JLOI 2015」装备购买 「CQOI 2013」新 Nim 游戏 「WC 2011」最大 XOR 和路径 「Codeforces 724G」Xor-matic Number of the Graph]]></content>
      <tags>
        <tag>算法笔记</tag>
        <tag>数论</tag>
        <tag>高斯消元</tag>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法笔记」行列式]]></title>
    <url>%2Farticles%2Falgorithm-Determinant%2F</url>
    <content type="text"><![CDATA[行列式的本质是线性变换的放大率。理解了这个物理意义，很多性质就迎刃而解了！ 定义我们定义一个矩阵 $A$ 的的行列式为 $\det(A)$，这个函数的结果是一个值。其本质是线性变换的放大率。 公式 \det(A)=\sum_{\forall P}[(-1)^{\tau(P)}\prod_{i=1}^n A_{i,P_i}]其中 $\tau(P)$ 表示 $n$ 的一个排列 $P​$ 的逆序对数量。 性质以下性质对于行和列同样适用！ 性质 1：交换某两行，行列式变号相当于每个全排列中，都有两个数被交换了位置。我们只需要证明交换两个数，逆序对变号即可。 设数字 $a​$ 和 $b​$ 将序列分为了三段： \{\text{第一段}\quad a\quad\text{第二段}\quad b\quad\text{第三段}\}改变顺序后第一段、第三段的逆序对数量不变。设第二段的长度为 $n​$，第二段中我们设： x_1\ \text{个元素}]]></content>
      <tags>
        <tag>算法笔记</tag>
        <tag>数论</tag>
        <tag>行列式</tag>
        <tag>高斯消元</tag>
        <tag>辗转相除法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法笔记」矩阵求逆]]></title>
    <url>%2Farticles%2Falgorithm-Matrix-Inversion%2F</url>
    <content type="text"><![CDATA[矩阵求逆和整数逆元比较类似，是通过高斯消元的思路实现的。 思路求 $n$ 阶矩阵 $A$ 的逆矩阵，也就是 $A^{-1}$，$\frac{1}{A}$，求出一个 $n$ 阶矩阵 $B$ 使得 $AB=E$（其中 $E​$ 表示单位矩阵）。 先回顾一下矩阵的三种初等行变换（具体内容详见 「算法笔记」矩阵入门）： 交换某两行。 将某一行的所有元素乘上 $k$（其中 $k\neq 0$）。 将某一行的所有元素乘上 $k$ 后加到另一行上去。 假设我们通过 $P_1,P_2,P_3,\dots,P_k$ 等初等矩阵分别左乘 $A$，即 $P_1P_2P_3\cdots P_kA=PA$，其中的 $P$ 为 $P_1$ 到 $P_k$ 的乘积。我们想让 $A$ 变为 $P$ 非常简单，只需要使用高斯消元先变成上三角矩阵，然后变成对角矩阵。 考虑如何求出这个 $P$，我们首先有 $PA=E$，$PE=P$，如果我们同时维护两个矩阵 $A$ 和 $B$ 并使得 $B$ 一开始等于 $E$，在对 $A$ 进行初等行变换变为 $E$ 的过程中也对 $B$ 进行相同的初等行变换。由于初等行变换等价于被对应的初等矩阵左乘，所以当 $A$ 变成 $P$ 后，$B$ 也就从 $E$ 变成了 $P$。 对于无解情况，如果在高斯消元的过程中发现 $A$ 无法变成 $E$ 就说明无解。 时间复杂度：$O(n^3)$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;const int N=305;const int mod=1e9+7;int n,m,a[N][N&lt;&lt;1];int pow(int x,int p) &#123; int ret=1; for(;p;p&gt;&gt;=1,x=1LL*x*x%mod) if(p&amp;1) ret=1LL*ret*x%mod; return ret;&#125;bool Gauss(int n,int m) &#123; for(int i=1;i&lt;=n;++i) &#123; int p=i; for(int k=i+1;k&lt;=n;++k) if(std::abs(a[k][i])&gt;std::abs(a[p][i])) p=k; if(i!=p) std::swap(a[i],a[p]); if(!a[i][i]) return 0; int d=pow(a[i][i],mod-2); for(int j=i;j&lt;=m;++j) a[i][j]=1LL*a[i][j]*d%mod; for(int k=1;k&lt;=n;++k) &#123; if(i==k) continue; int d=a[k][i]; for(int j=i;j&lt;=m;++j) a[k][j]=(a[k][j]-1LL*a[i][j]*d%mod+mod)%mod; &#125; &#125; return 1;&#125;int main() &#123; scanf("%d",&amp;n),m=n+n; for(int i=1;i&lt;=n;++i) &#123; for(int j=1;j&lt;=n;++j) scanf("%d",&amp;a[i][j]); a[i][n+i]=1; &#125; if(!Gauss(n,m)) return puts("No Solution"),0; for(int i=1;i&lt;=n;++i) &#123; for(int j=n+1;j&lt;=m;++j) printf("%d%c",a[i][j]," \n"[j==m]); &#125; return 0;&#125; 习题 「Luogu 4783」【模板】矩阵求逆 「BZOJ 4128」Matrix 「HEOI 2013」钙铁锌晒维生素]]></content>
      <tags>
        <tag>算法笔记</tag>
        <tag>数论</tag>
        <tag>高斯消元</tag>
        <tag>矩阵</tag>
        <tag>逆矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI 2011」数学作业]]></title>
    <url>%2Farticles%2Fproblem-HNOI-2011-Math-Homework%2F</url>
    <content type="text"><![CDATA[Description 题目链接：BZOJ 2326 小 C 数学成绩优异，于是老师给小 C 留了一道非常难的数学作业题： 给定正整数 $n$ 和 $m$，要求计算 $\text{Concatenate}(1\dots n)\bmod m$ 的值，其中 $\text{Concatenate}(1\dots n)$ 是将所有正整数 $1,2,\dots,n$ 顺序连接起来得到的数。小 C 想了大半天终于意识到这是一道不可能手算出来的题目，于是他只好向你求助，希望你能编写一个程序帮他解决这个问题。 数据范围：$1\le n\le 10^{18}$，$1\le m\le 10^9$ Solution我们设前 $i$ 个数的答案为 $f_i$，那么可以列出如下转移方程： f_i=f_{i-1}+10^{\left\lfloor\log_{10}i\right\rfloor+1}+i发现第 $i$ 项之和第 $i-1$ 项有关，可以考虑矩阵快速幂优化递推。 转移矩阵为： \begin{bmatrix} f_n \\ n \\ 1 \end{bmatrix}=\begin{bmatrix} 10^k & 1 & 1 \\ 0 & 1 & 1 \\ 0 & 0 & 1 \end{bmatrix}\times\begin{bmatrix} f_{n-1} \\ n-1 \\ 1 \end{bmatrix}但是我们发现，指数 $k$ 的值为 $\left\lfloor\log_{10}i\right\rfloor+1$（也就是 $len(i)$）的值是会变化的，没法直接矩乘。由于 $len(i)$ 的值一共只有 $18$ 种左右，所以我们直接枚举 $len(i)$ 然后分块矩乘后合并。 注意：合并时，必须用转移矩阵的若干次方左乘答案矩阵！ 时间复杂度：$O(3^3\log^2 n)$ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;const int N=4;int mod;void upd(int &amp;x,int y) &#123; (x+=y)&gt;=mod&amp;&amp;(x-=mod);&#125;struct Matrix &#123; int n,A[N][N]; Matrix(int _n=0) &#123;n=_n,memset(A,0,sizeof(A));&#125; void operator ~ () &#123; for(int i=0;i&lt;n;++i) A[i][i]=1; &#125; Matrix operator * (const Matrix &amp;b) const &#123; Matrix ret(n); for(int i=0;i&lt;n;++i) for(int j=0;j&lt;n;++j) for(int k=0;k&lt;n;++k) &#123; upd(ret.A[i][k],1LL*A[i][j]*b.A[j][k]%mod); &#125; return ret; &#125; Matrix operator ^ (const long long &amp;b) const &#123; Matrix ret(n),x=*this; ~ret; for(long long p=b;p;p&gt;&gt;=1,x=x*x) if(p&amp;1) ret=ret*x; return ret; &#125;&#125;;Matrix ans(3);void calc(long long p,long long b) &#123; Matrix x(3); x.A[0][0]=p%mod,x.A[0][1]=x.A[0][2]=x.A[1][1]=x.A[1][2]=x.A[2][2]=1; ans=(x^b)*ans;&#125;int main() &#123; long long n; scanf("%lld%d",&amp;n,&amp;mod); ~ans; long long r=10; while(r&lt;=n) calc(r,r-(r/10)),r*=10; calc(r,n-r/10+1); printf("%d\n",ans.A[0][2]); return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>动态规划</tag>
        <tag>BZOJ</tag>
        <tag>HNOI</tag>
        <tag>线性递推</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI 2013」游走]]></title>
    <url>%2Farticles%2Fproblem-HNOI-2013-Walk%2F</url>
    <content type="text"><![CDATA[Description 题目链接：BZOJ 3143 有一个无向简单连通图，顶点从 $1$ 编号到 $n$，边从 $1$ 编号到 $m$。 小 Z 在该图上进行随机游走，初始时小 Z 在 $1$ 号顶点，每一步小 Z 以相等的概率随机选择当前顶点的某条边，沿着这条边走到下一个顶点，获得等于这条边的编号的分数。当小 Z 到达 $n$ 号顶点时游走结束，总分为所有获得的分数之和的，答案保留 $3​$ 位小数。 现在，请你对这 $m$ 条边进行编号，使得小Z获得的总分的期望值最小。 数据范围：$2\le n\le 500$ Solution由于没有对 $m$ 的范围进行限定，那么 $m$ 的最大值可以达到 $O(n^2)$，这是无法接受的，因此我们考虑先统计点的期望次数。 我们设 $deg_i$ 表示第 $i$ 个点的度数，$f_i$ 表示第 $i​$ 个点期望经过次数： f_i=\begin{cases} f_1=\sum_{(i,j)\in E,j\neq n} \frac{f_j}{deg_j}+1 & i=1\\ f_i=\sum_{(i,j)\in E,j\neq n} \frac{f_j}{deg_j} & 1]]></content>
      <tags>
        <tag>高斯消元</tag>
        <tag>动态规划</tag>
        <tag>BZOJ</tag>
        <tag>概率期望</tag>
        <tag>HNOI</tag>
        <tag>带环 DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法笔记」矩阵入门]]></title>
    <url>%2Farticles%2Falgorithm-Matrix-Overview%2F</url>
    <content type="text"><![CDATA[矩阵是一个非常有用的工具，经常可以用于几何与代数之间的转化，以此来优化算法。 定义在数学中，矩阵是一个按照长方阵列排列的复数或实数集合。一个 $n\times m​$ 的矩阵一般这样表示： A_{nm}=\begin{bmatrix} a_{11} & a_{12} & a_{13} & \cdots & a_{1m} \\ a_{21} & a_{22} & a_{23} & \cdots & a_{2m} \\ a_{31} & a_{32} & a_{33} & \cdots & a_{3m} \\ \vdots & \vdots & \vdots & \ddots & \vdots \\ a_{n1} & a_{n2} & a_{n3} & \cdots & a_{nm} \\ \end{bmatrix}如果一个矩阵的行数和列数都等于 $n$，那么称这个矩阵为 $n​$ 阶矩阵。 运算加法减法同型矩阵之间可以进行加减法，运算法则为： C_{ij}=A_{ij}\pm B_{ij}乘法一个 $n\times m$ 的矩阵 $A$ 可以和一个 $m\times p$ 的矩阵 $B$ 进行乘法运算，得到一个 $n\times p$ 的矩阵 $C$，运算法则为： C_{ij}=\sum_{k=1}^m A_{ik}\times B_{kj} 特殊矩阵注意：以下矩阵中，没有明确标识的位置均表示 $0$！ 初等矩阵单位矩阵 P=\begin{bmatrix} 1 & & & \\ & 1 & & \\ & & 1 & \\ & & & 1 \\ \end{bmatrix}特征：除了主对角线上的元素为 $1$，其他元素均为 $0$。一般我们用字母 $E$ 来表示单位矩阵。 作用：$P$ 左乘 $A$ 矩阵，所得的结果还是 $A$ 矩阵本身。所以我们可以认为 $E$ 是矩阵乘法的单位元。 交换某两行 P=\begin{bmatrix} 1 & & & \\ & 0 & 1 & \\ & 1 & 0 & \\ & & & 1 \\ \end{bmatrix}特征：在单位矩阵的基础上，将第 $i$ 个 $1$ 向右移动一位，将第 $j$ 个 $1​$ 向左移动一位。 作用：$P$ 左乘 $A$ 矩阵，可以将 $A$ 的第 $i$ 行和第 $j​$ 行交换。 将一行的所有元素乘上 k P=\begin{bmatrix} 1 & & & \\ & 1 & & \\ & & k & \\ & & & 1 \\ \end{bmatrix}特征：在单位矩阵的基础上，将第 $i$ 个 $1$ 乘上 $k$。 作用：$P$ 左乘 $A$ 矩阵，可以将 $A$ 的第 $i$ 行的所有元素乘上 $k​$。 将一行的所有元素乘上 k 加到另一行去 P=\begin{bmatrix} 1 & & k & \\ & 1 & & \\ & & 1 & \\ & & & 1 \\ \end{bmatrix}特征：在单位矩阵的基础上，将第 $i$ 行第 $j$ 列的位置变为 $k​$（这个位置不在对角线上） 作用：$P$ 左乘 $A$ 矩阵，可以将 $A$ 矩阵的第 $j$ 行的所有元素乘上 $k$ 加到第 $i$ 行去。 上三角矩阵 P=\begin{bmatrix} 1 & 0 & 5 & 0 \\ & 4 & 7 & 0 \\ & & 9 & 7 \\ & & & 5 \\ \end{bmatrix}特征：除了主对角线及以上的元素（可以为 $0$ 也可以不为 $0$）外，其他元素均为 $0$。 作用：矩阵的秩、高斯消元、求行列式等中的重要矩阵！ 初等变换定义我们定义矩阵的三种初等行变换： 换行变换：交换某两行。 倍法变换：将某一行的所有元素乘上 $k$（其中 $k\neq 0$）。 消法变换：将某一行的所有元素乘上 $k$ 后加到另一行上去。 本质其实这三种初等行变换和上文的特殊矩阵是有联系的：初等行变换的本质是用初等矩阵左乘矩阵 $A$。那么很显然，初等列变换的本质是用初等矩阵右乘矩阵 $A$。 秩矩阵的秩分为行秩和列秩。一个矩阵 $A$ 的行秩是 $A$ 的线性无关独立的横行的极大数目；类似的，列秩是 $A$ 的线性无关独立的纵列的极大数目。 对于同一个矩阵而言，其行秩总是等于列秩的。 相抵如果矩阵 $A$ 可以通过一系列初等行变换和初等列变换变成矩阵 $B$，则称 $A$ 和 $B$ 是相抵的。 可逆对于一个矩阵 $A$，其可逆的充要条件是 $A$ 和 $E$ 是相抵的（即 $A$ 通过若干次初等行变换可以变成 $E$），也就是说存在一个矩阵 $P$ 使得 $PA=E$，则 $P=A^{-1}$。 有关矩阵求逆的相关过程详见：「算法笔记」矩阵求逆，其中有具体讲解如何方便地求一个矩阵的逆矩阵。 行列式行列式是一个函数，结果是一个值。矩阵 $A$ 的行列式写作 ​$\det(A)$ 或 $\vert A\vert​$。 一个矩阵的行列式求解公式为： \det(A)=\sum_{\forall P} [(-1)^{\tau(P)}\prod_{i=1}^n A_{i,P_i}]其中 $\tau(P)$ 表示排列 $P$ 的逆序对数量。 阶数较小的矩阵可以手动求解行列式，比如二阶矩阵的行列式为： \det(A)=A_{11}A_{22}-A_{12}A_{21}有关行列式的具体求解过程详见：「算法笔记」行列式，其中有具体讲解如何快速地求一个矩阵的行列式。 等价命题以下这些命题均是等价的，即是彼此的充要条件！ 矩阵满秩。 矩阵是可逆的。 矩阵的行列式不为 $0$。 板子为了方便大家使用，笔者把自己的矩阵板子放在博客里！（可能会更新） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;const int N=10;const int mod=1e9+7;void upd(int &amp;x,int y) &#123; (x+=y)&gt;=mod&amp;&amp;(x-=mod);&#125;struct Matrix &#123; int n,A[N][N]; Matrix(int _n=0) &#123;n=_n,memset(A,0,sizeof(A));&#125; void operator ~ () &#123; for(int i=0;i&lt;n;++i) A[i][i]=1; &#125; Matrix operator + (const Matrix &amp;b) const &#123; Matrix ret(n); for(int i=0;i&lt;n;++i) for(int j=0;j&lt;n;++j) ret.A[i][j]=(A[i][j]+b.A[i][j])%mod; return ret; &#125; Matrix operator - (const Matrix &amp;b) const &#123; Matrix ret(n); for(int i=0;i&lt;n;++i) for(int j=1;j&lt;n;++j) ret.A[i][j]=(A[i][j]-b.A[i][j]+mod)%mod; return ret; &#125; Matrix operator * (const Matrix &amp;b) const &#123; Matrix ret(n); for(int i=0;i&lt;n;++i) for(int j=0;j&lt;n;++j) for(int k=0;k&lt;n;++k) &#123; upd(ret.A[i][k],1LL*A[i][j]*b.A[j][k]%mod); &#125; return ret; &#125; Matrix operator ^ (const long long &amp;b) const &#123; Matrix ret(n),x=*this; ~ret; for(long long p=b;p;p&gt;&gt;=1,x=x*x) if(p&amp;1) ret=ret*x; return ret; &#125; void print() &#123; for(int i=0;i&lt;n;++i) for(int j=0;j&lt;n;++j) printf("%d%c",A[i][j]," \n"[j==n-1]); &#125;&#125;;int main() &#123; return 0;&#125;]]></content>
      <tags>
        <tag>算法笔记</tag>
        <tag>数论</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JSOI 2008」最小生成树计数]]></title>
    <url>%2Farticles%2Fproblem-JSOI-2008-MST-Count%2F</url>
    <content type="text"><![CDATA[Description 题目链接：BZOJ 1016 给出一个由 $n$ 个点和 $m$ 条边构成的简单无向加权图。你不满足于求出这个图的最小生成树，而希望知道这个图中有多少个不同的最小生成树。（两棵最小生成树是不同的当且仅当它们有至少有一条边不同）。方案数对 $31011$ 取模。 数据范围：$1\le n\le 100$，$1\le m\le 1000$ Solution简化版由于在 $\text{MST}$ 中，每种权值的边的数量是固定的，那么我们先统计出每种权值需要多少条边，记为 $c_i$。 我们发现具有相同权值的边的数量不超过 $10$ 条，那么我们暴力枚举第 $i$ 种权值的边选择哪 $c_i$ 条，然后根据乘法原理来统计答案。（这个算法已经可以通过本题） 注意：我们为了能够快速分开连通块，并查集中不能使用路径压缩！ 时间复杂度：$O(2^{10}m)​$ 加强版我们考虑加强版：每种权值的边不超过 $100$ 条。我们就需要矩阵树定理了。 注意到 $\text{MST}$ 有如下性质： 每种权值的边的数量是固定的。 不同的生成树中，某一种权值的边任意加入需要的数量后，形成的联通块状态是一样的。 这样一来，我们可以枚举树边的权值 $i$，把权值不是 $i$ 的树边都加入图中后进行缩点；对于权值为 $i$ 的原图中的边，在缩点后的图中构造基尔霍夫矩阵，用矩阵树定理求出方案数。 最终的答案也是根据乘法原理计算。 时间复杂度：$O(n^3\log n)$（大概是这样吧，这个算法我不怎么会算呀 QAQ） Code简化版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int N=105,M=1e3+5;const int mod=31011;int n,m,cnt,sum,l[M],r[M],c[M],fa[N];struct Edge &#123; int u,v,w; bool operator &lt; (const Edge &amp;b) const &#123; return w&lt;b.w; &#125;&#125;e[M];int find(int x) &#123; return fa[x]==x?x:find(fa[x]);&#125;void dfs(int now,int x,int num) &#123; if(now&gt;r[x]) &#123; sum+=(num==c[x]); return; &#125; int fu=find(e[now].u),fv=find(e[now].v); if(fu!=fv) &#123; fa[fu]=fv; dfs(now+1,x,num+1); fa[fu]=fu,fa[fv]=fv; &#125; dfs(now+1,x,num);&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;++i) scanf("%d%d%d",&amp;e[i].u,&amp;e[i].v,&amp;e[i].w); std::sort(e+1,e+m+1); for(int i=1;i&lt;=n;++i) fa[i]=i; int tot=0; for(int i=1;i&lt;=m;++i) &#123; if(e[i].w!=e[i-1].w) r[cnt]=i-1,l[++cnt]=i; int fu=find(e[i].u),fv=find(e[i].v); if(fu!=fv) ++c[cnt],fa[fu]=fv,++tot; &#125; r[cnt]=m; if(tot!=n-1) return puts("0"),0; for(int i=1;i&lt;=n;++i) fa[i]=i; int ans=1; for(int i=1;i&lt;=cnt;++i) &#123; sum=0,dfs(l[i],i,0),ans=ans*sum%mod; for(int j=l[i];j&lt;=r[i];++j) fa[find(e[j].u)]=find(e[j].v); &#125; printf("%d\n",ans); return 0;&#125; 加强版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;const int N=105,M=1e3+5;const int mod=31011;int n,m,tot,fa[N],a[N][N],bel[N],val[N];struct Edge &#123; int u,v,w; bool operator &lt; (const Edge &amp;b) const &#123; return w&lt;b.w; &#125;&#125;e[M],tr[N];int find(int x) &#123; return fa[x]==x?x:fa[x]=find(fa[x]);&#125;void init() &#123; for(int i=1;i&lt;=n;++i) fa[i]=i;&#125;void add(int u,int v) &#123; --a[u][v],--a[v][u],++a[u][u],++a[v][v];&#125;void merge(int x,int y) &#123; fa[find(x)]=find(y);&#125;int Gauss(int n) &#123; int ans=1; for(int i=1;i&lt;=n;++i) &#123; for(int k=i+1;k&lt;=n;++k) &#123; while(a[k][i]) &#123; int d=a[i][i]/a[k][i]; for(int j=i;j&lt;=n;++j) a[i][j]=(a[i][j]-1LL*d*a[k][j]%mod+mod)%mod; std::swap(a[i],a[k]),ans=-ans; &#125; &#125; ans=1LL*ans*a[i][i]%mod,ans=(ans+mod)%mod; &#125; return ans;&#125;bool kruskal() &#123; std::sort(e+1,e+m+1); init(); int cnt=0; for(int i=1;i&lt;=m;++i) &#123; int fu=find(e[i].u),fv=find(e[i].v); if(fu==fv) continue; fa[fu]=fv,tr[++cnt]=e[i]; if(e[i].w!=val[tot]) val[++tot]=e[i].w; &#125; return cnt==n-1;&#125;void addTreeEdge(int v) &#123; for(int i=1;i&lt;n&amp;&amp;tr[i].w!=v;++i) merge(tr[i].u,tr[i].v); for(int i=n-1;i&amp;&amp;tr[i].w!=v;--i) merge(tr[i].u,tr[i].v);&#125;int getblock() &#123; int blo=0; for(int i=1;i&lt;=n;++i) if(find(i)==i) bel[i]=++blo; for(int i=1;i&lt;=n;++i) bel[i]=bel[find(i)]; return blo;&#125;void rebuild(int v) &#123; memset(a,0,sizeof(a)); for(int i=1;i&lt;=m;++i) if(e[i].w==v) add(bel[e[i].u],bel[e[i].v]);&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;++i) scanf("%d%d%d",&amp;e[i].u,&amp;e[i].v,&amp;e[i].w); if(!kruskal()) return puts("0"),0; int ans=1; for(int i=1;i&lt;=tot;++i) &#123; init(); addTreeEdge(val[i]); int blo=getblock(); rebuild(val[i]); ans=1LL*ans*Gauss(blo-1)%mod; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>高斯消元</tag>
        <tag>矩阵树定理</tag>
        <tag>BZOJ</tag>
        <tag>DFS</tag>
        <tag>JSOI</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HDU 3976」Electric Resistance]]></title>
    <url>%2Farticles%2Fproblem-HDU-3976-Electric-Resistance%2F</url>
    <content type="text"><![CDATA[Description 题目链接：HDU 3976 给你一个有 $n$ 个节点的电路（标记为 $1$ 到 $n$），请你求出节点 $1$ 和节点 $n​$ 之间电路的等效电路。 电路在 $1$ 和 $n$ 之间的等效电阻为：如果只考虑节点 $1$ 为正极，节点 $n​$ 为负极，那么整个电路可以看作是一个电阻。保证任意两个节点之间的电阻最多只有一个。 本题 $T$ 组数据。 数据范围：$1\le T\le 100$，$1\le n\le 50$，$1\le m\le 2000$ Solution首先明确一下电流、电压、电阻、电势的关系： 电压 = 电势差 = 电流 × 电阻 设第 $i$ 个点的电势为 $U_i$，那么总的电压为 $U_n-U_1$，设流过整个电路的电流为 $1$，那么电阻的数值也就是 $U_n-U_1$。我们根据每个点的流入电流等于流出电流（基尔霍夫电流定律，简称 $\text{KCL}$），列出 $n$ 个方程。 假设每个点流入的电流为负，流出的电流为正。那么设节点 $1$ 的流入电流为 $-1$，节点 $n$ 的流出电流为 $1$，那么对于 $u$ 到 $v$ 的电阻 $w$，也就是对 $u$ 的电流有 $\frac{U_v-U_u}{w}$ 的贡献，显然对 $v$ 的电流有 $\frac{U_u-U_v}{w}$ 的贡献。 由于电势差是相对的，因此我们又设节点 $1$ 的电势为 $0$，那么高斯消元后可以求出等效电阻为 $U_n​$ 了。 这样 $n​$ 个方程中的最后一个是多余的，我们可以替换成 $U_1=0​$，这样一来方程组就正确了。 时间复杂度：$O(Tn^3)$ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;const int N=105,M=1e3+5;int n,m;double a[N][N],b[N],x[N];void Gauss(int n) &#123; for(int i=1;i&lt;=n;++i) &#123; int p=i; for(int k=i+1;k&lt;=n;++k) if(fabs(a[k][i])&gt;fabs(a[p][i])) p=k; if(i!=p) std::swap(a[i],a[p]),std::swap(b[i],b[p]); for(int k=i+1;k&lt;=n;++k) &#123; double d=a[k][i]/a[i][i]; b[k]-=d*b[i]; for(int j=i;j&lt;=n;++j) a[k][j]-=d*a[i][j]; &#125; &#125; for(int i=n;i&gt;=1;--i) &#123; for(int j=i+1;j&lt;=n;++j) b[i]-=x[j]*a[i][j]; x[i]=b[i]/a[i][i]; &#125;&#125;int main() &#123; int T,cs=0; for(scanf("%d",&amp;T);T--;) &#123; scanf("%d%d",&amp;n,&amp;m); memset(a,0,sizeof(a)),memset(b,0,sizeof(b)); while(m--) &#123; int u,v,w; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); a[u][u]-=1.0/w,a[u][v]+=1.0/w; a[v][v]-=1.0/w,a[v][u]+=1.0/w; &#125; memset(a[n],0,sizeof(a[n])); a[n][1]=1; b[1]=1,b[n]=0; Gauss(n); printf("Case #%d: %.2lf\n",++cs,x[n]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>高斯消元</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HEOI 2015」小 Z 的房间]]></title>
    <url>%2Farticles%2Fproblem-HEOI-2015-Little-Z-Room%2F</url>
    <content type="text"><![CDATA[Description 题目链接：BZOJ 4031 你突然有了一个大房子，房子里面有一些房间。事实上，你的房子可以看做是一个包含 $n\times m$ 个格子的格状矩形，每个格子是一个房间或者是一个柱子。在一开始的时候，相邻的格子之间都有墙隔着。 你想要打通一些相邻房间的墙，使得所有房间能够互相到达。在此过程中，你不能把房子给打穿，或者打通柱子（以及柱子旁边的墙）。同时，你不希望在房子中有小偷的时候会很难抓，所以你希望任意两个房间之间都只有一条通路。现在，你希望统计一共有多少种可行的方案。答案对 $10^9$ 取模。 数据范围：$1\le n,m\le 9$ Solution矩阵树定理裸题，注意不能把柱子的点放入矩阵中。加边时，我们只枚举 $(i,j)​$ 上方和左方的点，这样可以保证每条边只被枚举到一次。 时间复杂度：$O(n^3m^3)$ Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int N=15,M=105;const int mod=1e9;char s[N][N];int n,m,a[M][M],id[N][N];void add(int u,int v) &#123; --a[u][v],--a[v][u],++a[u][u],++a[v][v];&#125;int Gauss(int n) &#123; int ans=1; for(int i=1;i&lt;=n;++i) &#123; for(int k=i+1;k&lt;=n;++k) &#123; while(a[k][i]) &#123; int d=a[i][i]/a[k][i]; for(int j=i;j&lt;=n;++j) a[i][j]=(a[i][j]-1LL*d*a[k][j]%mod+mod)%mod; std::swap(a[i],a[k]),ans=-ans; &#125; &#125; ans=1LL*ans*a[i][i]%mod,ans=(ans+mod)%mod; &#125; return ans;&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) scanf("%s",s[i]+1); int idx=0; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) if(s[i][j]=='.') id[i][j]=++idx; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) if(s[i][j]=='.') &#123; if(id[i-1][j]) add(id[i][j],id[i-1][j]); if(id[i][j-1]) add(id[i][j],id[i][j-1]); &#125; printf("%d\n",Gauss(idx-1)); return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>高斯消元</tag>
        <tag>生成树</tag>
        <tag>矩阵树定理</tag>
        <tag>BZOJ</tag>
        <tag>HEOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JSOI 2008」球形空间产生器]]></title>
    <url>%2Farticles%2Fproblem-JSOI-2008-Sphere-Space-Generator%2F</url>
    <content type="text"><![CDATA[Description 题目链接：BZOJ 1013 有一个球形空间产生器能够在 $n$ 维空间中产生一个坚硬的球体。现在，你被困在了这个 $n$ 维球体中，你只知道球面上 $n+1$ 个点的坐标 $(x_{i,1},x_{i,2},\dots,x_{i,n})$，你需要以最快的速度确定这个 $n$ 维球体的球心坐标，以便于摧毁这个球形空间产生器。答案保留 $3$ 位小数。 数据范围：$1\le n\le 10$，$\vert x_{i,j}\vert\le 20000$ Solution得到 $n+1$ 个等式： \begin{cases} (x_1-p_{1,1})^2+(x_2-p_{1,2})^2+(x_3-p_{1,3})^2+\cdots+(x_n-p_{1,n})^2=R^2 \\ (x_1-p_{2,1})^2+(x_2-p_{2,2})^2+(x_3-p_{2,3})^2+\cdots+(x_n-p_{2,n})^2=R^2 \\ \vdots \\ (x_1-p_{n,1})^2+(x_2-p_{n,2})^2+(x_3-p_{n,3})^2+\cdots+(x_n-p_{n,n})^2=R^2 \\ (x_1-p_{n+1,1})^2+(x_2-p_{n+1,2})^2+(x_3-p_{n+1,3})^2+\cdots+(x_n-p_{n+1,n})^2=R^2 \end{cases}然后用第 $n+1$ 个等式去消去前 $n$ 个等式的 ${x_i}^2$ 项，这样就得到了一个标准的 $n$ 元 $1$ 次方程组，直接高斯消元求出 $n​$ 个未知数。 时间复杂度：$O(n^3)$ Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;const int N=15;int n;double p[N][N],a[N][N],b[N],x[N];void Gauss(int n) &#123; for(int i=1;i&lt;=n;++i) &#123; int p=i; for(int k=i+1;k&lt;=n;++k) if(fabs(a[k][i])&gt;fabs(a[p][i])) p=k; if(i!=p) std::swap(a[i],a[p]),std::swap(b[i],b[p]); for(int k=i+1;k&lt;=n;++k) &#123; double d=a[k][i]/a[i][i]; b[k]-=d*b[i]; for(int j=i;j&lt;=n;++j) a[k][j]-=d*a[i][j]; &#125; &#125; for(int i=n;i&gt;=1;--i) &#123; for(int j=i+1;j&lt;=n;++j) b[i]-=x[j]*a[i][j]; x[i]=b[i]/a[i][i]; &#125;&#125;void init() &#123; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j) &#123; a[i][j]=2.0*(p[n+1][j]-p[i][j]),b[i]+=p[n+1][j]*p[n+1][j]-p[i][j]*p[i][j]; &#125;&#125;int main() &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n+1;++i) for(int j=1;j&lt;=n;++j) scanf("%lf",&amp;p[i][j]); init(); Gauss(n); for(int i=1;i&lt;=n;++i) printf("%.3lf%c",x[i]," \n"[i==n]); return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>高斯消元</tag>
        <tag>BZOJ</tag>
        <tag>JSOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu 2187」小 Z 的笔记]]></title>
    <url>%2Farticles%2Fproblem-Luogu-2187-Little-Z-Notes%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Luogu 2187 小 Z 的有一个长度为 $n$ 的笔记，他规定有 $m​$ 个字母对不能相邻，并且是与字母顺序无关的。现在给出这个笔记，请求出最少需要擦掉多少个字母，使得整个笔记合法。 数据范围：$1\le n\le 10^5$，$1\le m\le 400​$ Solution我们可以很容易地写出朴素的 $\text{DP}​$ 转移方程： f_i=\min\{f_j+i-j-1\}\quad(0\le j]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「APIO 2014」Split the Sequence]]></title>
    <url>%2Farticles%2Fproblem-APIO-2014-Split-the-Sequence%2F</url>
    <content type="text"><![CDATA[Description 题目链接：UOJ 104 你正在玩一个关于长度为 $n$ 的非负整数序列 $a_i$ 的游戏。这个游戏中你需要把序列分成 $k+1$ 个非空的块。为了得到 $k+1$ 块，你需要重复下面的操作 $k$ 次： 选择一个有超过一个元素的块（初始时你只有一块，即整个序列） 选择两个相邻元素把这个块从中间分开，得到两个非空的块。 每次操作后你将获得那两个新产生的块的元素和的乘积的分数。你想要最大化最后的总得分。 数据范围：$2\le n\le 10^5$，$1\le k\le \min(n-1,200)$，$0\le a_i\le 10^4$ Solution我们首先证明答案和分割顺序无关。 如果我们有长度为 $3$ 的序列 $x,y,z$ 将其分为 $3$ 部分，有如下两种分割方法： 先在 $x$ 后面分割，答案为 $x(y+z)+yz$ 即为 $xy+yz+zx$。 先在 $y$ 后面分割，答案为 $(x+y)z+xy$ 即为 $xy+yz+zx$。 然后这个结论可以扩展到任意长度的序列（分析一下贡献），证明完毕 QAQ 那么我们定义 $F_{i,j}$ 表示前 $i$ 个数进行 $j$ 次切割的最大得分。我们记 $a_i$ 的前缀和为 $s_i$，那么转移方程为： F_{i,k}=\max\{F_{j,k-1}+s_j(s_i-s_j)\}\quad (0\le j]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>斜率优化</tag>
        <tag>APIO</tag>
        <tag>UOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu 2906」Cow Neighborhoods]]></title>
    <url>%2Farticles%2Fproblem-Luogu-2906-Cow-Neighborhoods%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Luogu 2906 了解奶牛们的人都知道，奶牛喜欢成群结队。观察约翰的 $n$ 只奶牛，你会发现她们已经结成了几个“群”。每只奶牛在吃草的时候有一个独一无二的位置坐标 $(X_i,Y_i)$。当满足下列两个条件之一，两只奶牛 $i$ 和 $j$ 是属于同一个群的： 两只奶牛的曼哈顿距离不超过 $C$，即 $|X_i-X_j|+|Y_i-Y_j|\le C$。 两只奶牛有共同的邻居。即存在一只奶牛 $k$，使 $i$ 与 $k$、$j$ 与 $k$ 均同属一个群。 请计算有多少个牛群，以及最大的牛群里有多少奶牛。 数据范围：$1\le n\le 10^5$，$1\le X_i,Y_i,C\le 10^9$，$X_i,Y_i,C\in \mathbb{Z}$ Solution首先我们有一个转化：曼哈顿距离转切比雪夫距离。将一个点的坐标 $(x,y)$ 转化成 $(x+y,x-y)$，设新点的坐标为 $(x’,y’)$，那么原来的曼哈顿距离 $\vert x_1-x_2\vert +\vert y_1-y_2\vert$ 就等于现在的切比雪夫距离 $\max(\vert x’_1-x’_2\vert,\vert y’_1-y’_2\vert)$。可以通过分类讨论或几何法简单证明成立。 设第 $i$ 个点的新坐标为 $(X_i+Y_i,X_i-Y_i)$，记为 $(x_i,y_i)$。那么第 $1$ 个限制会变为： 两只奶牛的切比雪夫距离不超过 $C$，即 $\max(\vert x_1-x_2\vert,\vert y_1-y_2\vert)\le C$。 由于有 $\max$，我们可以将 $(x_i,y_i)$ 以 $x_i$ 为第一个关键字，$y_i$ 为第二关键字，从小到大排序。对于同一群的奶牛我们用并查集合并。 我们用 $\text{set}$ 维护 $y_i$（每个点）的值，我们每次在插入第 $i$ 个点时，先把 $\text{set}$ 中所有满足 $\vert x_i-x_j\vert&gt;C$ 的点都删除，然后用 $\text{lower_bound}$ 找到第一个大于等于 $y_i$ 的点，如果满足约束条件就将这两个点合并起来。再找到最后一个小于 $y_i$ 的点，进行相同合并操作。 最后我们证明其他的点不需要和 $i$ 合并。 对于大于等于 $y_j$ 的点 $k$ 满足约束条件 $y_k-y_i\le C$，那么 $y_k-y_j\le y_k-y_i\le C$，那么在处理 $j$ 或 $k$ 时一定会把 $k$ 合并进来（这取决于 $x_j$ 和 $x_k$ 的大小），所以不必合并了。对于小于的部分证明同理。 时间复杂度：$O(n\cdot\alpha(n)\log n)$ Code1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;set&gt;typedef std::pair&lt;long long,int&gt; pli;typedef std::pair&lt;long long,long long&gt; pll;#define mk std::make_pairconst int N=1e5+5;int n,C,fa[N],cnt[N];pll a[N];std::set&lt;pli&gt; s;int find(int x) &#123; return fa[x]==x?x:fa[x]=find(fa[x]);&#125;void merge(int x,int y) &#123; fa[find(x)]=find(y);&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;C); for(int i=1;i&lt;=n;++i) &#123; int X,Y; scanf("%d%d",&amp;X,&amp;Y); a[i]=mk(X+Y,X-Y),fa[i]=i; &#125; std::sort(a+1,a+n+1); s.insert(mk(-1LL&lt;&lt;60,0)),s.insert(mk(1LL&lt;&lt;60,0)); s.insert(mk(a[1].second,1)); for(int l=1,i=2;i&lt;=n;++i) &#123; while(a[i].first-a[l].first&gt;C) s.erase(mk(a[l].second,l)),++l; std::set&lt;pli&gt;::iterator it=s.lower_bound(mk(a[i].second,0)); if(it-&gt;first-a[i].second&lt;=C) merge(i,it-&gt;second); --it; if(a[i].second-it-&gt;first&lt;=C) merge(i,it-&gt;second); s.insert(mk(a[i].second,i)); &#125; int ans=0,mx=0; for(int i=1;i&lt;=n;++i) ans+=(find(i)==i),mx=std::max(mx,++cnt[find(i)]); printf("%d %d\n",ans,mx); return 0;&#125;]]></content>
      <tags>
        <tag>Luogu</tag>
        <tag>曼哈顿距离</tag>
        <tag>切比雪夫距离</tag>
        <tag>set</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SCOI 2005」王室联邦]]></title>
    <url>%2Farticles%2Fproblem-SCOI-2005-Royal-Commonwealth%2F</url>
    <content type="text"><![CDATA[Description 题目链接：BZOJ 1086 “余”人国的国王想重新编制他的国家。他想把他的国家划分成若干个省，每个省都由他们王室联邦的一个成员来管理。他的国家有 $n$ 个城市，编号为 $1\dots n$。一些城市之间有道路相连，任意两个不同的城市之间有且仅有一条直接或间接的道路。 为了防止管理太过分散，每个省至少要有 $B$ 个城市，为了能有效的管理，每个省最多只有 $3B​$ 个城市。 每个省必须有一个省会，这个省会可以位于省内，也可以在该省外。但是该省的任意一个城市到达省会所经过的道路上的城市（除了最后一个城市，即该省省会）都必须属于该省。 一个城市可以作为多个省的省会。 数据范围：$1\le n\le 3000​$ Solution我们可以考虑这样一个构造方法： 我们 $\text{DFS}$ 整棵树，处理每个节点时，将其一部分子节点分块，将未被分块的子节点返回到上一层。 枚举 $u$ 的每个子节点 $v$，递归处理子树后，将每个子节点返回的未被分块的节点添加到集合 $S$ 中，一旦 $\vert S\vert\ge B$ 就把 $S$ 作为一个新的块并将 $u$ 作为省会，然后清空 $S$ 并继续枚举 $v$。 处理完所有子树后，将 $u$ 也加入到集合 $S$ 中，此时在 $S$ 中的节点为未被分块的节点，将被返回到上一层，显然 $S$ 的大小最大为 $B-1$ 个子树节点 + $u$ 节点本身，即 $\vert S\vert\le B$。 由于返回的集合的大小最大为 $B$，对于一个子树会对集合最多增加 $B-1$ 个节点，那么每个块的大小最大为 $2B-1$，满足条件。 在 $\text{DFS}$ 结束后，集合 $S$ 中可能还有节点（最多有 $B$ 个），那么我们把这 $B$ 个节点并入最后一个块（以根节点为省会的最后一个块）中，那么这个块的大小最大为 $3B-1$，符合条件。 时间复杂度：$O(n)​$ Code123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;const int N=1e3+5,M=2e3+5;int n,B,sz,cnt,tot,lnk[N],ter[M],nxt[M],st[N],rt[N],bel[N];void add(int u,int v) &#123; ter[++tot]=v,nxt[tot]=lnk[u],lnk[u]=tot;&#125;void dfs(int u,int p) &#123; int cnr=sz; for(int i=lnk[u];i;i=nxt[i]) &#123; int v=ter[i]; if(v==p) continue; dfs(v,u); if(sz-cnr&gt;=B) &#123; rt[++cnt]=u; while(sz&gt;cnr) bel[st[sz--]]=cnt; &#125; &#125; st[++sz]=u;&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;B); for(int i=1;i&lt;n;++i) &#123; int u,v; scanf("%d%d",&amp;u,&amp;v); add(u,v),add(v,u); &#125; dfs(1,0); if(!cnt) rt[++cnt]=1; while(sz) bel[st[sz--]]=cnt; printf("%d\n",cnt); for(int i=1;i&lt;=n;++i) printf("%d%c",bel[i]," \n"[i==n]); for(int i=1;i&lt;=cnt;++i) printf("%d%c",rt[i]," \n"[i==cnt]); return 0;&#125;]]></content>
      <tags>
        <tag>分块</tag>
        <tag>BZOJ</tag>
        <tag>构造</tag>
        <tag>SCOI</tag>
        <tag>树分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu 2900」Land Acquisition]]></title>
    <url>%2Farticles%2Fproblem-Luogu-2900-Land-Acquisition%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Luogu 2900 约翰准备扩大他的农场，眼前他正在考虑购买 $n$ 块长方形的土地，每块土地宽为 $w_i$、长为 $l_i$。如果约翰单买一块土地，价格就是土地的面积 $w_i\times l_i$。但他可以选择并购一组土地，并购的价格为这些土地中最大的长乘以最大的宽，即 $\max\{w_i\}\times \max\{l_i\}$。比如约翰并购一块 $3\times 5$ 和一块 $5\times 3$ 的土地，他只需要支付 $5\times 5=25​$ 元， 比单买合算。约翰希望买下所有的土地。他发现，将这些土地分成不同的小组来并购可以节省经费。给定每份土地的尺寸，请你帮助他计算购买所有土地所需的最小费用。 数据范围：$1\le n\le 5\times 10^4$，$1\le w_i,l_i\le 10^6$ Solution我们首先可以发现一个性质：如果对于土地 $i,j$ 满足 $w_i\ge w_j$ 且 $l_i\ge l_j$，那么土地 $j$ 显然是无用的。那么最终有用的土地，如果在宽递减的前提下，一定是长递增的。这个过程可以通过排序简单预处理。 假设我们已经得到 $n$ 块土地满足 $w_i\le w_{i-1},l_i\ge l_{i-1}$，我们可以证明每一组土地一定是连续的一段。这个证明基本是显然的，因为我们可以将一块土地并入前后的组别，使得这块土地不需要额外花费。 由此，我们可以简单推出 $\text{DP}​$ 方程：$f_i=\min\{f_j+w_{j+1}\times l_i\}\quad (0\le j&lt;i)​$，但是这个转移是 $O(n^2)​$ 的，不能通过本题。 其实这个东西是有决策单调性的，我们考虑斜率优化。 我们任取 $j,k$ 满足 $0\le k&lt;j&lt;i$，如果此时 $j$ 比 $k$ 要更好，那么有如下不等式： \begin{aligned} f_j+w_{j+1}\times l_i&\le f_k+w_{k+1}\times l_i \\ f_j-f_k&\le l_i\times (w_{k+1}-w_{j+1}) \end{aligned}由于宽是递减的，那么 $w_{k+1}\ge w_{j+1}$，可以直接移项得到： l_i\ge \frac{f_j-f_k}{w_{k+1}-w_{j+1}}显然我们只要维护一个下凸壳就可以斜率优化啦！ 时间复杂度：$O(n\log n)$（瓶颈竟然在排序上 QAQ） Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int N=5e4+5;int n,q[N];long long f[N];struct Land &#123; int x,y; bool operator &lt; (const Land &amp;b) const &#123; return x==b.x?y&gt;b.y:x&gt;b.x; &#125;&#125; a[N];void init() &#123; std::sort(a+1,a+n+1); int m=0; for(int i=1;i&lt;=n;++i) if(a[i].y&gt;a[m].y) a[++m]=a[i]; n=m;&#125;double slope(int i,int j) &#123; return 1.0*(f[i]-f[j])/(a[j+1].x-a[i+1].x);&#125;int main() &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;++i) scanf("%d%d",&amp;a[i].x,&amp;a[i].y); init(); int l=1,r=0; q[++r]=0; for(int i=1;i&lt;=n;++i) &#123; while(l&lt;r&amp;&amp;slope(q[l],q[l+1])&lt;=a[i].y) ++l; f[i]=f[q[l]]+1LL*a[q[l]+1].x*a[i].y; while(l&lt;r&amp;&amp;slope(q[r-1],q[r])&gt;=slope(q[r],i)) --r; q[++r]=i; &#125; printf("%lld\n",f[n]); return 0;&#125;]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>斜率优化</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法笔记」分块算法]]></title>
    <url>%2Farticles%2Falgorithm-Partition%2F</url>
    <content type="text"><![CDATA[分块算法，和莫队有着异曲同工之妙，是一种优雅的暴力。 概述分块算法，顾名思义是把一个长度为 $n$ 的序列分成 $m$ 块，每块的大小均为 $\frac{n}{m}$。我们维护块内信息，使得块内信息的查询是 $O(1)$ 的，而总的询问又可以看做是若干个块的询问的总和。 为了方便描述，我们定义： 完整块：区间操作时，完整包含于区间的块。 不完整的块：区间操作时，只有部分包含于区间的块，即左右端点所在的两个块。 零散元素：不完整的块内的元素。 我们发现，对于一个询问 $[l,r]$，我们可以进行如下处理： 拆成若干个完整块，其中每个完整快内的信息可以 $O(1)$ 更新。其中完整块的数量为 $O(\frac{n}{m})$。 剩下两个不完整的块，对于这两个块内的信息暴力更新。其中不完整的块的大小为 $O(m)$。 综上所述，分块算法单次操作的时间复杂度为 $O(\frac{n}{m}+m)$。根据均值不等式，我们可以发现 $m=\sqrt n$ 时复杂度最优。 如何分块我们定义如下变量： $len$ $num$ $bl[i]$ $l[i]$ $r[i]$ 块的大小 块的数量 第 $i$ 个元素所属的块 第 $i$ 个块的左端点 第 $i$ 个块的右端点 那么我们可以用如下代码建立分块： 其中特别需要注意 r[num]=n 意味着第 $num$ 个块（最后一个块）的右端点一定是 $n$！ 123456void build() &#123; len=sqrt(n),num=(n-1)/len+1; for(int i=1;i&lt;=n;++i) bl[i]=(i-1)/len+1; for(int i=1;i&lt;=num;++i) l[i]=(i-1)*len+1,r[i]=i*len; r[num]=n;&#125; 接下来我们就用 $9​$ 个来自 LOJ 的例题（可能稍有修改）来简单讲解一下分块的思想。 例题 1给定一个长度为 $n$ 的序列和 $m$ 个操作。支持区间加法，单点求值。 Solution我们用 $tag[i]$ 记录第 $i$ 个块内每个元素都加的值。 对于修改操作 $[x,y]$ 有两种情况： 其中 $x$ 和 $y$ 在同一个块内，那么直接暴力修改 $a[i]$ 的值即可。 其中 $x$ 和 $y$ 不在同一个块内，那么先修改整块 $(bl[x],bl[y])$ 的 $tag$ 值，然后再对 $x$ 和 $y$ 所在的块内的零散元素暴力修改 $a[i]$ 的值。 对于查询操作 $x$，直接输出 $a[x]+tag[bl[x]]$ 的值。 时间复杂度：$O(m\sqrt n)$ Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cmath&gt;const int N=1e5+5,M=320;int n,m,len,num,a[N],bl[N],l[M],r[M],tag[M];void build() &#123; len=sqrt(n),num=(n-1)/len+1; for(int i=1;i&lt;=n;++i) bl[i]=(i-1)/len+1; for(int i=1;i&lt;=num;++i) l[i]=(i-1)*len+1,r[i]=i*len; r[num]=n;&#125;void modify(int x,int y,int v) &#123; if(bl[x]==bl[y]) &#123; for(int i=x;i&lt;=y;++i) a[i]+=v; &#125; else &#123; for(int i=bl[x]+1;i&lt;=bl[y]-1;++i) tag[i]+=v; for(int i=x;i&lt;=r[bl[x]];++i) a[i]+=v; for(int i=l[bl[y]];i&lt;=y;++i) a[i]+=v; &#125;&#125;int query(int x) &#123; return a[x]+tag[bl[x]];&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) scanf("%d",&amp;a[i]); build(); while(m--) &#123; int opt; scanf("%d",&amp;opt); if(!opt) &#123; int x,y,v; scanf("%d%d%d",&amp;x,&amp;y,&amp;v); modify(x,y,v); &#125; else &#123; int x; scanf("%d",&amp;x); printf("%d\n",query(x)); &#125; &#125; return 0;&#125; 例题 2给定一个长度为 $n$ 的序列和 $m$ 个操作。支持区间加法，区间查询小于 $v$ 的元素个数。 Solution我们首先考虑没有修改操作怎么做： 对于零散元素，我们直接暴力查找。 对于整块，我们可以先排序然后直接二分查找。 如果有了修改操作，那么意味着我们每次修改后需要重新排序，还是分成两部分考察： 对于零散元素，我们暴力修改后对不完整块直接重新排序。时间复杂度为 $O(\sqrt n\log n)$。 对于整块，我们发现修改不影响元素之间的相对顺序，所以不需要排序。查询时需要用 $v-tag[i]$ 的值二分查找。时间复杂度为 $O(\sqrt n)$。 时间复杂度：$O(m\sqrt n\log n)$（其中可以用均值不等式计算出更优的复杂度 QAQ） Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;const int N=1e5+5,M=320;int n,m,len,num,a[N],bl[N],l[M],r[M],tag[M];std::vector&lt;int&gt; ve[M];void build() &#123; len=sqrt(n),num=(n-1)/len+1; for(int i=1;i&lt;=n;++i) &#123; bl[i]=(i-1)/len+1; ve[bl[i]].push_back(a[i]); &#125; for(int i=1;i&lt;=num;++i) &#123; l[i]=(i-1)*len+1,r[i]=i*len; std::sort(ve[i].begin(),ve[i].end()); &#125; r[num]=n;&#125;void reset(int x) &#123; ve[x].clear(); for(int i=l[x];i&lt;=r[x];++i) ve[x].push_back(a[i]); std::sort(ve[x].begin(),ve[x].end());&#125;void modify(int x,int y,int v) &#123; if(bl[x]==bl[y]) &#123; for(int i=x;i&lt;=y;++i) a[i]+=v; reset(bl[x]); &#125; else &#123; for(int i=bl[x]+1;i&lt;=bl[y]-1;++i) tag[i]+=v; for(int i=x;i&lt;=r[bl[x]];++i) a[i]+=v; for(int i=l[bl[y]];i&lt;=y;++i) a[i]+=v; reset(bl[x]),reset(bl[y]); &#125;&#125;int query(int x,int y,int v) &#123; int ans=0; if(bl[x]==bl[y]) &#123; for(int i=x;i&lt;=y;++i) if(a[i]+tag[bl[i]]&lt;v) ++ans; &#125; else &#123; for(int i=bl[x]+1;i&lt;=bl[y]-1;++i) &#123; ans+=std::lower_bound(ve[i].begin(),ve[i].end(),v-tag[i])-ve[i].begin(); &#125; for(int i=x;i&lt;=r[bl[x]];++i) if(a[i]+tag[bl[i]]&lt;v) ++ans; for(int i=l[bl[y]];i&lt;=y;++i) if(a[i]+tag[bl[i]]&lt;v) ++ans; &#125; return ans;&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) scanf("%d",&amp;a[i]); build(); while(m--) &#123; int opt,x,y,v; scanf("%d%d%d%d",&amp;opt,&amp;x,&amp;y,&amp;v); if(!opt) &#123; modify(x,y,v); &#125; else &#123; printf("%d\n",query(x,y,v)); &#125; &#125; return 0;&#125; 例题 3给定一个长度为 $n$ 的序列和 $m$ 个操作。支持区间加法，区间查询 $v$ 的前驱。 Solution我们有一个很直观的想法：直接沿用例题 2 的思路，只要修改一下二分即可。 但是这题有一个更简单的方法，直接用 $\text{set}$ 维护块内信息。这样甚至可以支持插入和删除操作，更加方便。但是 $\text{set}$ 常数巨大，所以此题不建议使用 $\text{set}​$ 来维护。 时间复杂度：$O(m\sqrt n\log n)$ Code直接二分查找 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;const int N=1e5+5,M=320;int n,m,len,num,a[N],bl[N],l[M],r[M],tag[M];std::vector&lt;int&gt; ve[M];void build() &#123; len=sqrt(n),num=(n-1)/len+1; for(int i=1;i&lt;=n;++i) &#123; bl[i]=(i-1)/len+1; ve[bl[i]].push_back(a[i]); &#125; for(int i=1;i&lt;=num;++i) &#123; l[i]=(i-1)*len+1,r[i]=i*len; std::sort(ve[i].begin(),ve[i].end()); &#125; r[num]=n;&#125;void reset(int x) &#123; ve[x].clear(); for(int i=l[x];i&lt;=r[x];++i) ve[x].push_back(a[i]); std::sort(ve[x].begin(),ve[x].end());&#125;void modify(int x,int y,int v) &#123; if(bl[x]==bl[y]) &#123; for(int i=x;i&lt;=y;++i) a[i]+=v; reset(bl[x]); &#125; else &#123; for(int i=bl[x]+1;i&lt;=bl[y]-1;++i) tag[i]+=v; for(int i=x;i&lt;=r[bl[x]];++i) a[i]+=v; for(int i=l[bl[y]];i&lt;=y;++i) a[i]+=v; reset(bl[x]),reset(bl[y]); &#125;&#125;int query(int x,int y,int v) &#123; int ans=-1; if(bl[x]==bl[y]) &#123; for(int i=x;i&lt;=y;++i) &#123; int val=a[i]+tag[bl[i]]; if(val&lt;v) ans=std::max(ans,val); &#125; &#125; else &#123; for(int i=bl[x]+1;i&lt;=bl[y]-1;++i) &#123; std::vector&lt;int&gt;::iterator it=std::lower_bound(ve[i].begin(),ve[i].end(),v-tag[i]); if(it!=ve[i].begin()) ans=std::max(ans,*(--it)+tag[i]); &#125; for(int i=x;i&lt;=r[bl[x]];++i) &#123; int val=a[i]+tag[bl[i]]; if(val&lt;v) ans=std::max(ans,val); &#125; for(int i=l[bl[y]];i&lt;=y;++i) &#123; int val=a[i]+tag[bl[i]]; if(val&lt;v) ans=std::max(ans,val); &#125; &#125; return ans;&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) scanf("%d",&amp;a[i]); build(); while(m--) &#123; int opt,x,y,v; scanf("%d%d%d%d",&amp;opt,&amp;x,&amp;y,&amp;v); if(!opt) &#123; modify(x,y,v); &#125; else &#123; printf("%d\n",query(x,y,v)); &#125; &#125; return 0;&#125; 使用 $\text{set}$ 维护 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;set&gt;const int N=1e5+5,M=320;int n,m,len,num,a[N],bl[N],l[M],r[M],tag[M];std::set&lt;int&gt; s[M];void build() &#123; len=sqrt(n),num=(n-1)/len+1; for(int i=1;i&lt;=n;++i) bl[i]=(i-1)/len+1,s[bl[i]].insert(a[i]); for(int i=1;i&lt;=num;++i) l[i]=(i-1)*len+1,r[i]=i*len; r[num]=n;&#125;void update(int x,int v) &#123; s[bl[x]].erase(a[x]),s[bl[x]].insert(a[x]+=v);&#125;void modify(int x,int y,int v) &#123; if(bl[x]==bl[y]) &#123; for(int i=x;i&lt;=y;++i) update(i,v); &#125; else &#123; for(int i=bl[x]+1;i&lt;=bl[y]-1;++i) tag[i]+=v; for(int i=x;i&lt;=r[bl[x]];++i) update(i,v); for(int i=l[bl[y]];i&lt;=y;++i) update(i,v); &#125;&#125;int query(int x,int y,int v) &#123; int ans=-1; if(bl[x]==bl[y]) &#123; for(int i=x;i&lt;=y;++i) &#123; int val=a[i]+tag[bl[i]]; if(val&lt;v) ans=std::max(ans,val); &#125; &#125; else &#123; for(int i=bl[x]+1;i&lt;=bl[y]-1;++i) &#123; std::set&lt;int&gt;::iterator it=s[i].lower_bound(v-tag[i]); if(it!=s[i].begin()) ans=std::max(ans,*(--it)+tag[i]); &#125; for(int i=x;i&lt;=r[bl[x]];++i) &#123; int val=a[i]+tag[bl[i]]; if(val&lt;v) ans=std::max(ans,val); &#125; for(int i=l[bl[y]];i&lt;=y;++i) &#123; int val=a[i]+tag[bl[i]]; if(val&lt;v) ans=std::max(ans,val); &#125; &#125; return ans;&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) scanf("%d",&amp;a[i]); build(); while(m--) &#123; int opt,x,y,v; scanf("%d%d%d%d",&amp;opt,&amp;x,&amp;y,&amp;v); if(!opt) &#123; modify(x,y,v); &#125; else &#123; printf("%d\n",query(x,y,v)); &#125; &#125; return 0;&#125; 例题 4给定一个长度为 $n$ 的序列和 $m$ 个操作。支持区间加法，区间求和。答案对 $10^9+7$ 取模。 Solution这题还是和例题 1 一样的思路，只不过需要多维护一个区间和：我们定义 $sum[i]$ 表示第 $i$ 个块的总和（不包括 $tag[i]$ 的值，也就是说这两者是独立的）。 我们先分析修改操作，对于两种情况分类讨论： 对于零散元素，我们暴力修改 $a[i]$ 和 $sum[bl[i]]$ 的值。 对于整块，只需要修改 $tag[i]$ 的值即可，而不需要修改 $sum[i]$ 的值。 我们再分析查询操作，对于两种情况分类讨论： 对于零散元素，我们用 $a[i]+tag[bl[i]]$ 来更新答案。 对于整块，经过简单的思考就可以发现答案就是 $sum[i]+tag[i]\times len$ 的总和。 为什么可以直接用 $len$ 的值？因为我们在统计时，只使用 $(bl[x],bl[y])$ 这个闭区间内的整块，不涉及最后一个块，所以每个块的大小必为 $len$。 时间复杂度：$O(m\sqrt n)$ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;cmath&gt;const int mod=1e9+7;const int N=1e5+5,M=320;int n,m,len,num,a[N],bl[N],l[M],r[M],tag[M],sum[M];void upd(int &amp;x,int y) &#123; (x+=y)&gt;=mod&amp;&amp;(x-=mod);&#125;void build() &#123; len=sqrt(n),num=(n-1)/len+1; for(int i=1;i&lt;=n;++i) bl[i]=(i-1)/len+1,upd(sum[bl[i]],a[i]); for(int i=1;i&lt;=num;++i) l[i]=(i-1)*len+1,r[i]=i*len; r[num]=n;&#125;void modify(int x,int y,int v) &#123; if(bl[x]==bl[y]) &#123; for(int i=x;i&lt;=y;++i) a[i]+=v; upd(sum[bl[x]],1LL*(y-x+1)*v%mod); &#125; else &#123; for(int i=bl[x]+1;i&lt;=bl[y]-1;++i) upd(tag[i],v); for(int i=x;i&lt;=r[bl[x]];++i) upd(a[i],v); upd(sum[bl[x]],1LL*(r[bl[x]]-x+1)*v%mod); for(int i=l[bl[y]];i&lt;=y;++i) upd(a[i],v); upd(sum[bl[y]],1LL*(y-l[bl[y]]+1)*v%mod); &#125;&#125;int query(int x,int y) &#123; int ans=0; if(bl[x]==bl[y]) &#123; for(int i=x;i&lt;=y;++i) upd(ans,a[i]); upd(ans,1LL*(y-x+1)*tag[bl[x]]%mod); &#125; else &#123; for(int i=bl[x]+1;i&lt;=bl[y]-1;++i) upd(ans,sum[i]),upd(ans,1LL*tag[i]*len%mod); for(int i=x;i&lt;=r[bl[x]];++i) upd(ans,a[i]); upd(ans,1LL*(r[bl[x]]-x+1)*tag[bl[x]]%mod); for(int i=l[bl[y]];i&lt;=y;++i) upd(ans,a[i]); upd(ans,1LL*(y-l[bl[y]]+1)*tag[bl[y]]%mod); &#125; return ans;&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) scanf("%d",&amp;a[i]); build(); while(m--) &#123; int opt,x,y; scanf("%d%d%d",&amp;opt,&amp;x,&amp;y); if(!opt) &#123; int v; scanf("%d",&amp;v); modify(x,y,v); &#125; else &#123; printf("%d\n",query(x,y)); &#125; &#125; return 0;&#125; 例题 5给定一个长度为 $n$ 的序列和 $m$ 个操作。支持区间开方，区间求和。 Solution由于有区间开方操作，没法直接更新区间和，问题貌似比较棘手。 但是我们可以分析一下开方的性质：一个 $10^9$ 的数字不断进行开方，其值大约为：$10^9,31622,177,13,3,1,1,1,\cdots$ 那么意味着，每个数最多被开方大约 $5$ 次，这样我们可以记录每个块中是否有 $&gt;1$ 的元素。如果没有则不需要对这个块内元素开方操作。 有了这个性质，直接暴力操作即可。 时间复杂度：$O(m\sqrt n)$ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cmath&gt;const int N=1e5+5,M=320;int n,m,len,num,a[N],bl[N],l[M],r[M],sum[M];bool flg[M];void build() &#123; len=sqrt(n),num=(n-1)/len+1; for(int i=1;i&lt;=n;++i) bl[i]=(i-1)/len+1,sum[bl[i]]+=a[i]; for(int i=1;i&lt;=num;++i) l[i]=(i-1)*len+1,r[i]=i*len; r[num]=n;&#125;void solve(int x) &#123; if(flg[x]) return; sum[x]=0,flg[x]=1; for(int i=l[x];i&lt;=r[x];++i) sum[x]+=(a[i]=sqrt(a[i])),flg[x]&amp;=(a[i]&lt;=1);&#125;void modify(int x,int y) &#123; if(bl[x]==bl[y]) &#123; for(int i=x;i&lt;=y;++i) sum[bl[x]]-=a[i],sum[bl[x]]+=(a[i]=sqrt(a[i])); &#125; else &#123; for(int i=bl[x]+1;i&lt;=bl[y]-1;++i) solve(i); for(int i=x;i&lt;=r[bl[x]];++i) sum[bl[x]]-=a[i],sum[bl[x]]+=(a[i]=sqrt(a[i])); for(int i=l[bl[y]];i&lt;=y;++i) sum[bl[y]]-=a[i],sum[bl[y]]+=(a[i]=sqrt(a[i])); &#125;&#125;int query(int x,int y) &#123; int ans=0; if(bl[x]==bl[y]) &#123; for(int i=x;i&lt;=y;++i) ans+=a[i]; &#125; else &#123; for(int i=bl[x]+1;i&lt;=bl[y]-1;++i) ans+=sum[i]; for(int i=x;i&lt;=r[bl[x]];++i) ans+=a[i]; for(int i=l[bl[y]];i&lt;=y;++i) ans+=a[i]; &#125; return ans;&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) scanf("%d",&amp;a[i]); build(); while(m--) &#123; int opt,x,y; scanf("%d%d%d",&amp;opt,&amp;x,&amp;y); if(!opt) &#123; modify(x,y); &#125; else &#123; printf("%d\n",query(x,y)); &#125; &#125; return 0;&#125; 例题 6给定一个长度为 $n$ 的序列和 $m$ 个操作。支持单点插入，单点求值。 Solution首先考虑数据随机的情况，那么每个块内插入的操作是均摊的。我们只需要用 $\text{vector}$ 维护每个块，暴力插入查询即可，时间复杂度依旧为 $O(m\sqrt n)$。 我们发现，在极限数据下，某个块内可能会被插入至多 $O(m)$ 次，这样单次操作的复杂度就变成了 $O(m)$，显然是不能接受的。 我们发现，当一个块的大小过大时就会影响整体的复杂度。那么我们在块过大时进行重构分块，我们定义一个阈值 $k$，当某个块的大小超过 $k\times len$ 时，我们对整个序列进行重构。一般而言，这个阈值 $k$ 在 $20$ 左右复杂度较优。 当然还有一个方法：每进行 $\sqrt n$ 次插入操作后就进行重构。每次重构的复杂度为 $O(n+m)$，那么总体的复杂度还是 $O(m\sqrt n)$（默认 $n$ 和 $m$ 同阶）。 时间复杂度：$O(m\sqrt n)$ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;vector&gt;const int N=1e5+5,M=500;int n,m,len,num,a[N],st[N&lt;&lt;1];std::vector&lt;int&gt; ve[M];void build() &#123; len=sqrt(n),num=(n-1)/len+1; for(int i=1;i&lt;=n;++i) ve[(i-1)/len+1].push_back(a[i]);&#125;void rebuild() &#123; int top=0; for(int i=1;i&lt;=num;++i) &#123; for(int j=0;j&lt;(int)ve[i].size();++j) st[++top]=ve[i][j]; ve[i].clear(); &#125; len=sqrt(top),num=(top-1)/len+1; for(int i=1;i&lt;=top;++i) ve[(i-1)/len+1].push_back(st[i]);&#125;std::pair&lt;int,int&gt; get(int k) &#123; int x=1; while(k&gt;(int)ve[x].size()) k-=ve[x++].size(); return std::make_pair(x,k-1);&#125;void insert(int x,int v) &#123; std::pair&lt;int,int&gt; r=get(x); int i=r.first; ve[i].insert(ve[i].begin()+r.second,v); if((int)ve[i].size()&gt;20*len) rebuild();&#125;int query(int x) &#123; std::pair&lt;int,int&gt; r=get(x); return ve[r.first][r.second];&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) scanf("%d",&amp;a[i]); build(); while(m--) &#123; int opt,x; scanf("%d%d",&amp;opt,&amp;x); if(!opt) &#123; int v; scanf("%d",&amp;v); insert(x,v); &#125; else &#123; printf("%d\n",query(x)); &#125; &#125; return 0;&#125; 例题 7给定一个长度为 $n$ 的序列和 $m$ 个操作。支持区间乘法，区间加法，单点求值。答案对 $10007$ 取模。 Solution我们发现修改操作和「Luogu 3373」【模板】线段树 2 的套路非常相似。 首先我们强制乘法比加法优先。也就是说，块内维护两个标记 $add[i]$ 和 $mul[i]$ 分别表示整个块内加、乘的值。一个元素 $a[i]$ 实际表示的值为 $a[i]\times mul[bl[i]]+add[bl[i]]$。 块内乘法 $v$：假如两个标记的值为 $A$ 和 $M$，那么标记变成 $A\times v$ 和 $M\times v$。 块内加法 $v$：假如两个标记的值为 $A$ 和 $M$，那么标记变成 $A+v$ 和 $M$。 对于零散元素，我们无法直接修改，所以直接暴力将所在块内的标记转移到元素上，然后将标记清空（$add[i]=0,mul[i]=1$），直接对零散元素本身修改即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;cstdio&gt;#include &lt;cmath&gt;const int mod=10007;const int N=1e5+5,M=320;int n,m,len,num,a[N],bl[N],l[M],r[M],add[M],mul[M];void build() &#123; len=sqrt(n),num=(n-1)/len+1; for(int i=1;i&lt;=n;++i) bl[i]=(i-1)/len+1; for(int i=1;i&lt;=num;++i) l[i]=(i-1)*len+1,r[i]=i*len,mul[i]=1; r[num]=n;&#125;void upd(int &amp;x,int y) &#123; (x+=y)&gt;=mod&amp;&amp;(x-=mod);&#125;void reset(int x) &#123; for(int i=l[x];i&lt;=r[x];++i) a[i]=(a[i]*mul[x]+add[x])%mod; add[x]=0,mul[x]=1;&#125;void modifyAdd(int x,int y,int v) &#123; if(bl[x]==bl[y]) &#123; reset(bl[x]); for(int i=x;i&lt;=y;++i) upd(a[i],v); &#125; else &#123; for(int i=bl[x]+1;i&lt;=bl[y]-1;++i) upd(add[i],v); reset(bl[x]),reset(bl[y]); for(int i=x;i&lt;=r[bl[x]];++i) upd(a[i],v); for(int i=l[bl[y]];i&lt;=y;++i) upd(a[i],v); &#125;&#125;void modifyMul(int x,int y,int v) &#123; if(bl[x]==bl[y]) &#123; reset(bl[x]); for(int i=x;i&lt;=y;++i) (a[i]*=v)%=mod; &#125; else &#123; for(int i=bl[x]+1;i&lt;=bl[y]-1;++i) (add[i]*=v)%=mod,(mul[i]*=v)%=mod; reset(bl[x]),reset(bl[y]); for(int i=x;i&lt;=r[bl[x]];++i) (a[i]*=v)%=mod; for(int i=l[bl[y]];i&lt;=y;++i) (a[i]*=v)%=mod; &#125;&#125;int query(int x) &#123; return (a[x]*mul[bl[x]]+add[bl[x]])%mod;&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) scanf("%d",&amp;a[i]); build(); while(m--) &#123; int opt; scanf("%d",&amp;opt); if(!opt) &#123; int x,y,v; scanf("%d%d%d",&amp;x,&amp;y,&amp;v); modifyAdd(x,y,v%mod); &#125; else if(opt==1) &#123; int x,y,v; scanf("%d%d%d",&amp;x,&amp;y,&amp;v); modifyMul(x,y,v%mod); &#125; else &#123; int x; scanf("%d",&amp;x); printf("%d\n",query(x)); &#125; &#125; return 0;&#125; 例题 8给定一个长度为 $n$ 的序列和 $m$ 个操作。支持区间查询等于 $v$ 的元素个数并覆盖为 $v$。 Solution我们先考虑一个暴力的做法，对于修改操作： 对于零散元素，我们暴力修改。注意单点修改前需要下放标记！ 对于整块，我们对这个块打上标记，表示整个块内的元素相同，均为 $v$。 然后考虑查询操作： 对于零散元素，我们下放标记后暴力查询。 对于整块，如果这个块内有标记且标记的值为 $v$，那么对答案有 $len$ 的贡献。如果没有标记，那么我们对 $[l[i],r[i]]$ 区间内的元素暴力查询。 这个做法看上去单次查询的复杂度为 $O(n)$，但是我们这样分析： 假设初始序列都是同一个值，那么单次查询的复杂度为 $O(\sqrt n)$。如果这是进行一个区间操作，它最多破环首位 $2$ 个块的标记，所以只能使得后面的询问至多增加 $2$ 个块的暴力时间，所以均摊的单次复杂度为 $O(\sqrt n)$。 换句话说，要让一次操作耗费 $O(n)$ 的时间，要先花费 $O(\sqrt n)$ 个操作对数列进行修改！综上所述，总体时间复杂度为 $O(m\sqrt n)$。 时间复杂度：$O(m\sqrt n)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;cmath&gt;const int N=1e5+5,M=320;int n,m,len,num,a[N],bl[N],l[M],r[M],cov[M];bool tag[M];void build() &#123; len=sqrt(n),num=(n-1)/len+1; for(int i=1;i&lt;=n;++i) bl[i]=(i-1)/len+1; for(int i=1;i&lt;=num;++i) l[i]=(i-1)*len+1,r[i]=i*len; r[num]=n;&#125;void reset(int x) &#123; if(!tag[x]) return; for(int i=l[x];i&lt;=r[x];++i) a[i]=cov[x]; tag[x]=0;&#125;void modify(int x,int y,int v) &#123; if(bl[x]==bl[y]) &#123; reset(bl[x]); for(int i=x;i&lt;=y;++i) a[i]=v; &#125; else &#123; for(int i=bl[x]+1;i&lt;=bl[y]-1;++i) tag[i]=1,cov[i]=v; reset(bl[x]),reset(bl[y]); for(int i=x;i&lt;=r[bl[x]];++i) a[i]=v; for(int i=l[bl[y]];i&lt;=y;++i) a[i]=v; &#125;&#125;int query(int x,int y,int v) &#123; int ans=0; if(bl[x]==bl[y]) &#123; reset(bl[x]); for(int i=x;i&lt;=y;++i) ans+=(a[i]==v); &#125; else &#123; for(int i=bl[x]+1;i&lt;=bl[y]-1;++i) &#123; if(tag[i]) &#123; ans+=(cov[i]==v?len:0); &#125; else &#123; for(int j=l[i];j&lt;=r[i];++j) ans+=(a[j]==v); &#125; &#125; reset(bl[x]),reset(bl[y]); for(int i=x;i&lt;=r[bl[x]];++i) ans+=(a[i]==v); for(int i=l[bl[y]];i&lt;=y;++i) ans+=(a[i]==v); &#125; return ans;&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) scanf("%d",&amp;a[i]); build(); while(m--) &#123; int x,y,v; scanf("%d%d%d",&amp;x,&amp;y,&amp;v); printf("%d\n",query(x,y,v)); modify(x,y,v); &#125; return 0;&#125; 例题 9给定一个长度为 $n$ 的序列和 $m​$ 个操作。支持区间查询最小众数。 Solution以下解法中，我们为了方便表述，定义 $\text{mode}(i)$ 表示第 $i$ 个整块的众数。 解法 1（无修改）我们首先可以发现一个性质：对于询问 $[x,y]$，答案 $\in\text{mode}(i\sim j)\cup\text{零散元素}$（其中 $\text{mode}(i\sim j$) 表示 $[x,y]$ 内的所有整块的众数）。令 $l,r$ 分别在第 $a,b$ 块，那么 $[l,r]$ 可以拆成： 从 $l$ 到第 $a$ 块的最后一个元素。 从第 $a+1$ 块到第 $b-1​$ 块。 从第 $b$ 块的起始一个元素到 $r$。 根据这个性质，我们只需要至多比较 $2\sqrt n+1​$ 即 $O(\sqrt n)​$ 个数的出现次数即可。 那么我们可以 $O(n\sqrt n)$ 预处理 $f[i][j]$ 表示第 $i$ 个整块到第 $j$ 个整块的众数。然后对于每个种值开一个 $\text{vector}$ 记录值 $i$ 出现的位置。 接下来考虑询问 $[x,y]$ 怎么分解处理： 对于零散元素，我们暴力查找每个元素在 $[x,y]​$ 内的出现次数，这个过程可以通过在记录 $a[i]​$ 出现位置的 $ve[a[i]]​$ 内二分查找实现。 对于整块，众数为 $f[bl[x]+1][bl[y]-1]$，出现次数同理可以二分得到。 我们只需要在这 $O(\sqrt n)$ 个数内找到出现次数最多的数即可。 注意，为了方便计算需要事先对数据离散化。 时间复杂度：$O(m\sqrt n\log n)$（可以通过均值不等式计算出块的大小为 $\sqrt{\frac{n}{\log n}}$ 以获得更优的复杂度通过本题） 期望得分：$80\sim100​$ 解法 2（无修改）我们考虑在解法 1 的基础上进行修改。首先 $\sqrt n$ 这个系数是肯定没法去掉了，考虑如何仍然在 $\sqrt n$ 分块下去掉 $\log n$ 这个系数。这意味着我们要在 $O(1)$ 的时间内回答询问。 不妨设 $F[i][x]$ 表示 $[0,i]$ 之间有多少个 $x$。那么 $[l,r]$ 之间的 $x$ 的数量就是 $F[r][x]-F[l-1][x]$，所以可以省去一个二分的 $\log n$。 预处理时，我们只需要对序列扫一遍即可，复杂度为 $O(n)​$。 时间复杂度：$O(m\sqrt n)$ 期望得分：$100$ 解法 3（带修改）貌似可以 $\sqrt[3] n$ 分块？推荐阅读 区间众数解题报告 - 陈立杰 改日填坑 Code解法 1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;const int N=1e5+5,M=1300;int n,m,len,num,a[N],val[N],bl[N],l[M],r[M],cnt[N],f[M][M];std::vector&lt;int&gt; p[N];void build() &#123; for(int i=1;i&lt;=n;++i) val[i]=a[i]; std::sort(val+1,val+n+1); int sz=std::unique(val+1,val+n+1)-(val+1); for(int i=1;i&lt;=n;++i) &#123; a[i]=std::lower_bound(val+1,val+sz+1,a[i])-val; p[a[i]].push_back(i); &#125; len=sqrt(n/log2(n)),num=(n-1)/len+1; for(int i=1;i&lt;=n;++i) bl[i]=(i-1)/len+1; for(int i=1;i&lt;=num;++i) l[i]=(i-1)*len+1,r[i]=i*len; r[num]=n;&#125;void init() &#123; for(int i=1;i&lt;=num;++i) &#123; memset(cnt,0,sizeof(cnt)); int ans=0,mx=0; for(int j=i;j&lt;=num;++j) &#123; for(int k=l[j];k&lt;=r[j];++k) &#123; ++cnt[a[k]]; if(cnt[a[k]]&gt;mx||(cnt[a[k]]==mx&amp;&amp;a[k]&lt;ans)) ans=a[k],mx=cnt[a[k]]; &#125; f[i][j]=ans; &#125; &#125;&#125;int sum(int l,int r,int v) &#123; return std::upper_bound(p[v].begin(),p[v].end(),r)-std::lower_bound(p[v].begin(),p[v].end(),l);&#125;void solve(int x,int y,int l,int r,int &amp;ans,int &amp;mx) &#123; for(int i=x;i&lt;=y;++i) &#123; int now=sum(l,r,a[i]); if(now&gt;mx||(now==mx&amp;&amp;a[i]&lt;ans)) ans=a[i],mx=now; &#125;&#125;int query(int x,int y) &#123; int ans=0,mx=0; if(bl[x]+1&gt;=bl[y]) &#123; solve(x,y,x,y,ans,mx); &#125; else &#123; ans=f[bl[x]+1][bl[y]-1],mx=sum(x,y,ans); solve(x,r[bl[x]],x,y,ans,mx); solve(l[bl[y]],y,x,y,ans,mx); &#125; return ans;&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) scanf("%d",&amp;a[i]); build(),init(); while(m--) &#123; int x,y; scanf("%d%d",&amp;x,&amp;y); printf("%d\n",val[query(x,y)]); &#125; return 0;&#125; 解法 2 1// 改日填坑 解法 3 1// 改日填坑 习题 Ynoi 吼啊！改日填坑]]></content>
      <tags>
        <tag>算法笔记</tag>
        <tag>分块</tag>
        <tag>根号分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「APIO 2010」特别行动队]]></title>
    <url>%2Farticles%2Fproblem-APIO-2010-Special-Action-Team%2F</url>
    <content type="text"><![CDATA[Description 题目链接：BZOJ 1911 你有一支由 $n$ 名预备役士兵组成的部队，士兵从 $1$ 到 $n$ 编号，要将他们拆分 成若干特别行动队调入战场。出于默契的考虑，同一支特别行动队中队员的编号 应该连续，即为形如 $(i,i+1,\dots,i+k)$ 的序列。 编号为 $i$ 的士兵的初始战斗力为 $x_i$ ，一支特别行动队的初始战斗力 $x$ 为队内 士兵初始战斗力之和，即 $x=x_i+x_{i+1}+\cdots+x_{i+k}$。 通过长期的观察，你总结出一支特别行动队的初始战斗力 $x$ 将按如下经验公 式修正为 $x’$：$x’= ax^2+bx+c$，其中 $a,b,c$ 是已知的系数（$a&lt;0$）。 作为部队统帅，现在你要为这支部队进行编队，使得所有特别行动队修正后战斗力之和最大。试求出这个最大和。 数据范围：$1\le n\le 10^6$，$-5\le a\le -1$，$\vert b\vert,\vert c\vert\le 10^7$，$1\le x_i\le 100$ Solution我们先列出一个朴素的 $\text{DP}$ 方程，定义 $f_i$ 表示考虑到第 $i$ 个人时的战斗力之和的最大值，记 $sum_i=\sum_{k=1}^i x_k$，那么转移方程为： f_i=\max\{f_j+a(sum_i-sum_j)^2+b(sum_i-sum_j)+c\}\quad (0\le j]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>斜率优化</tag>
        <tag>BZOJ</tag>
        <tag>APIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法笔记」斜率优化]]></title>
    <url>%2Farticles%2Falgorithm-Slope-Optimization%2F</url>
    <content type="text"><![CDATA[斜率优化，一种根据决策单调性来优化动态规划的思想。 单调队列优化毕竟斜率优化根据的是决策单调性，那么在讲斜率优化前，我们先提一下单调队列优化。 如果我们有一个转移方程： f_i=\min\{f_j+a_i+b_j\}\quad(0\le j]]></content>
      <tags>
        <tag>算法笔记</tag>
        <tag>动态规划</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI 2008」玩具装箱]]></title>
    <url>%2Farticles%2Fproblem-HNOI-2008-Toy%2F</url>
    <content type="text"><![CDATA[Description 题目链接：BZOJ 1010 P 教授要去看奥运，但是他舍不得他的玩具，于是他决定把所有的玩具运到北京。 他使用自己的压缩器进行压缩。这个压缩器可以将任意物品变成一维，再放到一种特殊的一维容器中。P 教授有编号为 $1\dots n$ 的 $n$ 件玩具，玩具经过压缩后会变成一维，第 $i$ 件件玩具压缩后长度为 $C_i$。 为了方便整理，P 教授要求： 在一个一维容器中，玩具的编号是连续的； 如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物。形式地说，如果要将 $i$ 号玩具到 $j$ 号玩具放到同一个容器中，则容器长度不小于 $x=j-i+\sum_{k=i}^{j}C_k$。 制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为 $x$，其制作费用为 $(x-L)^2$，其中 $L$ 是一个常量。 P 教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过 $L$。试求最小费用。 数据范围：$1\le n\le 5\times 10^4$，$1\le L,C_i\le 10^7$ Solution这题可以说是斜率优化的入门题了吧（关于斜率优化的分析实现，请参见我的另一篇博客「算法笔记」斜率优化）。我们首先考虑朴素的动态规划，定义 $f_i$ 表示考虑到第 $i$ 个玩具的最小费用，记 $sum_i=\sum_{k=1}^i C_k$。转移方程为： f_i=\min\{f_j+(i-j-1+sum_i-sum_j-L)^2\}\quad (0\le j]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>斜率优化</tag>
        <tag>BZOJ</tag>
        <tag>HNOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法笔记」主席树]]></title>
    <url>%2Farticles%2Falgorithm-Chairman-Tree%2F</url>
    <content type="text"><![CDATA[主席树是一种可持久化数据结构。所谓可持久化，就是可以访问某一个历史版本，我们需要运用不同版本之间的共同性质来降低复杂度。本文主要讲述主席树最经典的应用：求静态区间第 $k$ 小值。 可持久化线段树例题你需要维护一个长度为 $n$ 的序列 $a_i$，进行 $m$ 种操作，操作类型如下： 在某个历史版本上修改某一个位置的值。 访问某个历史版本上的某一个位置的值。 对于每次操作，我们需要生成一个与历史版本完全一样的版本并在这个新的版本上修改。 数据范围：$1\le n,m\le 10^6$，$\vert a_i\vert\le 10^9$。 思路分析我们最简单的思路就是暴力建立 $m$ 棵线段树，然后每次直接到对应版本查询。这样一来空间复杂度肯定承受不了，直接 $\text{MLE}$。那么我们如何维护历史版本呢？ 由于每次修改会使得它到根的路径被修改。线段树的层数为 $O(\log n)$ 层，所真正被修改的节点只有 $O(\log n)$ 个，我们只需要新建 $O(\log n)$ 个节点！这些节点只需要保存从新版本 $i$ 的根节点 $root_i$ 到需要修改的那个叶子节点的路径，对于不在此路径上的左儿子或者右儿子，只要接到原版本对应区间的对应儿子就可以啦！这样我们就可以保证，从对应版本的根节点出发，一定可以访问到这个版本的任何一个节点。 这样一来我们就可以只建立一棵线段树维护所有的版本了。对于每次修改插入一个路径，采用动态开点的方法节约内存。 上述过程的具体实现详见代码。 时间复杂度：$O(m\log n)$ 空间复杂度：$O(m\log n)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;const int N=1e6+5;int n,m,cnt,a[N],rt[N],val[N*20],lc[N*20],rc[N*20];void build(int &amp;p,int l,int r) &#123; p=++cnt; if(l==r) &#123; val[p]=a[l]; return; &#125; int mid=(l+r)&gt;&gt;1; build(lc[p],l,mid); build(rc[p],mid+1,r);&#125;void modify(int &amp;p,int l,int r,int u,int x,int v) &#123; p=++cnt,lc[p]=lc[u],rc[p]=rc[u],val[p]=val[u]; if(l==r) &#123; val[p]=v; return; &#125; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) modify(lc[p],l,mid,lc[u],x,v); else modify(rc[p],mid+1,r,rc[u],x,v);&#125;int query(int p,int l,int r,int x) &#123; if(l==r) return val[p]; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) return query(lc[p],l,mid,x); else return query(rc[p],mid+1,r,x);&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) scanf("%d",&amp;a[i]); build(rt[0],1,n); for(int i=1;i&lt;=m;++i) &#123; int u,opt,x; scanf("%d%d%d",&amp;u,&amp;opt,&amp;x); if(opt==1) &#123; int v; scanf("%d",&amp;v); modify(rt[i],1,n,rt[u],x,v); &#125; else &#123; printf("%d\n",query(rt[u],1,n,x)),rt[i]=rt[u]; &#125; &#125; return 0;&#125; 权值线段树我们一般的线段树是用于维护区间的，而权值线段树每个叶子节点维护的是某个元素出现的次数，一条线段代表着这个区间内所有数字的出现次数总和。 可以利用权值线段树查询整体第 $k$ 小值。具体方法如下： 我们先对序列进行离散化。建立一棵权值线段树。从根节点开始查找，设当前左子树的大小为 $ls$，右子树的大小为 $rs$，如果 $k\le ls$，那么第 $k$ 小值是在左子树中；否则该区间的第 $k$ 小值为右子树的第 $k-ls$ 小值。 时间复杂度：$O(\log n)$ 空间复杂度：$O(n\log n)$ 静态主席树例题给定一个长度为 $n$ 的序列 $a_i$，有 $m$ 次询问，每次询问区间 $[l,r]$ 内的第 $k$ 小值。 数据范围：$1\le n,m\le 2\times 10^5$，$\vert a_i\vert\le 10^9$ 思路分析前缀和思想我们利用之前提出的权值线段树的方法，查询 $[l,r]$ 就是令 $[1,r]$ 和 $[1,l-1]$ 两棵线段树的 $size$ 相减。由于线段树是完全二叉树，具有结构稳定的性质，所以这 $n$ 棵权值线段树是长得完全一样的，可以相减。所以我们可以建立 $n$ 棵权值线段树，第 $x$ 棵表示 $a_i(i\in[1,x])$ 组成权值线段树。 运用可持久化线段树但是发现暴力开 $n$ 棵线段树的空间肯定是不行的，考虑如何优化。 我们很容易发现，每次加进来一个新的数字，只有这个权值对应的节点到根的路径会发生变化，这不就是可持久化线段树吗？ 所以我们只需要先建立第 $0$ 棵线段树（空树），然后对每个前缀 $i$ 在第 $i-1$ 棵权值线段树的基础上新建 $O(\log n)$ 个节点形成第 $i$ 棵权值线段树。 每次查询时，用第 $r$ 棵线段树减去 $l-1$ 棵线段树，具体过程和权值线段树的查找过程相同！ 时间复杂度：$O((n+m)\log n)$ 空间复杂度：$O(n\log n)$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int N=2e5+5,M=N*18;int n,m,cnt,a[N],b[N],rt[N],sum[M],lc[M],rc[M];void build(int &amp;p,int l,int r) &#123; p=++cnt; if(l==r) return; int mid=(l+r)&gt;&gt;1; build(lc[p],l,mid); build(rc[p],mid+1,r);&#125;void modify(int &amp;p,int l,int r,int u,int x) &#123; p=++cnt,lc[p]=lc[u],rc[p]=rc[u],sum[p]=sum[u]+1; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) modify(lc[p],l,mid,lc[u],x); else modify(rc[p],mid+1,r,rc[u],x);&#125;int query(int x,int y,int l,int r,int k) &#123; if(l==r) return l; int mid=(l+r)&gt;&gt;1; int v=sum[lc[y]]-sum[lc[x]]; if(v&gt;=k) return query(lc[x],lc[y],l,mid,k); else return query(rc[x],rc[y],mid+1,r,k-v);&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) scanf("%d",&amp;a[i]),b[i]=a[i]; std::sort(b+1,b+n+1); int sz=std::unique(b+1,b+n+1)-(b+1); build(rt[0],1,sz); for(int i=1;i&lt;=n;++i) modify(rt[i],1,sz,rt[i-1],std::lower_bound(b+1,b+sz+1,a[i])-b); while(m--) &#123; int l,r,k; scanf("%d%d%d",&amp;l,&amp;r,&amp;k); printf("%d\n",b[query(rt[l-1],rt[r],1,sz,k)]); &#125; return 0;&#125; 习题 「Luogu 3919」【模板】可持久化数组（可持久化线段树/平衡树） 「Luogu 3834」【模板】可持久化线段树 1（主席树） 「Luogu 3939」数颜色 「TJOI 2013」奖学金 「POI 2014」KUR-Couriers 「Luogu 2617」Dynamic Rankings 「Luogu 2633」Count on a tree 「CQOI 2011」动态逆序对]]></content>
      <tags>
        <tag>算法笔记</tag>
        <tag>数据结构</tag>
        <tag>可持久化</tag>
        <tag>主席树</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI 2009」晨跑]]></title>
    <url>%2Farticles%2Fproblem-SDOI-2009-Morning-Jogging%2F</url>
    <content type="text"><![CDATA[Description 题目链接：BZOJ 1877 Elaxia 最近迷恋上了空手道，他为自己设定了一套健身计划，比如俯卧撑、仰卧起坐等 等，不过到目前为止，他坚持下来的只有晨跑。现在给出一张学校附近的地图，这张地图中包含 $n$ 个十字路口和 $m$ 条街道，Elaxia 只能从一个十字路口跑向另外一个十字路口，街道之间只在十字路口处相交。Elaxia 每天从寝室出发跑到学校，保证寝室编号为 $1$，学校编号为 $n$。Elaxia 的晨跑计划是按周期（包含若干天）进行的，由于他不喜欢走重复的路线，所以在一个周期内，每天的晨跑路线都不会相交（在十字路口处），寝室和学校不算十字路口。Elaxia 耐力不太好，他希望在一个周期内跑的路程尽量短，但是又希望训练周期包含的天数尽量长。 数据范围：$1\le n\le 200$，$1\le m\le 2\times 10^4$ Solution首先我们发现需要求路程最短，天数尽量长。那么我们可以考虑最小费用最大流，其中路程为费用，天数为流量。 由于每个点只能被访问 $1$ 次，那么我们进行拆点，将 $i$ 拆成 $i_1$ 和 $i_2$，其中 $i_1$ 和 $i_2$ 之间连边 $(i_1,i_2,1,0)$（容量为 $1$，费用为 $0$），对于有向图的每条边 $(u,v,w)$ 连边 $(u_2,v_1,1,w)$ 和其反向边 $(v_1,u_2,0,-w)$。 又因为 $1$ 和 $n$ 可以多次经过，那么源点和汇点分别为 $s_2$ 和 $t_1$，然后直接跑网络流即可。 时间复杂度：$O(nmf)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;const int N=4e2+5,M=1e5+5;const int INF=0x3f3f3f3f;int n,m,tot=1,lnk[N],cnr[N],ter[M],nxt[M],cap[M],cost[M],dis[N],ret;bool vis[N];void add(int u,int v,int w,int c) &#123; ter[++tot]=v,nxt[tot]=lnk[u],lnk[u]=tot,cap[tot]=w,cost[tot]=c;&#125;void addedge(int u,int v,int w,int c) &#123; add(u,v,w,c),add(v,u,0,-c);&#125;int spfa(int s,int t) &#123; memset(dis,0x3f,sizeof(dis)); memcpy(cnr,lnk,sizeof(lnk)); std::queue&lt;int&gt; q; q.push(s),dis[s]=0,vis[s]=1; while(!q.empty()) &#123; int u=q.front(); q.pop(),vis[u]=0; for(int i=lnk[u];i;i=nxt[i]) &#123; int v=ter[i]; if(cap[i]&amp;&amp;dis[v]&gt;dis[u]+cost[i]) &#123; dis[v]=dis[u]+cost[i]; if(!vis[v]) q.push(v),vis[v]=1; &#125; &#125; &#125; return dis[t]!=INF;&#125;int dfs(int u,int t,int flow) &#123; if(u==t) return flow; vis[u]=1; int ans=0; for(int i=cnr[u];i;i=nxt[i]) &#123; cnr[u]=i; int v=ter[i]; if(!vis[v]&amp;&amp;cap[i]&amp;&amp;dis[v]==dis[u]+cost[i]) &#123; int x=dfs(v,t,std::min(cap[i],flow-ans)); if(x) ret+=x*cost[i],cap[i]-=x,cap[i^1]+=x,ans+=x; &#125; &#125; vis[u]=0; return ans;&#125;int mcmf(int s,int t) &#123; int ans=0; while(spfa(s,t)) &#123; int x; while((x=dfs(s,t,INF))) ans+=x; &#125; return ans;&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); while(m--) &#123; int u,v,c; scanf("%d%d%d",&amp;u,&amp;v,&amp;c); addedge(u+n,v,1,c); &#125; for(int i=1;i&lt;=n;++i) addedge(i,i+n,1,0); int s=1+n,t=n; int ans=mcmf(s,t); printf("%d %d\n",ans,ret); return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
        <tag>BZOJ</tag>
        <tag>SDOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法笔记」网络流 - 费用流]]></title>
    <url>%2Farticles%2Falgorithm-Network-Flow-Cost-Flow%2F</url>
    <content type="text"><![CDATA[最小费用最大流，指在保证最大流量的同时最小费用。 网络流系列文章 最大流 最小割 费用流 有上下界的网络流（未学习） 概念费用我们定义一条边的费用 $w(u,v)$ 表示边 $(u,v)$ 上单位流量的费用。也就是说，当边 $(u,v)$ 的流量为 $f(u,v)$ 时，需要花费 $f(u,v)\times w(u,v)$ 的费用。 最小费用最大流网络流图中，花费最小的最大流被称为最小费用最大流，这也是接下来我们要研究的对象。 求解我们可以在 $\text{Dinic}​$ 算法的基础上进行改进，把 $\text{BFS}​$ 求分层图改为用 $\text{SPFA}​$（由于有负权边，所以不能直接用 $\text{Dijkstra}​$）来求一条单位费用之和最小的路径，也就是把 $w(u,v)​$ 当做边权然后在残量网络上求最短路，当然在 $\text{DFS}​$ 中也要略作修改。这样就可以求得网络流图的最小费用最大流了。 如何建反向边？对于一条边 $(u,v,w,c)$（其中 $w$ 和 $c$ 分别为容量和费用），我们建立正向边 $(u,v,w,c)$ 和反向边 $(v,u,0,-c)$（其中 $-c$ 是使得从反向边经过时退回原来的费用）。 优化：如果你是“关于 $\text{SPFA}$，它死了”言论的追随者，那么你可以使用 $\text{Primal-Dual}$ 原始对偶算法将 $\text{SPFA}$ 改成 $\text{Dijkstra}$！ 时间复杂度：可以证明上界为 $O(nmf)$，其中 $f$ 表示流量。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;const int N=5e3+5,M=1e5+5;const int INF=0x3f3f3f3f;int n,m,tot=1,lnk[N],cnr[N],ter[M],nxt[M],cap[M],cost[M],dis[N],ret;bool vis[N];void add(int u,int v,int w,int c) &#123; ter[++tot]=v,nxt[tot]=lnk[u],lnk[u]=tot,cap[tot]=w,cost[tot]=c;&#125;void addedge(int u,int v,int w,int c) &#123; add(u,v,w,c),add(v,u,0,-c);&#125;bool spfa(int s,int t) &#123; memset(dis,0x3f,sizeof(dis)); memcpy(cnr,lnk,sizeof(lnk)); std::queue&lt;int&gt; q; q.push(s),dis[s]=0,vis[s]=1; while(!q.empty()) &#123; int u=q.front(); q.pop(),vis[u]=0; for(int i=lnk[u];i;i=nxt[i]) &#123; int v=ter[i]; if(cap[i]&amp;&amp;dis[v]&gt;dis[u]+cost[i]) &#123; dis[v]=dis[u]+cost[i]; if(!vis[v]) q.push(v),vis[v]=1; &#125; &#125; &#125; return dis[t]!=INF;&#125;int dfs(int u,int t,int flow) &#123; if(u==t) return flow; vis[u]=1; int ans=0; for(int i=cnr[u];i&amp;&amp;ans&lt;flow;i=nxt[i]) &#123; cnr[u]=i; int v=ter[i]; if(!vis[v]&amp;&amp;cap[i]&amp;&amp;dis[v]==dis[u]+cost[i]) &#123; int x=dfs(v,t,std::min(cap[i],flow-ans)); if(x) ret+=x*cost[i],cap[i]-=x,cap[i^1]+=x,ans+=x; &#125; &#125; vis[u]=0; return ans;&#125;int mcmf(int s,int t) &#123; int ans=0; while(spfa(s,t)) &#123; int x; while((x=dfs(s,t,INF))) ans+=x; &#125; return ans;&#125;int main() &#123; int s,t; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;s,&amp;t); while(m--) &#123; int u,v,w,c; scanf("%d%d%d%d",&amp;u,&amp;v,&amp;w,&amp;c); addedge(u,v,w,c); &#125; int ans=mcmf(s,t); printf("%d %d\n",ans,ret); return 0;&#125; 习题 「Luogu 3381」【模板】最小费用最大流 「Luogu 4452」航班安排 「SDOI 2009」晨跑 「SCOI 2007」修车 「HAOI 2010」订货 「NOI 2012」美食节 网络流 24 题 「Luogu 1251」餐巾计划问题 「Luogu 2754」家园 「Luogu 2756」飞行员配对方案问题 「Luogu 2761」软件补丁问题 「Luogu 2762」太空飞行计划问题 「Luogu 2763」试题库问题 「Luogu 2764」最小路径覆盖问题 「Luogu 2765」魔术球问题 「Luogu 2766」最长不下降子序列问题 「Luogu 2770」航空路线问题 「Luogu 2774」方格取数问题 「Luogu 2775」机器人路径规划问题 「Luogu 3254」圆桌问题 「Luogu 3355」骑士共存问题 「Luogu 3356」火星探险问题 「Luogu 3357」最长k可重线段集问题 「Luogu 3358」最长k可重区间集问题 「Luogu 4009」汽车加油行驶问题 「Luogu 4011」孤岛营救问题 「Luogu 4012」深海机器人问题 「Luogu 4013」数字梯形问题 「Luogu 4014」分配问题 「Luogu 4015」运输问题 「Luogu 4016」负载平衡问题]]></content>
      <tags>
        <tag>算法笔记</tag>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2127」Happiness]]></title>
    <url>%2Farticles%2Fproblem-BZOJ-2127-Happiness%2F</url>
    <content type="text"><![CDATA[Description 题目链接：BZOJ 2127 高一一班的座位表是个 $n\times m$ 的矩阵，经过一个学期的相处，每个同学和前后左右相邻的同学互相成为了好朋友。这学期要分文理科了，每个同学对于选择文科与理科有着自己的喜悦值，而一对好朋友如果能同时选文科或者理科，那么他们又将收获一些喜悦值。 作为计算机竞赛教练的 scp 大老板，想知道如何分配可以使得全班的喜悦值总和最大。 数据范围：$1\le n,m\le 100$，喜悦值均为小于等于 $5000$ 的非负整数。 Solution考虑用网络流求解，总量减去最小割即为答案。 对于每个点 $(i,j)$，从 $s$ 连一条容量为选择文科的边，到 $t$ 连一条容量位选择理科的边。 对于 $(i,j)$ 和 $(i+1,j)$ 两个点的组合情况。假设这两个点同时选文科有 $w$ 的喜悦值，我们新建一个节点 $x$，从 $s$ 向 $x$ 连一条容量为喜悦值 $w$ 的边，再从 $x$ 向 $(i,j)$ 和 $(i+1,j)$ 分别连一条容量为 $\text{INF}$ 的边。对于左右前后、文科理科同理！ 考虑这样做法的正确性：每个点自然只能选择一个科目（文科或理科），当某个点选择了文科 $s$，那么它向理科 $t$ 的边都应该要被断开。考虑哪些边会被断开：首先是它直接连向 $t$ 的边，其次是它和别的点组合连向 $t$ 的边，这样一来，这些边在网络图的割中是有贡献的，意味着这些边的容量在答案中没有贡献，正确性证明完毕。 时间复杂度：$O((nm)^3)$（$\text{Dinic}$） Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define FOR(i,a,b) for(int i=a;i&lt;=b;++i)const int N=1e5+5,M=5e6+5;const int inf=1&lt;&lt;30;int n,m,tot=1,lnk[N],ter[M],nxt[M],val[M],dep[N],cnr[N];int id(int x,int y) &#123; return (x-1)*m+y;&#125;void add(int u,int v,int w) &#123; ter[++tot]=v,nxt[tot]=lnk[u],lnk[u]=tot,val[tot]=w;&#125;void addedge(int u,int v,int w) &#123; add(u,v,w),add(v,u,0);&#125;int bfs(int s,int t) &#123; memset(dep,0,sizeof(dep)); memcpy(cnr,lnk,sizeof(lnk)); std::queue&lt;int&gt; q; q.push(s),dep[s]=1; while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=lnk[u];i;i=nxt[i]) &#123; int v=ter[i]; if(val[i]&amp;&amp;!dep[v]) q.push(v),dep[v]=dep[u]+1; &#125; &#125; return dep[t];&#125;int dfs(int u,int t,int flow) &#123; if(u==t) return flow; int ans=0; for(int i=cnr[u];i&amp;&amp;ans&lt;flow;i=nxt[i]) &#123; cnr[u]=i; int v=ter[i]; if(val[i]&amp;&amp;dep[v]==dep[u]+1) &#123; int x=dfs(v,t,std::min(val[i],flow-ans)); if(x) val[i]-=x,val[i^1]+=x,ans+=x; &#125; &#125; if(ans&lt;flow) dep[u]=-1; return ans;&#125;int dinic(int s,int t) &#123; int ans=0; while(bfs(s,t)) &#123; int x; while((x=dfs(s,t,inf))) ans+=x; &#125; return ans;&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); int s=0,t=n*m+2*n*(m-1)+2*(n-1)*m+1,cnt=n*m; int ans=0; FOR(i,1,n) FOR(j,1,m) &#123; int x; scanf("%d",&amp;x),ans+=x; addedge(s,id(i,j),x); &#125; FOR(i,1,n) FOR(j,1,m) &#123; int x; scanf("%d",&amp;x),ans+=x; addedge(id(i,j),t,x); &#125; FOR(i,1,n-1) FOR(j,1,m) &#123; int x; scanf("%d",&amp;x),ans+=x; addedge(s,++cnt,x); addedge(cnt,id(i,j),inf); addedge(cnt,id(i+1,j),inf); &#125; FOR(i,1,n-1) FOR(j,1,m) &#123; int x; scanf("%d",&amp;x),ans+=x; addedge(++cnt,t,x); addedge(id(i,j),cnt,inf); addedge(id(i+1,j),cnt,inf); &#125; FOR(i,1,n) FOR(j,1,m-1) &#123; int x; scanf("%d",&amp;x),ans+=x; addedge(s,++cnt,x); addedge(cnt,id(i,j),inf); addedge(cnt,id(i,j+1),inf); &#125; FOR(i,1,n) FOR(j,1,m-1) &#123; int x; scanf("%d",&amp;x),ans+=x; addedge(++cnt,t,x); addedge(id(i,j),cnt,inf); addedge(id(i,j+1),cnt,inf); &#125; printf("%d\n",ans-dinic(s,t)); return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>最小割</tag>
        <tag>BZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu 2756」飞行员配对方案问题]]></title>
    <url>%2Farticles%2Fproblem-Luogu-2756-Pilots-Matching%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Luogu 2756 英国皇家空军从沦陷国征募了大量外籍飞行员。由皇家空军派出的每一架飞机都需要配备在航行技能和语言上能互相配合的 $2$ 名飞行员，其中 $1$ 名是英国飞行员，另 $1$ 名是外籍飞行员。在众多的飞行员中，每一名外籍飞行员都可以与其他若干名英国飞行员很好地配合。皇家空军共有 $n$ 名飞行员，其中 $m$ 名为外籍飞行员。对于给定的外籍飞行员与英国飞行员的配合情况，试设计一个算法找出最佳飞行员配对方案，使皇家空军一次能派出最多的飞机。 数据范围：$1\le m\le m&lt;100$ Solution由于每个飞行员只能被选择一次，所以我们可以直接想到二分图最大匹配，显然可以用匈牙利算法或网络流解决。 对于输出方案，匈牙利算法可以直接利用匹配数组，而网络流可以判断正向边是否有流量（即反向边的残量是否不为 $0$）。 时间复杂度：$O(n^2\sqrt n)$（二分图 $\text{Dinic}$） Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;const int N=205,M=2e4+5;int n,m,tot=1,lnk[N],ter[M],nxt[M],val[M],dep[N],cnr[N];void add(int u,int v,int w) &#123; ter[++tot]=v,nxt[tot]=lnk[u],lnk[u]=tot,val[tot]=w;&#125;void addedge(int u,int v,int w) &#123; add(u,v,w),add(v,u,0);&#125;int bfs(int s,int t) &#123; memset(dep,0,sizeof(dep)); memcpy(cnr,lnk,sizeof(lnk)); std::queue&lt;int&gt; q; q.push(s),dep[s]=1; while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=lnk[u];i;i=nxt[i]) &#123; int v=ter[i]; if(val[i]&amp;&amp;!dep[v]) dep[v]=dep[u]+1,q.push(v); &#125; &#125; return dep[t];&#125;int dfs(int u,int t,int flow) &#123; if(u==t) return flow; int ret=0; for(int i=cnr[u];i&amp;&amp;ret&lt;flow;i=nxt[i]) &#123; cnr[u]=i; int v=ter[i]; if(val[i]&amp;&amp;dep[v]==dep[u]+1) &#123; int x=dfs(v,t,std::min(val[i],flow-ret)); if(x) val[i]-=x,val[i^1]+=x,ret+=x; &#125; &#125; if(ret&lt;flow) dep[u]=-1; return ret;&#125;int dinic(int s,int t) &#123; int ans=0; while(bfs(s,t)) &#123; int x; while((x=dfs(s,t,1&lt;&lt;30))) ans+=x; &#125; return ans;&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); int u,v; while(scanf("%d%d",&amp;u,&amp;v)&amp;&amp;~u&amp;&amp;~v) addedge(u,v,1); int s=0,t=n+m+1; for(int i=1;i&lt;=n;++i) addedge(s,i,1); for(int i=n+1;i&lt;=m;++i) addedge(i,t,1); int ans=dinic(s,t); if(!ans) return puts("No Solution!"); printf("%d\n",ans); for(int u=1;u&lt;=n;++u) &#123; for(int i=lnk[u];i;i=nxt[i]) &#123; int v=ter[i]; if(v!=s&amp;&amp;val[i]==0&amp;&amp;val[i^1]==1) printf("%d %d\n",u,v); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>Luogu</tag>
        <tag>网络流 24 题</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOIP 2012」国王游戏]]></title>
    <url>%2Farticles%2Fproblem-NOIP-2012-King-Game%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Luogu 1080 恰逢 H 国国庆，国王邀请 $n$ 位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这 $n$ 位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。 国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。 数据范围：$1\le n\le 10^3$，$0&lt;a,b&lt;10^4$ Solution我们可以发现，对于第 $i$ 和 $i+1$ 两个人，他们的先后对其他人没有影响，所以我们可以通过调整 $i$ 和 $i+1$ 的位置，以这样的局部最优解获得全局最优解。 设第 $i$ 个人左手的数字为 $a_i$，右手的数字为 $b_i$，第 $i$ 个人之前（不包括第 $i$ 个人）的人左手数字之积为 $p$。对于 $i$ 和 $j$（我们令 $j=i+1$）的前后有两种可能。 情况 $1$：$i$ 在 $j$ 的前面情况 $2$：$i$ 在 $j$ 的后面 前面为 $i$后面为 $j$答案前面为 $j$后面为 $i$答案 $a_i$$a_j$$\max(\frac{p}{b_i},\frac{p\times a_i}{b_j})$$a_j$$a_i$$\max(\frac{p}{b_j},\frac{p\times a_j}{b_i})$ $b_i$$b_j$$b_j$$b_i$ 然后我们对比一下两个答案： ans_1=\max(\frac{p}{b_i},\frac{p\times a_i}{b_j})\\ ans_2=\max(\frac{p}{b_j},\frac{p\times a_j}{b_i})如果此时我们要求 $i$ 在 $j$ 的前面，那么需要满足 $ans_1&lt;ans_2$ 即 $\max(\frac{p}{b_i},\frac{p\times a_i}{b_j})&lt;\max(\frac{p}{b_j},\frac{p\times a_j}{b_i})$。 由于 $\frac{p}{b_i}&lt;\frac{p\times a_j}{b_i}$且 $\frac{p}{b_j}&lt;\frac{p\times a_i}{b_j}$，所以如果要满足 $ans_1&lt;ans_2$，那么一定有 $\frac{p\times a_i}{b_j}&lt;\frac{p\times a_j}{b_i}$，变形可得 $a_i\times b_i&lt;a_j\times b_j$，所以我们只需要以 $a_i\times b_i$ 为关键字从小到大排序即可。最后求解时套上高精度。我菜死了高精度调了一个晚上 时间复杂度：$O(n^2)$（朴素的高精度） Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;const int N=1e3+5;int n;struct data &#123; int x,y; bool operator &lt; (const data &amp;rhs) const &#123; return x*y&lt;rhs.x*rhs.y; &#125;&#125; a[N];struct huge &#123; int len,a[4005]; huge(int x=0) &#123;memset(a,0,sizeof(a)),a[len=1]=x;&#125; huge operator * (const int &amp;x) const &#123; huge c; for(int i=1;i&lt;=len;++i) c.a[i]=a[i]*x; c.len=len+4; for(int i=1;i&lt;=c.len;++i) c.a[i+1]+=c.a[i]/10,c.a[i]%=10; while(!c.a[c.len]) --c.len; return c; &#125; huge operator / (const int &amp;x) const &#123; huge c; c.len=len; memset(c.a,0,sizeof(c.a)); int r=0; for(int i=len;i;--i) r=10*r+a[i],c.a[i]=r/x,r%=x; while(c.len&gt;1&amp;&amp;!c.a[c.len]) --c.len; return c; &#125; bool operator &lt; (const huge &amp;b) const &#123; if(len!=b.len) return len&lt;b.len; for(int i=len;i;--i) if(a[i]!=b.a[i]) return a[i]&lt;b.a[i]; return 0; &#125; void print() &#123; for(int i=len;i;--i) printf("%d",a[i]); puts(""); &#125;&#125;;int main() &#123; scanf("%d",&amp;n); for(int i=0;i&lt;=n;++i) scanf("%d%d",&amp;a[i].x,&amp;a[i].y); std::sort(a+1,a+n+1); huge prod(1),ans; for(int i=1;i&lt;=n;++i) &#123; prod=prod*a[i-1].x; huge now=prod/a[i].y; if(ans&lt;now) ans=now; &#125; ans.print(); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>Luogu</tag>
        <tag>NOIP</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu 5110」块速递推]]></title>
    <url>%2Farticles%2Fproblem-Luogu-5110-Fast-Recursion%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Luogu 5110 给定一个数列 $a$ 满足递推式： a_n=233\times a_{n-1}+666\times a_{n-2},a_{0}=0,a_{1}=1求这个数列第 $n$ 项 $a_n\bmod (10^9+7)$ 的值，一共有 $T$ 组询问。为了减少你的输出量，你只需要输出所有询问答案的异或和。 数据范围：$0\le n&lt;2^{64}$，$1\le T\le 5\times 10^7$ Solution先考虑朴素的做法，我们可以直接用矩阵乘法和矩阵快速幂在 $O(2^3T\log n)$ 的时间内求解。矩乘的式子如下： \begin{align*} \left[\begin{matrix}a_n\\a_{n-1}\end{matrix}\right]&=\left[\begin{matrix}233\times a_{n-1}+666\times a_{n-2}\\1\times a_{n-1}+0\times a_{n-2}\end{matrix}\right] \\ &=\left[\begin{matrix}233 & 666 \\1 & 0\end{matrix}\right]\times\left[\begin{matrix}a_{n-1}\\a_{n-2}\end{matrix}\right] \\ &=\left[\begin{matrix}233 & 666 \\1 & 0\end{matrix}\right]^{n-1}\times\left[\begin{matrix}a_1\\a_0\end{matrix}\right] \end{align*}接下来我们考虑如何优化。由于 $T$ 的范围很大，我们需要保证每次询问的复杂度为 $O(1)$。首先有一个非常显然的性质 $a^b\equiv a^{b\bmod \varphi(p)}\pmod p$，因此我们把式子转化为： \begin{align*} \left[\begin{matrix}a_n\\a_{n-1}\end{matrix}\right]&=\left[\begin{matrix}233 & 666 \\1 & 0\end{matrix}\right]^{(n-1)\bmod \varphi(10^9+7)}\times\left[\begin{matrix}a_1\\a_0\end{matrix}\right] \\ &=\left[\begin{matrix}233 & 666 \\1 & 0\end{matrix}\right]^{(n-1)\bmod (10^9+6)}\times\left[\begin{matrix}a_1\\a_0\end{matrix}\right] \end{align*}虽然有这样一个转化，但是我的复杂度瓶颈却在矩阵快速幂的 $O(\log n)$ 上，考虑如何优化掉这个 $\log$：由于询问很多，我们需要在常数时间内回答，考虑预处理矩阵的幂。 我们令矩阵 $A=\left[\begin{matrix}233 &amp; 666\\ 1 &amp; 0\end{matrix}\right]$，我们预处理出两部分矩阵的幂。 首先我们令 $k=\left\lceil\sqrt{10^9+6}\right\rceil$（$10^9+6$ 也就是 $n$ 的最大值）。此处注意一定要上取整，不然预处理的幂可能不充分。 预处理 $A^1,A^2,A^3,\cdots,A^k$，将矩阵 $A^i$ 记为 $X(i)$。 预处理 $A^k,A^{2k},A^{2k},\cdots,A^{k^2}$，将矩阵 $A^{ik}$ 记为 $Y(i)$。 很显然以上两部分的复杂度均为 $O(k)$。 我们把询问 $m$（此处的 $m$ 为 $(n-1)\bmod \varphi(10^9+7)$）拆成 $m=ak+b$，其中 $0\le b&lt;k$。转化为数学语言为 $a=\left\lfloor\frac{m}{k}\right\rfloor,b=m\bmod k$，于是 $A^m$ 转化为 $(A^k)^a\times A^b$，根据我们上面预处理的部分，我们可以发现，$(A^k)^a$ 和 $A^b$ 都是可以直接查表得到的。所以 $A^m=(A^k)^a\times A^b=X(b)\times Y(a)$。 这样我们的询问复杂度就降低为 $O(1)$（其实应该是矩阵乘法复杂度 $O(2^3)$），加上常数优化即可通过本题！ 吐槽：此题卡常！出题人毒瘤！ 时间复杂度：$O(T+\sqrt{10^9+6})$（其中 $\sqrt{10^9+6}$ 约为 $32000$ 左右） Code12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cstring&gt;const int N=32000,mod=1e9+7;struct Matrix &#123; int mat[2][2]; Matrix operator * (const Matrix &amp;b) const &#123; Matrix ans; ans.mat[0][0]=(1LL*mat[0][0]*b.mat[0][0]+1LL*mat[0][1]*b.mat[1][0])%mod; ans.mat[0][1]=(1LL*mat[0][0]*b.mat[0][1]+1LL*mat[0][1]*b.mat[1][1])%mod; ans.mat[1][0]=(1LL*mat[1][0]*b.mat[0][0]+1LL*mat[1][1]*b.mat[1][0])%mod; ans.mat[1][1]=(1LL*mat[1][0]*b.mat[0][1]+1LL*mat[1][1]*b.mat[1][1])%mod; return ans; &#125;&#125; p1[N+5],p2[N+5];unsigned long long SA,SB,SC;unsigned long long rand() &#123; SA^=SA&lt;&lt;32,SA^=SA&gt;&gt;13,SA^=SA&lt;&lt;1; unsigned long long t=SA; SA=SB,SB=SC,SC^=t^SA; return SC;&#125;int main() &#123; Matrix s; s.mat[0][0]=233,s.mat[0][1]=666,s.mat[1][0]=1,s.mat[1][1]=0; p1[0].mat[0][0]=p1[0].mat[1][1]=1; for(int i=1;i&lt;=N;++i) p1[i]=p1[i-1]*s; p2[0].mat[0][0]=p2[0].mat[1][1]=1,s=p1[N]; for(int i=1;i&lt;=N;++i) p2[i]=p2[i-1]*s; int T; scanf("%d%llu%llu%llu",&amp;T,&amp;SA,&amp;SB,&amp;SC); int ans=0; for(int i=1;i&lt;=T;++i) &#123; int n=(rand()-1)%(mod-1); ans^=(p2[n/N]*p1[n%N]).mat[0][0]; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>根号分治</tag>
        <tag>Luogu</tag>
        <tag>线性递推</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu 2763」试题库问题]]></title>
    <url>%2Farticles%2Fproblem-Luogu-2763-Item-Bank-Problem%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Luogu 2763 假设一个试题库中有 $n$ 道试题，试题被分为 $k$ 个类型。每道试题都标明了所属类别，同一道题可能有多个类别属性。现要从题库中抽取 $m$ 道题组成试卷，每道题只能被选择一次。给出每个类型需要的题数，试设计一个满足要求的组卷方案。 数据范围：$2\le k\le 20$，$k\le n\le 1000$ Solution由于这道题是关于匹配的问题，所以我们可以考虑用网络流解决。 首先建立源点 $s$ 和汇点 $t$。 源点和试题相连。因为一道题只能被选择一次，所以容量为 $1$。 汇点与类型相连。因为每个类型需要若干道题目，所以容量为“这个类型需要的题目数量”。 每道试题和它所属的类型相连。因为每道题只能满足一个类型，所以容量为 $1$。 接下来直接跑最大流就行了。 最后分析一下如何判断是否有解。如果最大流小于 $m$，那么显然无解，否则就是有解。输出方案时，我们对于每个类型 $i$，如果它向试题的连边（显然这条边应该是反向边）的残量不为 $0$，那么表示这条边的正向边是满流的，也就是选择了这个匹配，就可以输出方案了。 时间复杂度：$O(n^2m)$（$\text{Dinic}$） Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;const int N=2e3+5,M=1e5+5;const int INF=1&lt;&lt;30;int n,k,tot=1,lnk[N],ter[M],nxt[M],val[M],dep[N],cnr[N];void add(int u,int v,int w) &#123; ter[++tot]=v,nxt[tot]=lnk[u],lnk[u]=tot,val[tot]=w;&#125;void addedge(int u,int v,int w) &#123; add(u,v,w),add(v,u,0);&#125;bool bfs(int s,int t) &#123; memset(dep,0,sizeof(dep)); memcpy(cnr,lnk,sizeof(lnk)); std::queue&lt;int&gt; q; q.push(s),dep[s]=1; while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=lnk[u];i;i=nxt[i]) &#123; int v=ter[i]; if(val[i]&amp;&amp;!dep[v]) q.push(v),dep[v]=dep[u]+1; &#125; &#125; return dep[t];&#125;int dfs(int u,int t,int flow) &#123; if(u==t) return flow; int ans=0; for(int i=cnr[u];i&amp;&amp;ans&lt;flow;i=nxt[i]) &#123; cnr[u]=i; int v=ter[i]; if(val[i]&amp;&amp;dep[v]==dep[u]+1) &#123; int x=dfs(v,t,std::min(val[i],flow-ans)); if(x) val[i]-=x,val[i^1]+=x,ans+=x; &#125; &#125; if(ans&lt;flow) dep[u]=-1; return ans;&#125;int dinic(int s,int t) &#123; int ans=0; while(bfs(s,t)) &#123; int x; while((x=dfs(s,t,INF))) ans+=x; &#125; return ans;&#125;int main() &#123; scanf("%d%d",&amp;k,&amp;n); int sum=0; int s=0,t=k+n+1; for(int i=1;i&lt;=k;++i) &#123; int x; scanf("%d",&amp;x),sum+=x; addedge(n+i,t,x); &#125; for(int i=1;i&lt;=n;++i) &#123; int m; scanf("%d",&amp;m); while(m--) &#123; int x; scanf("%d",&amp;x); addedge(i,n+x,1); &#125; addedge(s,i,1); &#125; if(dinic(s,t)!=sum) return puts("No Solution!"),0; for(int u=1;u&lt;=k;++u,puts("")) &#123; printf("%d:",u); for(int i=lnk[n+u];i;i=nxt[i]) &#123; if(ter[i]!=t&amp;&amp;val[i]) printf(" %d",ter[i]); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>Luogu</tag>
        <tag>网络流 24 题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BJOI 2006」狼抓兔子]]></title>
    <url>%2Farticles%2Fproblem-BJOI-2006-Wolves-Catch-Rabbits%2F</url>
    <content type="text"><![CDATA[Description 题目链接：BZOJ 1001 现在小朋友们最喜欢的”喜羊羊与灰太狼”，话说灰太狼抓羊不到，但抓兔子还是比较在行的，而且现在的兔子还比较笨，它们只有两个窝，现在你做为狼王，面对下面这样一个网格的地形： 左上角点为 $(1,1)$，右下角点为 $(n,m)$（上图中 $N=3,M=4$）。有以下三种类型的道路： $(x,y)\longleftrightarrow(x+1,y)$ $(x,y)\longleftrightarrow(x,y+1)$ $(x,y)\longleftrightarrow(x+1,y+1)$ 道路上的权值表示这条路上最多能够通过的兔子数，道路是无向的。左上角和右下角为兔子的两个窝，开始时所有的兔子都聚集在左上角 $(1,1)$ 的窝里，现在它们要跑到右下角 $(N,M)$ 的窝中去，狼王开始伏击这些兔子.当然为了保险起见，如果一条道路上最多通过的兔子数为 $K$，狼王需要安排同样数量的 $K$ 只狼，才能完全封锁这条道路，你需要帮助狼王安排一个伏击方案，使得在将兔子一网打尽的前提下，参与的狼的数量要最小。 数据范围：$1\le N,M\le 1000$ Solution很显然是一个裸的最小割，对 $(1,1)$ 到 $(N,M)$ 依次编号，然后按照题意建边跑最短路即可 QAQ 吐槽：终于做出了 BZOJ 的 1001（大雾 当然由于这题的图是一张平面图，所以我们也可以建出对偶图，直接跑最短路，得到的就是原图的最小割。 时间复杂度：$O((NM)^3)$（$\text{Dinic}$） Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;const int N=1e6+5,M=6e6+5;int n,m,tot=1,lnk[N],ter[M],nxt[M],val[M],dep[N],cnr[N];int id(int x,int y) &#123; return (x-1)*m+y;&#125;void add(int u,int v,int w) &#123; ter[++tot]=v,nxt[tot]=lnk[u],lnk[u]=tot,val[tot]=w;&#125;void addedge(int u,int v,int w) &#123; add(u,v,w),add(v,u,w);&#125;int bfs(int s,int t) &#123; memset(dep,0,sizeof(dep)); memcpy(cnr,lnk,sizeof(lnk)); std::queue&lt;int&gt; q; q.push(s),dep[s]=1; while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=lnk[u];i;i=nxt[i]) &#123; int v=ter[i]; if(val[i]&amp;&amp;!dep[v]) q.push(v),dep[v]=dep[u]+1; &#125; &#125; return dep[t];&#125;int dfs(int u,int t,int flow) &#123; if(u==t) return flow; int ans=0; for(int i=cnr[u];i&amp;&amp;ans&lt;flow;i=nxt[i]) &#123; cnr[u]=i; int v=ter[i]; if(val[i]&amp;&amp;dep[v]==dep[u]+1) &#123; int x=dfs(v,t,std::min(val[i],flow-ans)); if(x) val[i]-=x,val[i^1]+=x,ans+=x; &#125; &#125; if(ans&lt;flow) dep[u]=-1; return ans;&#125;int dinic(int s,int t) &#123; int ans=0; while(bfs(s,t)) &#123; int x; while((x=dfs(s,t,1&lt;&lt;30))) ans+=x; &#125; return ans;&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;m;++j) &#123; int x; scanf("%d",&amp;x); addedge(id(i,j),id(i,j+1),x); &#125; for(int i=1;i&lt;n;++i) for(int j=1;j&lt;=m;++j) &#123; int x; scanf("%d",&amp;x); addedge(id(i,j),id(i+1,j),x); &#125; for(int i=1;i&lt;n;++i) for(int j=1;j&lt;m;++j) &#123; int x; scanf("%d",&amp;x); addedge(id(i,j),id(i+1,j+1),x); &#125; printf("%d\n",dinic(id(1,1),id(n,m))); return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>最小割</tag>
        <tag>BZOJ</tag>
        <tag>BJOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu 1345」Telecowmunication]]></title>
    <url>%2Farticles%2Fproblem-Luogu-1345-Telecowmunication%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Luogu 1345 农夫约翰的奶牛们喜欢通过电邮保持联系，于是他们建立了一个奶牛电脑网络，以便互相交流。这个网络包括 $n$ 台电脑和 $m$ 个电脑之间的连接。这些电脑用如下的方式发送电邮：如果存在一个由 $c$ 台电脑组成的序列 $a_1,a_2,\dots,a_c$，且 $a_1$ 与 $a_2$ 相连，$a_2$ 与 $a_3$ 相连……那么电脑 $a_1$ 和 $a_c$ 就可以互发电邮。 很不幸，有时候某些倒霉的电脑会坏掉。说这意味着这台电脑不能再发送电邮了，于是与这台电脑相关的连接也就不可用了。 有两头奶牛就想：如果我们两个不能互发电邮，至少需要坏掉多少台电脑呢？你需要计算出这个最小值。 数据范围：$1\le n\le 100$，$1\le m\le 600$ Solution这道题和「BalticOI 2008」Mafia 的本质是一样的，都是割掉一部分点，使得源点和汇点不连通，只是源点和汇点是不能割掉的。于是根据 Mafia 的思路，我们有一个小变化：源点为 $s_2$，汇点为 $t_1$。之后直接跑最小割就行了。 时间复杂度：$O(n^2m)$（$\text{Dinic}$） Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;const int N=205,M=5e3+5;int n,m,tot=1,lnk[N],ter[M],nxt[M],val[M],dep[N],cnr[N];int id(int x,int y) &#123; return (x-1)*m+y;&#125;void add(int u,int v,int w) &#123; ter[++tot]=v,nxt[tot]=lnk[u],lnk[u]=tot,val[tot]=w;&#125;void addedge(int u,int v,int w) &#123; add(u,v,w),add(v,u,0);&#125;int bfs(int s,int t) &#123; memset(dep,0,sizeof(dep)); memcpy(cnr,lnk,sizeof(lnk)); std::queue&lt;int&gt; q; q.push(s),dep[s]=1; while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=lnk[u];i;i=nxt[i]) &#123; int v=ter[i]; if(val[i]&amp;&amp;!dep[v]) q.push(v),dep[v]=dep[u]+1; &#125; &#125; return dep[t];&#125;int dfs(int u,int t,int flow) &#123; if(u==t) return flow; int ans=0; for(int i=cnr[u];i&amp;&amp;ans&lt;flow;i=nxt[i]) &#123; cnr[u]=i; int v=ter[i]; if(val[i]&amp;&amp;dep[v]==dep[u]+1) &#123; int x=dfs(v,t,std::min(val[i],flow-ans)); if(x) val[i]-=x,val[i^1]+=x,ans+=x; &#125; &#125; if(ans&lt;flow) dep[u]=-1; return ans;&#125;int dinic(int s,int t) &#123; int ans=0; while(bfs(s,t)) &#123; int x; while((x=dfs(s,t,1&lt;&lt;30))) ans+=x; &#125; return ans;&#125;int main() &#123; int s,t; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;s,&amp;t); for(int i=1;i&lt;=n;++i) addedge(i,i+n,1); while(m--) &#123; int u,v; scanf("%d%d",&amp;u,&amp;v); addedge(u+n,v,1&lt;&lt;30); addedge(v+n,u,1&lt;&lt;30); &#125; printf("%d\n",dinic(s+n,t)); return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>最小割</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu 4011」孤岛营救问题]]></title>
    <url>%2Farticles%2Fproblem-Luogu-4011-Island-Rescue-Problem%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Luogu 4011 1944 年，特种兵麦克接到国防部的命令，要求立即赶赴太平洋上的一个孤岛，营救被敌军俘虏的大兵瑞恩。瑞恩被关押在一个迷宫里，迷宫地形复杂，但幸好麦克得到了迷宫的地形图。迷宫的外形是一个长方形，其南北方向被划分为 $N$ 行，东西方向被划分为 $M$ 列，于是整个迷宫被划分为 $N\times M$ 个单元。每一个单元的位置可用一个有序数对（单元的行号，单元的列号）来表示。南北或东西方向相邻的 $2$ 个单元之间可能互通，也可能有一扇锁着的门，或者是一堵不可逾越的墙。迷宫中有一些单元存放着钥匙，并且所有的门被分成 $P$ 类，打开同一类的门的钥匙相同，不同类门的钥匙不同。 大兵瑞恩被关押在迷宫的东南角，即 $(N,M)$ 单元里，并已经昏迷。迷宫只有一个入口，在西北角。也就是说，麦克可以直接进入 $(1,1)$ 单元。另外，麦克从一个单元移动到另一个相邻单元的时间为 $1$，拿取所在单元的钥匙的时间以及用钥匙开门的时间可忽略不计。 试设计一个算法，帮助麦克以最快的方式到达瑞恩所在单元，营救大兵瑞恩。 数据范围：$1\le N,M,P\le 10$ Solution由于每次移动的代价都是 $1$，所以我们可以考虑 $\text{01BFS}$；又因为 $P$ 的范围很小，可以对 $P$ 进行状压，记 $cost(i,j,k)$ 表示到 $(i,j)$ 拥有的钥匙集合为 $k$ 的最小花费，维护 $i,j,k$ 进行 $\text{01BFS}​$，一旦有解直接返回，需要判断无解情况。 注意每个点可以放置多个钥匙，钥匙使用后还是存在的。 时间复杂度：$O(NM\cdot 2^P)$ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;const int N=12;const int dx[]=&#123;1,-1,0,0&#125;,dy[]=&#123;0,0,1,-1&#125;;int n,m,e[N][N][N][N],cnt[N][N],key[N][N][N];bool vis[N][N][1&lt;&lt;14];struct node &#123; int x,y,k,d; node() &#123;x=y=k=d=0;&#125; node(int _x,int _y,int _k,int _d) &#123; x=_x,y=_y,k=_k,d=_d; &#125;&#125;;int getkey(int x,int y) &#123; int ans=0; for(int i=1;i&lt;=cnt[x][y];++i) ans|=(1&lt;&lt;(key[x][y][i]-1)); return ans;&#125;int bfs(int sx,int sy) &#123; std::queue&lt;node&gt; q; int sk=getkey(sx,sy); q.push(node(sx,sy,sk,0)),vis[sx][sy][sk]=1; while(!q.empty()) &#123; node u=q.front(); q.pop(); if(u.x==n&amp;&amp;u.y==m) return u.d; int ux=u.x,uy=u.y; for(int i=0;i&lt;4;++i) &#123; int vx=ux+dx[i],vy=uy+dy[i],opt=e[ux][uy][vx][vy]; if(vx&lt;1||vx&gt;n||vy&lt;1||vy&gt;m||opt&lt;0||(opt&amp;&amp;!(u.k&amp;(1&lt;&lt;(opt-1))))) continue; int nxt=u.k|getkey(vx,vy); if(vis[vx][vy][nxt]) continue; q.push(node(vx,vy,nxt,u.d+1)),vis[vx][vy][nxt]=1; &#125; &#125; return -1;&#125;int main() &#123; int k,s; scanf("%d%d%*d",&amp;n,&amp;m); for(scanf("%d",&amp;k);k--;) &#123; int x1,y1,x2,y2,g; scanf("%d%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;g); if(g) e[x1][y1][x2][y2]=e[x2][y2][x1][y1]=g; else e[x1][y1][x2][y2]=e[x2][y2][x1][y1]=-1; &#125; for(scanf("%d",&amp;s);s--;) &#123; int x,y,q; scanf("%d%d%d",&amp;x,&amp;y,&amp;q); key[x][y][++cnt[x][y]]=q; &#125; printf("%d\n",bfs(1,1)); return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>Luogu</tag>
        <tag>网络流 24 题</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BalticOI 2008」Mafia]]></title>
    <url>%2Farticles%2Fproblem-BalticOI-2008-Mafia%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Luogu 4662 Byteland 国警方收到了一条匿名举报，其中说当地黑帮老大正计划一次从港口到郊区仓库的运输。警方知道运输的时间并且知道运输需要用到国家的高速公路网。 高速公路网包含 $n$ 个收费站和 $m$ 条双向的高速公路，每个路段直接连着两个不同的收费站。一个收费站可能与很多其他的收费站相连。汽车只能通过收费站进入或离开高速公路网。据所知，黑帮会距港口边最近的收费站进入高速公路，从距仓库最近的收费站离开（不会在出高速后重新进入）。特警组位于选定的收费站处。当运输车辆进入被监控的收费站时，它就会被警察抓住。 从这个角度看，最简单的办法就是在每个收费站处都安排特警班。然而，控制第 $i$ 个收费站需要特定的费用 $c_i$，每个收费站费用不同。警方想要让花费最小，所以他们需要制定一个收费站的最小控制集，这个集合满足两个条件： 所有从港口到仓库的交通必须至少经过集合中的一个收费站。 监控这些收费站的费用（即监控每一个收费站费用之和）最小。 你可以假设使用高速公路可以从港口到仓库。 你需要找到收费站的最小控制集。 数据范围：$1\le n\le 200$，$1\le m\le 2\times 10^4$，$1\le c_i\le 10^7$ Solution我们需要将一些收费站安排特警班，使得源点和汇点不连通，于是这个问题就是最小割问题。 我们考虑如何将割点转化成割边。由于每个点只能被割一次，我们首先需要拆点：将点 $i$ 拆成 $i_1$ 和 $i_2$ 两个点，其中 $i_1$ 和 $i_2$ 之间连容量为代价（本题中代价为 $1$）的边。对于对于一条边 $(u,v)$，也就转化为 $(u_2,v_1,\text{INF})$ 和 $(v_2,u_1,0)$，其中容量为 $\text{INF}$ 使得这条边不可能被割掉，即割掉的边一定为 $(i_1,i_2)$ 这样的边。 由于源点和汇点也可以被割，所以源点转化为 $s_1$，汇点转化为 $t_2$。 最后我们证明一下正确性。此时，整张图的形态没有改变，每个点只能被割一次对应着每条边 $(i_1,i_2)$ 只能被割一次，正确性得证。 对于控制集，我们从源点 $s_1$ 出发沿着残量大于 $0$ 的边开始 $\text{DFS}$，将所有访问的点打标记。对于一条正向边 $(u,v)$，如果 $u$ 被打了标记而 $v$ 没有被打标记，那么就意味着这条边所代表的点被割掉了。 时间复杂度：$O(n^2m)$（$\text{Dinic}$） Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;const int N=4e2+5,M=1e5+5;const int INF=1&lt;&lt;30;int n,m,tot=1,lnk[N],ter[M],nxt[M],val[M],dep[N],cnr[N];bool vis[N];void add(int u,int v,int w) &#123; ter[++tot]=v,nxt[tot]=lnk[u],lnk[u]=tot,val[tot]=w;&#125;void addedge(int u,int v,int w) &#123; add(u,v,w),add(v,u,0);&#125;int bfs(int s,int t) &#123; memset(dep,0,sizeof(dep)); memcpy(cnr,lnk,sizeof(lnk)); std::queue&lt;int&gt; q; q.push(s),dep[s]=1; while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=lnk[u];i;i=nxt[i]) &#123; int v=ter[i]; if(val[i]&amp;&amp;!dep[v]) q.push(v),dep[v]=dep[u]+1; &#125; &#125; return dep[t];&#125;int dfs(int u,int t,int flow) &#123; if(u==t) return flow; int ans=0; for(int i=cnr[u];i&amp;&amp;ans&lt;flow;i=nxt[i]) &#123; cnr[u]=i; int v=ter[i]; if(val[i]&amp;&amp;dep[v]==dep[u]+1) &#123; int x=dfs(v,t,std::min(val[i],flow-ans)); if(x) val[i]-=x,val[i^1]+=x,ans+=x; &#125; &#125; if(ans&lt;flow) dep[u]=-1; return ans;&#125;void dinic(int s,int t) &#123; while(bfs(s,t)) while(dfs(s,t,INF));&#125;void dfs(int u) &#123; vis[u]=1; for(int i=lnk[u];i;i=nxt[i]) if(val[i]&amp;&amp;!vis[ter[i]]) dfs(ter[i]);&#125;int main() &#123; int s,t; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;s,&amp;t); for(int i=1;i&lt;=n;++i) &#123; int x; scanf("%d",&amp;x); addedge(i,i+n,x); &#125; while(m--) &#123; int u,v; scanf("%d%d",&amp;u,&amp;v); addedge(u+n,v,INF),addedge(v+n,u,INF); &#125; dinic(s,t+n); dfs(s); std::vector&lt;int&gt; ans; for(int i=2;i&lt;=tot;i+=2) &#123; int u=ter[i^1],v=ter[i]; if(vis[u]&amp;&amp;!vis[v]) ans.push_back(u); &#125; std::sort(ans.begin(),ans.end()); for(int sz=(int)ans.size()-1,i=0;i&lt;=sz;++i) &#123; printf("%d%c",ans[i]," \n"[i==sz]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>最小割</tag>
        <tag>Luogu</tag>
        <tag>BalticOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu 5098」Cave Cow 3]]></title>
    <url>%2Farticles%2Fproblem-Luogu-5098-Cave-Cows-3%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Luogu 5098 约翰的 $n$ 只奶牛在一个洞里探险，他们只能通过叫声交流。用坐标 $(x_i,y_i)$ 表示第 $i$ 只牛的位置，两只牛之间的曼哈顿距离决定了声音传播的时间，即第 $i$ 只牛和第 $j$ 只牛交流，需要的时间为 $|x_i-x_j|+|y_i-y_j|$。求出任意一对牛之间交流需要的时间的最大值。 Solution由于 $i$ 和 $j$ 是无序的，我们强制 $x_i\ge x_j$，那么我们对 $y$ 进行分类讨论： 如果 $y_i\ge y_j$，那么 $\text{原式}=x_i-x_j+y_i-y_j=(x_i+y_i)-(x_j+y_j)$。答案最大为 $\max_{x+y}-\min_{x+y}$。 如果 $y_i&lt;y_j$，那么 $\text{原式}=x_i-x_j-y_i+y_j=(x_i-y_i)-(x_j-y_j)$。答案最大为 $\max_{x-y}-\min_{x-y}$。 所以我们只需要维护 $x+y$ 和 $x-y$ 的最大值和最小值就行了。 时间复杂度：$O(n)$ Code123456789101112131415161718#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int inf=1&lt;&lt;30;int main() &#123; int n,a=-inf,b=inf,c=-inf,d=inf; for(scanf("%d",&amp;n);n--;) &#123; int x,y; scanf("%d%d",&amp;x,&amp;y); a=std::max(a,x+y); b=std::min(b,x+y); c=std::max(c,x-y); d=std::min(d,x-y); &#125; printf("%d\n",std::max(a-b,c-d)); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>Luogu</tag>
        <tag>曼哈顿距离</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu 1361」小 M 的作物]]></title>
    <url>%2Farticles%2Fproblem-Luogu-1361-Little-M-Crop%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Luogu 1361 小 M 在开辟了两块巨大的耕地 $A$ 和 $B$（你可以认为容量无穷），现在他有 $n$ 种作物的种子各 $1$ 个，编号为 $1$ 到 $n$。第 $i$ 种作物在 $A$ 中种植可以获得 $a_i$ 的收益，在 $B$ 中种植可以获得 $b_i$ 的收益。某些作物种在同一块耕地中可以获得额外的收益，小 M 找到 $m$ 种作物的组合，每个组合用 $c_1,c_2,k $ 和一个序列 $p_1,p_2,\cdots.p_k$ 表示，代表这 $k$ 种作物共同种在 $A$ 和 $B$ 耕地中可以分别获得 $c_1$ 和 $c_2$ 的额外收益。求收益的最大值。 数据范围：$1\le n,m\le 1000$ Solution通过「算法笔记」网络流 - 最小割 中问题模型的分析，我们可以发现这题每种作物只能选择一个耕地，满足二者选其一的性质，所以我们可以考虑用最小割来解决。 对于单独的作物直接从源点 $s$ 连边或向 $t$ 连边即可，难点在如何处理组合的关系。 首先明确一点，一个组合就是一个点集，它的贡献有三种情况：对集合 $A$ 有贡献；对集合 $B$ 有贡献；没有任何贡献。这意味着只划分出一种状态是无法描述的，我们需要把 $A$ 和 $B$ 集合分开考虑。 接下来讨论点集 $\{u,v,w\}$ 对集合 $A$ 的贡献。 按照题意，我们的要求是：只要 $u,v,w$ 其中一者被割进了集合 $B$（连向 $t$），那么这个点集都没有贡献。换言之，只要其中一个点在集合 $B$，那么代表点集和集合 $A$ 的连边必须断开！ 我们先用一个虚点 $x$ 从 $s$ 连一条代表贡献的边（显然点集必须用一个虚点代替）。如果其中一个点被割进了集合 $B$，那么这条代表贡献的边就要被断开，而 $x$ 到 $u,v,w$ 的边不能被断开。所以我们可以得到：边 $(s,x)$ 的容量为 $c_1$，边 $(x,u),(x,v),(x,w)$ 的容量均为 $\text{INF}$（因为只有容量为正无穷的边不可能被断开）。 这个点集对集合 $B$ 的贡献同理。经过检验，我们发现这样的连边方式是完全正确的！直接建图跑最小割即可。 注意：答案为总的收益减去最小割！ 时间复杂度：$O(n^2m)$（$\text{Dinic}$） Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;const int N=3e3+5,M=5e6+5;int n,m,tot=1,a[N],b[N],lnk[N],ter[M],nxt[M],val[M],dep[N],cnr[N];int id(int p,int x) &#123; switch(p) &#123; case 1: return x; case 2: return m+x; case 3: return m+n+x; &#125;&#125;void add(int u,int v,int w) &#123; ter[++tot]=v,nxt[tot]=lnk[u],lnk[u]=tot,val[tot]=w;&#125;void addedge(int u,int v,int w) &#123; add(u,v,w),add(v,u,0);&#125;int bfs(int s,int t) &#123; memset(dep,0,sizeof(dep)); memcpy(cnr,lnk,sizeof(lnk)); std::queue&lt;int&gt; q; q.push(s),dep[s]=1; while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=lnk[u];i;i=nxt[i]) &#123; int v=ter[i]; if(val[i]&amp;&amp;!dep[v]) q.push(v),dep[v]=dep[u]+1; &#125; &#125; return dep[t];&#125;int dfs(int u,int t,int flow) &#123; if(u==t) return flow; int ans=0; for(int i=cnr[u];i&amp;&amp;ans&lt;flow;i=nxt[i]) &#123; cnr[u]=i; int v=ter[i]; if(val[i]&amp;&amp;dep[v]==dep[u]+1) &#123; int x=dfs(v,t,std::min(val[i],flow-ans)); if(x) val[i]-=x,val[i^1]+=x,ans+=x; &#125; &#125; if(ans&lt;flow) dep[u]=-1; return ans;&#125;int dinic(int s,int t) &#123; int ans=0; while(bfs(s,t)) &#123; int x; while((x=dfs(s,t,1&lt;&lt;30))) ans+=x; &#125; return ans;&#125;int main() &#123; scanf("%d",&amp;n); int ans=0; for(int i=1;i&lt;=n;++i) scanf("%d",&amp;a[i]),ans+=a[i]; for(int i=1;i&lt;=n;++i) scanf("%d",&amp;b[i]),ans+=b[i]; scanf("%d",&amp;m); int S=0,T=m+n+m+1; for(int i=1;i&lt;=n;++i) addedge(S,id(2,i),a[i]),addedge(id(2,i),T,b[i]); for(int i=1;i&lt;=m;++i) &#123; int k,c1,c2; for(scanf("%d%d%d",&amp;k,&amp;c1,&amp;c2);k--;) &#123; int x; scanf("%d",&amp;x); addedge(id(1,i),id(2,x),1&lt;&lt;30); addedge(id(2,x),id(3,i),1&lt;&lt;30); &#125; addedge(S,id(1,i),c1); addedge(id(3,i),T,c2); ans+=c1+c2; &#125; printf("%d\n",ans-dinic(S,T)); return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>最小割</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法笔记」二分图多重匹配]]></title>
    <url>%2Farticles%2Falgorithm-Binary-Graph-Multiple-Matching%2F</url>
    <content type="text"><![CDATA[在二分图最大匹配问题中，每个点最多只能和一条匹配边相关联。但是二分图多重匹配中，每个点可以多次匹配但是有匹配上限。 例题Description学校运动会即将开始，运动会有 $m$ 个项目，第 $i$ 个项目每个班必须派出 $p_i$ 名学生参加。班级里有 $n$ 名学生，第 $i$ 名学生最多参加 $a_i$ 个项目，并且他给出了他擅长的 $b_i​$ 个项目的编号。求是否有一个合适的安排满足条件。 数据范围：$1\le n,m\le 100$ Solution我们把 $n$ 名学生和 $m$ 个项目看作是二分图的 $A,B$ 两部。那么每个学生向他擅长的项目连边。这就是二分图匹配的一般思想。 由于有 $a_i$ 和 $p_i$ 的限制，我们要求 $A$ 部的点关联的边不能超过 $a_i$ 个，那么我们需要一个方法来限制这个量在 $[0,a_i]$ 之间。这样一来，有没有感觉特别想网络流中的容量？ 于是我们可以对二分图进行扩展，建立源点 $s$ 和汇点 $t$，在 $s$ 和 $A$ 部的第 $i$ 个点之间连一条容量为 $a_i$ 的边，在 $A$ 部和 $B$ 部之间相连的边的容量为 $1$，从 $B$ 部的第 $i$ 个点向 $t$ 连一条容量为 $p_i$ 的边。这个连边方式的正确性显然。 我们对这张图跑最大流，然后分析一下各个边的含义： 边 $(s,A_i)$ 表示学生 $A_i$ 参加的项目数量。 边 $(A_i,B_j)$ 表示 $A_i$ 是否参加了 $B_j$ 项目。 边 $(B_i,t)$ 表示项目 $B_i$ 的参加人数。 所以是否有合适方案，我们只要判断是否所有的边 $(B_i,t)$ 都满流即可！ 时间复杂度：$O((n+m)\cdot(nm)^2)$（$\text{Dinic}$） Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;const int N=205,M=5e4+5;int n,m,tot=1,lnk[N],ter[M],nxt[M],val[M],dep[N],cnr[N];int id(int p,int x) &#123; return p==1?x:n+x;&#125;void add(int u,int v,int w) &#123; ter[++tot]=v,nxt[tot]=lnk[u],lnk[u]=tot,val[tot]=w;&#125;void addedge(int u,int v,int w) &#123; add(u,v,w),add(v,u,0);&#125;int bfs(int s,int t) &#123; memset(dep,0,sizeof(dep)); memcpy(cnr,lnk,sizeof(lnk)); std::queue&lt;int&gt; q; q.push(s),dep[s]=1; while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=lnk[u];i;i=nxt[i]) &#123; int v=ter[i]; if(val[i]&amp;&amp;!dep[v]) q.push(v),dep[v]=dep[u]+1; &#125; &#125; return dep[t];&#125;int dfs(int u,int t,int flow) &#123; if(u==t) return flow; int ans=0; for(int i=cnr[u];i&amp;&amp;ans&lt;flow;i=nxt[i]) &#123; cnr[u]=i; int v=ter[i]; if(val[i]&amp;&amp;dep[v]==dep[u]+1) &#123; int x=dfs(v,t,std::min(val[i],flow-ans)); if(x) val[i]-=x,val[i^1]+=x,ans+=x; &#125; &#125; if(ans&lt;flow) dep[u]=-1; return ans;&#125;void dinic(int s,int t) &#123; while(bfs(s,t)) while(dfs(s,t,1&lt;&lt;30));&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); int S=0,T=n+m+1; for(int i=1;i&lt;=m;++i) &#123; int x; scanf("%d",&amp;x); addedge(id(2,i),T,x); &#125; for(int i=1;i&lt;=n;++i) &#123; int x,y; scanf("%d%d",&amp;x,&amp;y); addedge(S,id(1,i),x); while(y--) &#123; int j; scanf("%d",&amp;j); addedge(id(1,i),id(2,j),1); &#125; &#125; dinic(S,T); bool flg=1; for(int i=lnk[T];i;i=nxt[i]) flg&amp;=!val[i^1]; puts(flg?"Yes":"No"); return 0;&#125; 习题 「hihoCoder 1393」网络流三·二分图多重匹配 「POJ 2289」Jamie’s Contact Groups 「POJ 3189」Steady Cow Assignment 「POJ 1698」Alice’s Chance 「HDU 3605」Escape]]></content>
      <tags>
        <tag>算法笔记</tag>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法笔记」网络流 - 最小割]]></title>
    <url>%2Farticles%2Falgorithm-Network-Flow-Minimum-Cut%2F</url>
    <content type="text"><![CDATA[最小割，指割去一些边使得源点和汇点不连通的最小花费，有最大流最小割定理。 网络流系列文章 最大流 最小割 费用流 有上下界的网络流（未学习） 概念割对于一个网络流图 $G=(V,E)$，其割的定义为一种点的划分方式：将所有的点划分为 $S$ 和 $T=V-S$ 两个部分，其中源点 $s\in S$，汇点 $t\in T$。 割的容量我们的定义割 $(S,T)$ 的容量 $c(S,T)$ 表示所有从 $S$ 到 $T$ 的边的容量之和，即 $c(S,T)=\sum_{u\in S,v\in T}c(u,v)$。当然我们也可以用 $c(s,t)$ 表示 $c(S,T)$。 最小割最小割就是求得一个割 $(S,T)$ 使得割的容量 $c(S,T)$ 最小。 证明最大流最小割定理定理：$f(s,t)_{\max}=c(s,t)_{\min}$ 对于任意一个可行流 $f(s,t)$ 的割 $(S,T)$，我们可以得到： f(s,t)=S\text{出边的总流量}-S\text{入边的总流量}\le S\text{出边的总流量}=c(s,t)如果我们求出了最大流 $f$，那么残余网络中一定不存在 $s$ 到 $t$ 的増广路经，也就是 $S$ 的出边一定是满流，$S$ 的入边一定是零流，于是有： f(s,t)=S\text{出边的总流量}-S\text{入边的总流量}=S\text{出边的总流量}=c(s,t)结合前面的不等式，我们可以知道此时 $f$ 已经达到最大。 代码最小割通过最大流最小割定理，我们可以直接得到如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;const int N=1e4+5,M=2e5+5;int n,m,s,t,tot=1,lnk[N],ter[M],nxt[M],val[M],dep[N],cnr[N];void add(int u,int v,int w) &#123; ter[++tot]=v,nxt[tot]=lnk[u],lnk[u]=tot,val[tot]=w;&#125;void addedge(int u,int v,int w) &#123; add(u,v,w),add(v,u,0);&#125;int bfs(int s,int t) &#123; memset(dep,0,sizeof(dep)); memcpy(cnr,lnk,sizeof(lnk)); std::queue&lt;int&gt; q; q.push(s),dep[s]=1; while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=lnk[u];i;i=nxt[i]) &#123; int v=ter[i]; if(val[i]&amp;&amp;!dep[v]) q.push(v),dep[v]=dep[u]+1; &#125; &#125; return dep[t];&#125;int dfs(int u,int t,int flow) &#123; if(u==t) return flow; int ans=0; for(int i=cnr[u];i&amp;&amp;ans&lt;flow;i=nxt[i]) &#123; cnr[u]=i; int v=ter[i]; if(val[i]&amp;&amp;dep[v]==dep[u]+1) &#123; int x=dfs(v,t,std::min(val[i],flow-ans)); if(x) val[i]-=x,val[i^1]+=x,ans+=x; &#125; &#125; if(ans&lt;flow) dep[u]=-1; return ans;&#125;int dinic(int s,int t) &#123; int ans=0; while(bfs(s,t)) &#123; int x; while((x=dfs(s,t,1&lt;&lt;30))) ans+=x; &#125; return ans;&#125;int main() &#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;s,&amp;t); while(m--) &#123; int u,v,w; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); addedge(u,v,w); &#125; printf("%d\n",dinic(s,t)); return 0;&#125; 方案我们可以通过从源点 $s$ 开始 $\text{DFS}$，每次走残量大于 $0$ 的边，找到所有 $S$ 点集内的点。 1234567void dfs(int u) &#123; vis[u]=1; for(int i=lnk[u];i;i=nxt[i]) &#123; int v=ter[i]; if(!vis[v]&amp;&amp;val[i]) dfs(v); &#125;&#125; 割边数量只需要将每条边的容量变为 $1$，然后重新跑 $\text{Dinic}$ 即可。 问题模型有 $n$ 个物品和两个集合 $A,B$，如果将一个物品放入 $A$ 集合会花费 $a_i$，放入 $B$ 集合会花费 $b_i$；还有若干个形如 $u_i,v_i,w_i$ 限制条件，表示如果 $u_i$ 和 $v_i$ 同时不在一个集合会花费 $w_i$。每个物品必须且只能属于一个集合，求最小的代价。 这是一个经典的二者选其一的最小割题目。我们对于每个集合设置源点 $s$ 和汇点 $t$，第 $i$ 个点由 $s$ 连一条容量为 $a_i$ 的边、向 $t$ 连一条容量为 $b_i$ 的边。对于限制条件 $u,v,w$，我们在 $u,v$ 之间连容量为 $w$ 的双向边。 注意到当源点和汇点不相连时，代表这些点都选择了其中一个集合。如果将连向 $s$ 或 $t$ 的边割开，表示不放在 $A$ 或 $B$ 集合，如果把物品之间的边割开，表示这两个物品不放在同一个集合。 最小割就是最小花费。 习题 「USACO 4.4」Pollutant Control 「USACO 5.4」Telecowmunication 「Luogu 1361」小 M 的作物 「SHOI 2007」善意的投票 网络流 24 题 「Luogu 1251」餐巾计划问题 「Luogu 2754」家园 「Luogu 2756」飞行员配对方案问题 「Luogu 2761」软件补丁问题 「Luogu 2762」太空飞行计划问题 「Luogu 2763」试题库问题 「Luogu 2764」最小路径覆盖问题 「Luogu 2765」魔术球问题 「Luogu 2766」最长不下降子序列问题 「Luogu 2770」航空路线问题 「Luogu 2774」方格取数问题 「Luogu 2775」机器人路径规划问题 「Luogu 3254」圆桌问题 「Luogu 3355」骑士共存问题 「Luogu 3356」火星探险问题 「Luogu 3357」最长k可重线段集问题 「Luogu 3358」最长k可重区间集问题 「Luogu 4009」汽车加油行驶问题 「Luogu 4011」孤岛营救问题 「Luogu 4012」深海机器人问题 「Luogu 4013」数字梯形问题 「Luogu 4014」分配问题 「Luogu 4015」运输问题 「Luogu 4016」负载平衡问题]]></content>
      <tags>
        <tag>算法笔记</tag>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SPOJ 839」OPTM - Optimal Marks]]></title>
    <url>%2Farticles%2Fproblem-SPOJ-839-OPTM%2F</url>
    <content type="text"><![CDATA[Description 题目链接：SPOJ 839 给你一个由 $n$ 个点和 $m$ 条边的无向图（保证没有重边与自环），每个点都有一个整数标记 $mark_i$。对于边 $(u,v)$，我们定义 $\text{cost}(u,v)=mark_u\oplus mark_v$（其中 $\oplus$ 表示异或），那么整张图的总花费为所有边的 $\text{cost}$ 之和。 现在有 $k$ 个点已经有标记了，你需要确定其他 $n-k$ 个点的标记，使得总花费最小。 本题 $T$ 组数据。 数据范围：$1\le T\le 10$，$0&lt;n\le 500$，$0\le m\le 3000$，$0\le mark_i&lt;2^{31}$ Solution这个异或直接处理不方便，难以转化为一般的运算。由于 $\text{XOR}$ 的运算是各个二进制位相互独立的，那么我们可以分别考虑每个位。 那么就有子问题：每个点的标记为 $0$ 或 $1$，要求最小化总花费。 注意到这张图可以被分为两个点集，对于一条边的两个端点，如果他们的值相同则没有贡献，否则对答案有 $1$ 的贡献。我们只要最小化这个贡献即可。于是问题等价于：我们要把这 $n$ 个点放入 $1$ 集合或者 $0$ 集合，连通这两个集合的边的权值和就是贡献和，我们需要最小化这个贡献，显然这是一个最小割模型。 考虑如何建图。首先对题目中给出的所有边建立无向边，容量都为 $1$。对于 $k$ 个已经有标记的点，如果当前二进制位为 $1$，那么向源点 $S$ 连一条容量为 $\text{INF}$ 的边；否则向汇点 $T$ 连一条容量为 $\text{INF}$ 的边（这些反向边的容量均为 $0$）。 接下来对这张图求最小割，割边显然都是原边。求得的最小割即为当前二进制位的最优解。考虑如何计算标记值，我们只要从 $S$ 开始遍历所有满流的边，这些点在当前二进制位上的值均为 $1$。 时间复杂度：$O(n^2m\log n)$（$\text{Dinic}$） Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;const int N=5e2+5,M=1e4+5;const int inf=1&lt;&lt;30;int n,m,k,tot,Gu[M],Gv[M],lnk[N],ter[M],nxt[M],val[M],dep[N],cnr[N],ans[N],node[N],mark[N];bool vis[N];void initGraph() &#123; tot=1,memset(lnk,0,sizeof(lnk)),memset(vis,0,sizeof(vis));&#125;void add(int u,int v,int w) &#123; ter[++tot]=v,nxt[tot]=lnk[u],lnk[u]=tot,val[tot]=w;&#125;void addedge(int u,int v,int w) &#123; add(u,v,w),add(v,u,0);&#125;int bfs(int s,int t) &#123; memset(dep,0,sizeof(dep)); memcpy(cnr,lnk,sizeof(lnk)); std::queue&lt;int&gt; q; q.push(s),dep[s]=1; while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=lnk[u];i;i=nxt[i]) &#123; int v=ter[i]; if(val[i]&amp;&amp;!dep[v]) q.push(v),dep[v]=dep[u]+1; &#125; &#125; return dep[t];&#125;int dfs(int u,int t,int flow) &#123; if(u==t) return flow; int ans=0; for(int i=cnr[u];i&amp;&amp;ans&lt;flow;i=nxt[i]) &#123; cnr[u]=i; int v=ter[i]; if(val[i]&amp;&amp;dep[v]==dep[u]+1) &#123; int x=dfs(v,t,std::min(val[i],flow-ans)); if(x) val[i]-=x,val[i^1]+=x,ans+=x; &#125; &#125; if(ans&lt;flow) dep[u]=-1; return ans;&#125;void dinic(int s,int t) &#123; while(bfs(s,t)) while(dfs(s,t,inf));&#125;void find(int u,int ret) &#123; vis[u]=1,ans[u]+=ret; for(int i=lnk[u];i;i=nxt[i]) if(val[i]&amp;&amp;!vis[ter[i]]) find(ter[i],ret);&#125;int main() &#123; int T; for(scanf("%d",&amp;T);T--;) &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;++i) scanf("%d%d",&amp;Gu[i],&amp;Gv[i]); memset(ans,0,sizeof(ans)); scanf("%d",&amp;k); for(int i=1;i&lt;=k;++i) scanf("%d%d",&amp;node[i],&amp;mark[i]); int S=0,T=n+1; for(int j=0;j&lt;31;++j) &#123; initGraph(); for(int i=1;i&lt;=m;++i) add(Gu[i],Gv[i],1),add(Gv[i],Gu[i],1); for(int i=1;i&lt;=k;++i) (mark[i]&amp;(1&lt;&lt;j))?addedge(S,node[i],inf):addedge(node[i],T,inf); dinic(S,T); find(S,1&lt;&lt;j); &#125; for(int i=1;i&lt;=n;++i) printf("%d\n",ans[i]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>最小割</tag>
        <tag>SPOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法笔记」网络流 - 最大流]]></title>
    <url>%2Farticles%2Falgorithm-Network-Flow-Maximum-Flow%2F</url>
    <content type="text"><![CDATA[最大流，指一张网络图中的最大流量。 网络流系列文章 最大流 最小割 费用流 有上下界的网络流（未学习） 概念网络流网络流是指给定一个有向图，其中有两个特殊的点：源点 $s$（Source）和汇点 $t$（Sink）；每条边都有一个指定的流量上限，下文均称之为容量（Capacity），即经过这条边的流量不能超过容量，这样的图被称为网络流图。同时，除了源点和汇点外，所有点的入流和出流都相等，源点只有流出的流，汇点只有流入的流，网络流就是从 $s$ 到 $t$ 的一个可行流。 可行流定义 $c(u,v)$ 表示边 $(u,v)$ 的容量，$f(u,v)$ 表示边 $(u,v)$ 的流量。如果满足 $0\le f(u,v)\le c(u,v)$，则称 $f(u,v)$ 为边 $(u,v)$ 上的流量。 如果有一组流量满足：源点 $s$ 的流出量等于整个网络的流量，汇点 $t$ 的流入量等于整个网络的流量，除了任意一个不是 $s$ 或 $t$ 的点的总流入量等于总流出量。那么整个网络中的流量被称为一个可行流。 最大流在所有可行流中，最大流指其中流量最大的一个流的流量。 定义我们定义（部分定义在上文有涉及）： 源点 $s$：只有流出量的点。 汇点 $t$：只有流入量的点。 容量 $c$：$c(u,v)$ 表示边 $(u,v)$ 上的容量。 流量 $f$：$f(u,v)$ 表示边 $(u,v)$ 上的流量。 残量 $w$：$w(u,v)$ 表示边 $(u,v)$ 上的残量（显然有 $w(u,v)=c(u,v)-f(u,v)$）。 性质容量限制对于任何一条边，都有 $0\le f(u,v)\le c(u,v)$。 斜对称性对于任何一条边，都有 $f(u,v)=-f(v,u)$。即从 $u$ 到 $v$ 的流量一定等于从 $v$ 到 $u$ 的流量的相反数。 流守恒性对于任何一个点 $u$，如果满足 $u\neq s$ 并且 $u\neq t$，那么一定有 $\sum f(u,v)=0$，即 $u$ 到相邻节点的流量之和为 $0$。因为 $u$ 本身不会制造和消耗流量。 求解増广路网络流的所有算法都基于増广路的思想，接下来首先介绍一下増广路思想。 找到一条从 $s$ 到 $t$ 的路径，使得路径上的每一条边都有 $w(u,v)&gt;0$ 即残量大于 $0$。注意：这里是严格 $&gt;$ 而不是 $\ge$，这意味着这条边还可以分配流量。这条路径就被叫做増广路。 找到这条路径上最小的 $w(u,v)$，记为 $flow$。将这条路径上的每一条边的 $w(u,v)$ 减去 $flow$。 重复上述过程，直到找不到増广路为止。 注意：其实上述方法并不是正确的，但这是一个非常重要的分析过程，因此请读者仔细阅读！ 我们可以根据这个过程在下面这张图中模拟一遍。 如果我们把每条边的的信息用残量 / 容量表示出来，可以得到下图： 假设我们第一次找到的増广路为 $1-2-3-4$，那么我们把这条路径上的边的 $w(u,v)$ 减去 $\min\{f(u,v)\}$ 即 $1$，得到下图： 然后呢……我们发现已经没有増广路了，此时算出来的“最大流”为 $1$！但是我们可以手动计算一下，这张图的最大流其实是 $2$！这个最大流的路径为 $1-2-4$（流量为 $1$）和 $1-3-4$（流量为 $1$）。 因此，我们可以发现这样的过程是错误的。原因就是増广路在一定意义上是有顺序的，说白了就是没有给它反悔的机会。所以我们要引入反向边的概念。 反向边改进通过上文的分析我们已经知道，当我们在寻找増广路的时候，找到的并不一定是最优解。如果我们对正向边的 $w(u,v)$ 减去 $flow$ 的同时，将对应的反向边的 $w(v,u)$ 加上 $flow$，我们就相当于可以反悔从这条边流过。 那么我们可以建立反向边，初始时每条边的 $w(u,v)=c(u,v)$，它的反向边的 $w(v,u)=0$（显然反向边不能有流量，因此残量为 $0$）。 接下来再看一下上面那个例子，我们只用 $w(u,v)$ 来表示每条边（包括反向边）的信息： 接下来开始寻找増广路，假如还是 $1-2-3-4$ 这条路径。 我们需要把 $w(1,2)$，$w(2,3)$，$w(3,4)$ 减少 $1$，同时把反向边的 $w(2,1)$，$w(3,2)$，$w(4,3)$ 增加 $1$。那么可以得到下图： 继续从 $s$ 开始寻找増广路（不需要考虑边的类型），显然可以发现路径 $1-3-2-4$，其中 $flow=1$。更新边的信息，得到下图： 此时我们发现没有増广路了，为了直观观察这个网络，我们去掉反向边，显然我们求出的最大流为 $2$！ 正确性当我们第二次増广边 $(2,3)$ 走这条反向边 $(3,2)$ 时，把 $(2,3)$ 和 $(3,2)$ 的流量抵消了，相当于把 $(2,3)$ 这条正向边的流量给退了回去使得可以不走 $(2,3)$ 这条边。 如果反向边 $(v,u)$ 的流量不能完全抵消正向边 $(u,v)$，那么意味着从 $u$ 开始还可以流一部分流量到 $v$，这样也是允许的。 小技巧如何快速找到反向边？如果使用邻接表存图，那么可以对边从 $2$ 开始编号，那么下标为 $i$ 的边的反向边就是 $i\ \text{XOR}\ 1$。 思路总结 最初这个网络的流量为 $0$，称为零流。 找到一条从 $s$ 到 $t$ 的路径，使得路径上的每一条边都有 $w(u,v)&gt;0$ 即残量大于 $0$。注意：这里是严格 $&gt;$ 而不是 $\ge$，这意味着这条边还可以分配流量。这条路径就被叫做増广路。 找到这条路径上最小的 $w(u,v)$，记为 $flow$。 将这条路径上的每一条边的 $w(u,v)$ 减去 $flow$，同时将反向边 $(v,u)$ 的 $w(v,u)$ 加上 $flow$。 重复上述过程，直到找不到増广路为止，此时的流量就是最大流。 这个算法基于増广路定理（Augmenting Path Theorem）：网络达到最大流当且仅当残留网络中没有増广路。然而我不会证明 QAQ 算法求最大流有若干种算法，此处介绍其中的两种：$\text{Edmonds-Karp}$ 和 $\text{Dinic}$。 Edmonds-Karp实现过程简称 $\text{EK}$ 算法，每次用 $\text{BFS}$ 求出一条増广路径，通过记录每个点的前驱和这条边的编号来记录下这条路径。可以说是对増广路思路的完全模拟。 但是 $\text{EK}$ 在某些情况下会被卡得很慢。假如有下面这张图： 其中 $w(u,v)=1$，其余正向边的 $w(u,v)=100$。如果第一次増广路的策略不恰当，找到了 $1-2-3-4$，那么 $w(2,3)=0$，$w(3,2)=1$。接下来又会找到増广路经 $1-3-2-4$，然后又是 $1-2-3-4$…… 然后显然最大流路径就是 $1-2-4$（流量为 $100$）和 $1-3-4$（流量为 $100$），但是如果策略不当，就会这样不断这样増广下去，导致复杂度会爆炸！ 复杂度$\text{EK}$ 算法的时间复杂度为 $O(nm^2)$。我们可以证明最多需要 $O(nm)$ 次増广可以达到最大流，每次増广的复杂度为 $O(m)$。绝大多数情况下这个复杂度都跑不满。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;const int N=1e4+5,M=2e5+5;int n,m,s,t,tot=1,lnk[N],ter[M],nxt[M],val[M],pre[N],idx[N];bool vis[N];void add(int u,int v,int w) &#123; ter[++tot]=v,nxt[tot]=lnk[u],lnk[u]=tot,val[tot]=w;&#125;bool bfs(int s,int t) &#123; memset(pre,0,sizeof(pre)); memset(vis,0,sizeof(vis)); std::queue&lt;int&gt; q; q.push(s),vis[s]=1; while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=lnk[u];i;i=nxt[i]) &#123; int v=ter[i]; if(!vis[v]&amp;&amp;val[i]) &#123; pre[v]=u,idx[v]=i,q.push(v),vis[v]=1; if(v==t) return 1; &#125; &#125; &#125; return 0;&#125;int EK(int s,int t) &#123; int ans=0; while(bfs(s,t)) &#123; int mn=1&lt;&lt;30; for(int i=t;i!=s;i=pre[i]) mn=std::min(mn,val[idx[i]]); for(int i=t;i!=s;i=pre[i]) &#123; int x=idx[i]; val[x]-=mn,val[x^1]+=mn; &#125; ans+=mn; &#125; return ans;&#125;int main() &#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;s,&amp;t); while(m--) &#123; int u,v,w; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); add(u,v,w),add(v,u,0); &#125; printf("%d\n",EK(s,t)); return 0;&#125; Dinic实现过程我们发现 $\text{EK}$ 在某些情况下会很低效，我们有另一个算法 $\text{Dinic}$。它引入了分层图的概念，具体的方法如下： 为了避免走重复的路径，从 $s$ 开始 $\text{BFS}$ 对图分层，将整个图分为若干层，其中 $s$ 是第 $1$ 层。如果一条边的残量为 $0$，那么忽略这条无法増广的边。如果 $t$ 的层数不为 $0$，那么意味着存在増广路径。 如果存在増广路，那么从 $s$ 开始进行 $\text{DFS}$ 寻找从源点到汇点的増广路，注意此处増广必须要按照图的层次来遍历。每次下传当前流量 $flow$（初始流量认为是无穷大）。 设 $dep_i$ 表示 $i$ 的层次，$ans$ 代表当前从 $u$ 可以流的流量，对于当前点 $u$ 相连的点 $v$，如果 $dep_v=dep_u+1$ 并且 $w(u,v)&gt;0$，那么可以増广。此时下传的 $flow$ 应为 $\min(w(u,v),flow-ans)$，其中 $flow-ans$ 代表从 $u$ 还可以流的流量（已经有 $ans$ 的流量从 $v’$ 流出去了）。当 $ans\ge flow$ 时意味着没有可以流的流量了，应该退出増广。 如果该 $\text{DFS}$ 找到的可以増广的流量为 $0$，表示增广失败，跳过这条边。否则将 $w(u,v)$ 减去増广的流量，将 $w(v,u)$ 和 $ans$ 加上相同的值。 小剪枝：如果遍历完所有的 $v$ 后 $ans&lt;flow$，意味着已经从 $u$ 流出了所有可以増广的流量，即 $u$ 已经满流了，此时需要将 $dep_u$ 设为 $-1$，防止再次从这个点増广。 优化$\text{Dinic}$ 算法还有一个优化，被称为当前弧优化，即每次 $\text{DFS}$ 増广时不是从 $u$ 出发的第 $1$ 个点开始，而是用一个 $cnr$ 数组记录点 $u$ 増广到了哪条边，从这条边开始増广，以此来进一步加速。 复杂度$\text{Dinic}$ 算法的时间复杂度为 $O(n^2m)$。我们可以证明最多需要建立 $O(n)$ 个层次图，每次建立层次图的复杂度为 $O(m)$。接下来分析 $\text{DFS}$ 的复杂度，每次最多増广 $O(m)$ 次，每次修改流量的复杂度为 $O(n)$，所以 $\text{DFS}$ 的复杂度为 $O(nm)$。再加上 $O(n)$ 个层次图，总复杂度为 $O(n^2m)$。绝大多数情况下这个复杂度都跑不满。 对于 $\text{Dinic}$ 算法的复杂度，有如下 $3$ 种情况： 一般的网络图：$O(n^2m)$ 单位容量的图：$O(\min(\sqrt m,n^{\frac{2}{3}})\cdot m)$ 二分图：$O(m\sqrt n)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;const int N=1e4+5,M=2e5+5;int n,m,s,t,tot=1,lnk[N],ter[M],nxt[M],val[M],dep[N],cnr[N];void add(int u,int v,int w) &#123; ter[++tot]=v,nxt[tot]=lnk[u],lnk[u]=tot,val[tot]=w;&#125;void addedge(int u,int v,int w) &#123; add(u,v,w),add(v,u,0);&#125;int bfs(int s,int t) &#123; memset(dep,0,sizeof(dep)); memcpy(cnr,lnk,sizeof(lnk)); std::queue&lt;int&gt; q; q.push(s),dep[s]=1; while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=lnk[u];i;i=nxt[i]) &#123; int v=ter[i]; if(val[i]&amp;&amp;!dep[v]) q.push(v),dep[v]=dep[u]+1; &#125; &#125; return dep[t];&#125;int dfs(int u,int t,int flow) &#123; if(u==t) return flow; int ans=0; for(int i=cnr[u];i&amp;&amp;ans&lt;flow;i=nxt[i]) &#123; cnr[u]=i; int v=ter[i]; if(val[i]&amp;&amp;dep[v]==dep[u]+1) &#123; int x=dfs(v,t,std::min(val[i],flow-ans)); if(x) val[i]-=x,val[i^1]+=x,ans+=x; &#125; &#125; if(ans&lt;flow) dep[u]=-1; return ans;&#125;int dinic(int s,int t) &#123; int ans=0; while(bfs(s,t)) &#123; int x; while((x=dfs(s,t,1&lt;&lt;30))) ans+=x; &#125; return ans;&#125;int main() &#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;s,&amp;t); while(m--) &#123; int u,v,w; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); addedge(u,v,w); &#125; printf("%d\n",dinic(s,t)); return 0;&#125; 习题 「Luogu 3376」【模板】网络最大流 「Luogu 4722」【模板】最大流 加强版 / 预流推进 「Luogu 1231」教辅的组成 网络流 24 题 「Luogu 1251」餐巾计划问题 「Luogu 2754」家园 「Luogu 2756」飞行员配对方案问题 「Luogu 2761」软件补丁问题 「Luogu 2762」太空飞行计划问题 「Luogu 2763」试题库问题 「Luogu 2764」最小路径覆盖问题 「Luogu 2765」魔术球问题 「Luogu 2766」最长不下降子序列问题 「Luogu 2770」航空路线问题 「Luogu 2774」方格取数问题 「Luogu 2775」机器人路径规划问题 「Luogu 3254」圆桌问题 「Luogu 3355」骑士共存问题 「Luogu 3356」火星探险问题 「Luogu 3357」最长k可重线段集问题 「Luogu 3358」最长k可重区间集问题 「Luogu 4009」汽车加油行驶问题 「Luogu 4011」孤岛营救问题 「Luogu 4012」深海机器人问题 「Luogu 4013」数字梯形问题 「Luogu 4014」分配问题 「Luogu 4015」运输问题 「Luogu 4016」负载平衡问题]]></content>
      <tags>
        <tag>算法笔记</tag>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 1029F」Multicolored Markers]]></title>
    <url>%2Farticles%2Fproblem-Codeforces-1029F-Multicolored-Markers%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Codeforces 1029F 有一个由正方形砖块组成的板子（你可以认为是无限大的），你需要将 $a$ 个格子染成红色，$b$ 个格子染成蓝色。最终有颜色的砖块要形成一个大小为 $a+b$ 的矩形，并且其中至少有一种颜色也需要形成一个矩形。求出所有染色方案中，有颜色的砖块组成的矩形的周长最小值。 数据范围：$1\le a,b\le 10^{14}$ Solution我们可以发现，如果忽略染色的情况，那么矩形的形态总共有 $O(\sqrt{a+b})$ 个。对于这个数据范围，我们显然可以枚举矩形的较短边的长度 $i$。根据贪心的思路，我们从大到小枚举，遇到第一个满足条件的 $i$ 就可以得到最优解 $2\times(i+\frac{a+b}{i})​$。 接下来的问题就是如何判断是否可以将某一种颜色形成一个矩形。此时我们也可以贪心，假设需要染成矩形的颜色有 $a$ 个，那么我们找到最大的 $j$ 满足 $j\le i$ 并且 $j\mid a$。如果 $\frac{a}{j}\le \frac{a+b}{i}$ 那么就说明满足条件。 我们又可以发现这个 $j$ 是单调的，所以可以 $O(\sqrt a)$ 求出 $a$ 的因子，直接用一个指针移动就能找到当前最大的 $j$ 了。 时间复杂度：$O(\sqrt a)$ Code123456789101112131415161718192021#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;long long solve(long long tot,long long a) &#123; std::vector&lt;int&gt; f; for(int i=1;1LL*i*i&lt;=a;++i) if(a%i==0) f.push_back(i); int p=(int)f.size()-1; for(int i=sqrt(tot);i&gt;=1;--i) &#123; if(tot%i) continue; while(f[p]&gt;i) --p; if(a/f[p]&lt;=tot/i) return 2LL*(i+tot/i); &#125; return 1LL&lt;&lt;60;&#125;int main() &#123; long long n,m; scanf("%lld%lld",&amp;n,&amp;m); printf("%lld\n",std::min(solve(n+m,n),solve(n+m,m))); return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SPOJ 375」QTREE - Query on a tree]]></title>
    <url>%2Farticles%2Fproblem-SPOJ-375-QTREE%2F</url>
    <content type="text"><![CDATA[Description 题目链接：SPOJ 375 给定一棵 $n$ 个节点的树，边按照输入顺序编号为 $1\sim n-1$，每条边都有一个权值 $c_i$ 需要对这棵树进行若干次操作，操作分为 $2$ 种： CHANGE i t：将第 $i$ 条边的权值 $c_i$ 修改为 $t$ QUERY a b：询问从节点 $a$ 到 $b$ 的路径上的边权最大值。 询问以 DONE 结束，有 $T$ 组数据。 数据范围：$T\le 20$，$n\le10^4$，$c_i,t\le 10^6$ Solution对于这类树的题目，我们首先可以想到用树链剖分维护。而这题需要维护的边的信息，那么我们可以把每条边的信息放在较深的节点上，就转化成了维护点的信息了。 但是这样做需要注意一个问题：每次查询时，$\text{LCA}$ 的节点维护的信息是它上方的边，因此这个点不能被查询到。如何解决？我们根据树剖的性质可以发现以下方法：记 $x$ 的 $\text{DFS}$ 序为 $d_x$，那么最后查询 $u,v$ 的信息时（这里令 $u$ 的深度比 $v$ 浅），我们可以发现 $u$ 一定是 $\text{LCA}$，所以只要查询 $d_u+1,d_v$ 就可以避开 $\text{LCA}$ 了。 时间复杂度：$O(n\log^2 n)$（这里认为操作次数和 $n$ 同阶） Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define lson rt&lt;&lt;1#define rson rt&lt;&lt;1|1inline char nc() &#123; static char buf[1000000],*p1=buf,*p2=buf; return p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++;&#125;template &lt;class Tp&gt; inline void read(register Tp &amp;s) &#123; s=0; register bool neg=0; register char c=nc(); for(;c&lt;'0'||c&gt;'9';c=nc()) neg|=(c=='-'); for(;c&gt;='0'&amp;&amp;c&lt;='9';s=s*10+(c^48),c=nc()); s=(neg?-s:s);&#125;const int N=1e5+5,M=2e5+5;int n,idx,dfn[N],seq[N],U[N],V[N],W[N],val[N],fa[N],dep[N],top[N],sz[N],hvy[N];int tot,lnk[N],ter[M],nxt[M],wei[M],seg[N&lt;&lt;2];void add(int u,int v,int w) &#123; ter[++tot]=v,wei[tot]=w,nxt[tot]=lnk[u],lnk[u]=tot;&#125;void dfs1(int u,int f) &#123; fa[u]=f,dep[u]=dep[f]+1,sz[u]=1,hvy[u]=top[u]=0; for(int i=lnk[u];i;i=nxt[i]) &#123; int v=ter[i]; if(v==f) continue; val[v]=wei[i]; dfs1(v,u); sz[u]+=sz[v]; if(sz[hvy[u]]&lt;sz[v]) hvy[u]=v; &#125;&#125;void dfs2(int u,int tp) &#123; dfn[u]=++idx,seq[idx]=u,top[u]=tp; if(!hvy[u]) return; dfs2(hvy[u],tp); for(int i=lnk[u];i;i=nxt[i]) &#123; int v=ter[i]; if(v==fa[u]||v==hvy[u]) continue; dfs2(v,v); &#125;&#125;void pushup(int rt) &#123; seg[rt]=std::max(seg[lson],seg[rson]);&#125;void build(int rt,int l,int r) &#123; if(l==r) &#123; seg[rt]=val[seq[l]]; return; &#125; int mid=(l+r)&gt;&gt;1; build(lson,l,mid); build(rson,mid+1,r); pushup(rt);&#125;void modify(int x,int rt,int l,int r,int val) &#123; if(l==r) &#123; seg[rt]=val; return; &#125; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) modify(x,lson,l,mid,val); else modify(x,rson,mid+1,r,val); pushup(rt);&#125;int query(int x,int y,int rt,int l,int r) &#123; if(x&gt;y) return 0; if(x&lt;=l&amp;&amp;r&lt;=y) return seg[rt]; int mid=(l+r)&gt;&gt;1,res=0; if(x&lt;=mid) res=std::max(res,query(x,y,lson,l,mid)); if(mid&lt;y) res=std::max(res,query(x,y,rson,mid+1,r)); return res;&#125;int chainQuery(int u,int v) &#123; if(u==v) return 0; int res=0; for(int fu=top[u],fv=top[v];fu^fv;u=fa[fu],fu=top[u]) &#123; if(dep[fu]&lt;dep[fv]) std::swap(u,v),std::swap(fu,fv); res=std::max(res,query(dfn[fu],dfn[u],1,1,n)); &#125; if(dep[u]&gt;dep[v]) std::swap(u,v); res=std::max(res,query(dfn[u]+1,dfn[v],1,1,n)); return res;&#125;int main() &#123; int T; for(read(T);T--;) &#123; read(n); idx=tot=0,memset(lnk,0,sizeof(lnk)); for(int i=1;i&lt;n;++i) &#123; int u,v,w; read(u),read(v),read(w); add(u,v,w),add(v,u,w); U[i]=u,V[i]=v,W[i]=w; &#125; dfs1(1,0),dfs2(1,1),build(1,1,n); while(1) &#123; char c=nc(); while(c&lt;'A'||c&gt;'Z') c=nc(); if(c=='D') break; int x,y; read(x),read(y); if(c=='C') &#123; int u=U[x],v=V[x]; if(fa[v]==u) std::swap(u,v); modify(dfn[u],1,1,n,y); &#125; else &#123; printf("%d\n",chainQuery(x,y)); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>SPOJ</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu 1231」教辅的组成]]></title>
    <url>%2Farticles%2Fproblem-Luogu-1231-Composition-of-Book%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Luogu 1231 HansBug 眼前有 $n_1$ 本书，$n_2$ 本练习册，$n_3$ 本答案。已知一个完整的书册均应该包含且仅包含一本书、一本练习册、一本答案。现在 HansBug 只知道 $m_1$ 个可能的书和练习册的对应关系，$m_2$ 个可能的书和答案的对应关系。HansBug 想知道在这样的情况下，最多可能同时组合成多少个完整的书册。 数据范围：$n_1,n_2,n_3\le 10^4$，$m_1,m_2\le 2\times 10^4$ Solution首先我们可以发现这就是一个网络流的模型。于是顺手把 $n_1+n_2+n_3$ 个点分成 $3$ 个部分，建立源点和汇点后跑最大流。写完才发现这样是有漏洞的，如下图所示： 我们发现，如果按照上图跑最大流答案肯定是 $2$，而错误的原因就是书被重复使用了多次！所以我们还要保证每本书只能被使用一次！ 因此我们就要引入拆点的思想。我们的目的是：即使一本书与多个联系册有关系，它流出的流量也只能是 $1$。所以我们把每个代表书的点拆成左右两个点，左边的点和练习册连边，右边的点和答案连边；当然左右对应点也要连一条容量为 $1$ 的边。那么我们可以得到下图： 这样我们的答案就正确了，于是直接拆点后再跑最大流即可！ 时间复杂度：$O(n^2m)$（$\text{Dinic}$） Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;const int N=4e4+5,M=1e6+5;int n1,n2,n3,m,tot=1,lnk[N],ter[M],nxt[M],val[M],dep[N],cnr[N];int id(int p,int x) &#123; switch(p) &#123; case 1: return x; case 2: return n2+x; case 3: return n2+n1+x; case 4: return n2+n1+n1+x; &#125;&#125;void add(int u,int v,int w) &#123; ter[++tot]=v,nxt[tot]=lnk[u],lnk[u]=tot,val[tot]=w;&#125;void addedge(int u,int v,int w) &#123; add(u,v,w),add(v,u,0);&#125;int bfs(int s,int t) &#123; memset(dep,0,sizeof(dep)); memcpy(cnr,lnk,sizeof(lnk)); std::queue&lt;int&gt; q; q.push(s),dep[s]=1; while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=lnk[u];i;i=nxt[i]) &#123; int v=ter[i]; if(!dep[v]&amp;&amp;val[i]) dep[v]=dep[u]+1,q.push(v); &#125; &#125; return dep[t];&#125;int dfs(int u,int t,int flow) &#123; if(u==t) return flow; int ans=0; for(int i=cnr[u];i&amp;&amp;ans&lt;flow;i=nxt[i]) &#123; cnr[u]=i; int v=ter[i]; if(val[i]&amp;&amp;dep[v]==dep[u]+1) &#123; int x=dfs(v,t,std::min(val[i],flow-ans)); if(x) val[i]-=x,val[i^1]+=x,ans+=x; &#125; &#125; if(ans&lt;flow) dep[u]=-1; return ans;&#125;int dinic(int s,int t) &#123; int ans=0; while(bfs(s,t)) &#123; int x; while((x=dfs(s,t,1&lt;&lt;30))) ans+=x; &#125; return ans;&#125;int main() &#123; scanf("%d%d%d",&amp;n1,&amp;n2,&amp;n3); for(scanf("%d",&amp;m);m--;) &#123; int u,v; scanf("%d%d",&amp;u,&amp;v); addedge(id(1,v),id(2,u),1); &#125; for(scanf("%d",&amp;m);m--;) &#123; int u,v; scanf("%d%d",&amp;u,&amp;v); addedge(id(3,u),id(4,v),1); &#125; for(int i=1;i&lt;=n1;++i) addedge(id(2,i),id(3,i),1); int S=0,T=n2+n1+n1+n3+1; for(int i=1;i&lt;=n2;++i) addedge(S,id(1,i),1); for(int i=1;i&lt;=n3;++i) addedge(id(4,i),T,1); printf("%d\n",dinic(S,T)); return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 4810」由乃的玉米田]]></title>
    <url>%2Farticles%2Fproblem-BZOJ-4810-Corn-Field%2F</url>
    <content type="text"><![CDATA[Description 题目链接：BZOJ 4810 给你一个长度为 $n$ 的序列 $a_i$，有 $m$ 次操作，操作分为以下 $3$ 种： 1 l r x：询问能否在区间 $[l,r]$ 内选出两个数使得它们的差为 $x$。 2 l r x：询问能否在区间 $[l,r]$ 内选出两个数使得它们的和为 $x$。 3 l r x：询问能否在区间 $[l,r]$ 内选出两个数使得它们的积为 $x$。 如果可以，输出 yuno，否则输出 yumi。 数据范围：$n,m,a_i\le 10^5$ Solution由于没有修改操作，区间又没法用数据结构维护，我们可以考虑莫队。 现在把询问离线下来了，我们要考虑的就是如何利用已知信息求解。注意到 $a_i$ 的范围很小，所以我们可以用 $\text{bitset}$ 来记录每个数是否出现过。 设满足条件的两个数为 $x,y$，给出的值为 $k$，我们对三种操作分类讨论。 操作 1我们对 $x-y=k$ 变形为 $y=x-k$，那么如果 $x,y$ 存在当且仅当存在 $x$ 和 $x-k$。因此我们可以用一个 $\text{bitset}$（假设为 $f$）维护是否有 $i$ 这个数，判定方法为 $f\ \&amp;\ (f&lt;&lt;x)$。 操作 2依旧对 $x+y=k$ 进行变形，得到 $y=-x+k$。但是注意到此处等式右边的 $x$ 为负，没法直接用 $\text{bitset}$ 维护。所以我们令 $x’=N-x$（$N$ 为 $a_i$ 的最大值），那么我们用另一个 $\text{bitset}$（假设为 $g$）维护是否有 $N-i$ 这个数，那么等式转化为 $y=N-(-x+k)=N+x-k$ 即 $f$ 中有 $x$，$g$ 中有 $N+x-k$，判定方法为 $f\ \&amp;\ (g&gt;&gt;(N-k))$。 操作 3如果直接枚举因子，复杂度为 $O(n\sqrt n)$，但是莫队的复杂度也是 $O(n\sqrt n)$，因此不会带来额外的复杂度。所以操作 $3$ 中只要大力枚举 $k$ 的因子，在 $f$ 中查找即可。判定方法为 $f[d]\ \text{AND}\ f[\frac{k}{d}]$（其中 $k\bmod d=0$）。 时间复杂度：$O(n\sqrt n)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;bitset&gt;const int N=1e5;int n,m,a[N+5],b[N+5],cnt[N+5];bool ans[N+5];std::bitset&lt;N+5&gt; f1,f2;struct ques &#123; int opt,l,r,k,id; bool operator &lt; (const ques &amp;rhs) const &#123; return b[l]==b[rhs.l]?r&lt;rhs.r:l&lt;rhs.l; &#125;&#125;q[N+5];void add(int x) &#123; if(++cnt[x]==1) f1[x]=f2[N-x]=1;&#125;void del(int x) &#123; if(--cnt[x]==0) f1[x]=f2[N-x]=0;&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); int len=sqrt(n); for(int i=1;i&lt;=n;++i) scanf("%d",&amp;a[i]),b[i]=(i-1)/len+1; for(int i=1;i&lt;=m;++i) scanf("%d%d%d%d",&amp;q[i].opt,&amp;q[i].l,&amp;q[i].r,&amp;q[i].k),q[i].id=i; std::sort(q+1,q+m+1); for(int l=1,r=0,i=1;i&lt;=m;++i) &#123; int x=q[i].l,y=q[i].r,k=q[i].k; while(x&lt;l) add(a[--l]); while(x&gt;l) del(a[l++]); while(y&lt;r) del(a[r--]); while(y&gt;r) add(a[++r]); if(q[i].opt==1) &#123; ans[q[i].id]=(f1&amp;(f1&lt;&lt;k)).any(); &#125; else if(q[i].opt==2) &#123; ans[q[i].id]=(f1&amp;(f2&gt;&gt;(N-k))).any(); &#125; else &#123; for(int d=1;d*d&lt;=k;++d) if(k%d==0&amp;&amp;f1[d]&amp;&amp;f1[k/d]) &#123;ans[q[i].id]=1;break;&#125; &#125; &#125; for(int i=1;i&lt;=m;++i) puts(ans[i]?"yuno":"yumi"); return 0;&#125;]]></content>
      <tags>
        <tag>莫队</tag>
        <tag>BZOJ</tag>
        <tag>bitset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SPOJ 6779」GSS7 - Can you answer these queries VII]]></title>
    <url>%2Farticles%2Fproblem-SPOJ-6779-GSS7%2F</url>
    <content type="text"><![CDATA[Description 题目链接：SPOJ 6779 给你一棵有 $n$ 个节点的树，每个点有一个权值 $x_i$。接下来有 $Q$ 个操作，操作分为以下 $2$ 种： 1 a b：求出 $a$ 到 $b$ （包括 $a$ 和 $b$）这条路径上的权值组成的序列的最大子段和（可以为空）。 2 a b c：将 $a$ 到 $b$（包括 $a$ 和 $b$）的路径上的所有点的权值改为 $c$。 数据范围：$n,Q\le 10^5$，$|x_i|,|c|\le 10^4$ Solution我们可以用树链剖分来维护这棵树，修改时直接在线段树上覆盖。询问时，我们根据树链剖分的过程，可以发现只不过是把这条链拆成了若干段，那么我们可以对这几段依次查询、维护、更新答案。 关于如何用线段树维护序列的最大子段和（这个方法很套路），详见「SPOJ 1716」GSS3 - Can you answer these queries III。 时间复杂度：$O(Q\log^2 n)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define lson rt&lt;&lt;1#define rson rt&lt;&lt;1|1const int N=1e5+5,M=2e5+5;int n,q,tot,x[N],lnk[N],ter[M],nxt[M];int idx,dfn[N],seq[N],sz[N],dep[N],hvy[N],top[N],fa[N];struct Node &#123; int sum,lmx,rmx,ret,tag; bool cov; Node() &#123;sum=lmx=rmx=ret=0;&#125;&#125;seg[N&lt;&lt;2];void add(int u,int v) &#123; ter[++tot]=v,nxt[tot]=lnk[u],lnk[u]=tot;&#125;void dfs1(int u,int f) &#123; dep[u]=dep[f]+1,fa[u]=f,sz[u]=1; for(int i=lnk[u];i;i=nxt[i]) &#123; int v=ter[i]; if(v==f) continue; dfs1(v,u); sz[u]+=sz[v]; if(sz[v]&gt;sz[hvy[u]]) hvy[u]=v; &#125;&#125;void dfs2(int u,int tp) &#123; dfn[u]=++idx,seq[idx]=u,top[u]=tp; if(!hvy[u]) return; dfs2(hvy[u],tp); for(int i=lnk[u];i;i=nxt[i]) &#123; int v=ter[i]; if(v==fa[u]||v==hvy[u]) continue; dfs2(v,v); &#125;&#125;Node merge(Node x,Node y) &#123; Node ans; ans.sum=x.sum+y.sum; ans.lmx=std::max(x.lmx,x.sum+y.lmx); ans.rmx=std::max(y.rmx,y.sum+x.rmx); ans.ret=std::max(std::max(x.ret,y.ret),x.rmx+y.lmx); ans.tag=ans.cov=0; return ans;&#125;void build(int rt,int l,int r) &#123; if(l==r) &#123; seg[rt].sum=x[seq[l]]; seg[rt].lmx=seg[rt].rmx=seg[rt].ret=std::max(seg[rt].sum,0); seg[rt].cov=0; return; &#125; int mid=(l+r)&gt;&gt;1; build(lson,l,mid); build(rson,mid+1,r); seg[rt]=merge(seg[lson],seg[rson]);&#125;void update(int rt,int l,int r,int k) &#123; seg[rt].sum=(r-l+1)*k; seg[rt].lmx=seg[rt].rmx=seg[rt].ret=std::max(seg[rt].sum,0); seg[rt].cov=1,seg[rt].tag=k;&#125;void pushdown(int rt,int l,int r) &#123; if(!seg[rt].cov) return; int mid=(l+r)&gt;&gt;1; update(lson,l,mid,seg[rt].tag); update(rson,mid+1,r,seg[rt].tag); seg[rt].tag=seg[rt].cov=0;&#125;void modify(int x,int y,int rt,int l,int r,int k) &#123; if(x&lt;=l&amp;&amp;r&lt;=y) &#123; update(rt,l,r,k); return; &#125; pushdown(rt,l,r); int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) modify(x,y,lson,l,mid,k); if(mid&lt;y) modify(x,y,rson,mid+1,r,k); seg[rt]=merge(seg[lson],seg[rson]);&#125;Node query(int x,int y,int rt,int l,int r) &#123; if(x&lt;=l&amp;&amp;r&lt;=y) return seg[rt]; pushdown(rt,l,r); int mid=(l+r)&gt;&gt;1; Node L,R; if(x&lt;=mid) L=query(x,y,lson,l,mid); if(mid&lt;y) R=query(x,y,rson,mid+1,r); return merge(L,R);&#125;void chainModify(int u,int v,int k) &#123; for(int fu=top[u],fv=top[v];fu^fv;u=fa[fu],fu=top[u]) &#123; if(dep[fu]&lt;dep[fv]) std::swap(u,v),std::swap(fu,fv); modify(dfn[fu],dfn[u],1,1,n,k); &#125; if(dep[u]&gt;dep[v]) std::swap(u,v); modify(dfn[u],dfn[v],1,1,n,k);&#125;Node chainQuery(int u,int v) &#123; Node L,R; for(int fu=top[u],fv=top[v];fu^fv;) &#123; if(dep[fu]&lt;dep[fv]) &#123; R=merge(query(dfn[fv],dfn[v],1,1,n),R); v=fa[fv],fv=top[v]; &#125; else &#123; L=merge(query(dfn[fu],dfn[u],1,1,n),L); u=fa[fu],fu=top[u]; &#125; &#125; if(dep[u]&gt;dep[v]) &#123; L=merge(query(dfn[v],dfn[u],1,1,n),L); &#125; else &#123; R=merge(query(dfn[u],dfn[v],1,1,n),R); &#125; std::swap(L.lmx,L.rmx); return merge(L,R);&#125;int main() &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;++i) scanf("%d",&amp;x[i]); for(int i=1;i&lt;n;++i) &#123; int u,v; scanf("%d%d",&amp;u,&amp;v); add(u,v),add(v,u); &#125; dfs1(1,0),dfs2(1,1),build(1,1,n); scanf("%d",&amp;q); while(q--) &#123; int opt; scanf("%d",&amp;opt); if(opt==1) &#123; int l,r; scanf("%d%d",&amp;l,&amp;r); printf("%d\n",chainQuery(l,r).ret); &#125; else &#123; int l,r,k; scanf("%d%d%d",&amp;l,&amp;r,&amp;k); chainModify(l,r,k); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>SPOJ</tag>
        <tag>最大子段和</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 916E」Jamie and Tree]]></title>
    <url>%2Farticles%2Fproblem-Codeforces-916E-Jamie-and-Tree%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Codeforces 916E 给你一棵有根树标号为 $1\sim n$，每个点都有一个权值 $a_i$。初始时根为 $1$，接下来有 $q$ 次操作，操作分为以下 $3$ 种： 1 x：将整棵树的根变为节点 $x$。 2 x y k：把 $x,y$ 的 $\text{LCA}$ 为根的子树中的所有点的权值增加 $k$。 3 x：查询以 $x$ 为根的子树中的节点的权值和。 数据范围：$1\le n,q\le 10^5$，$-10^8\le a_i,k\le 10^8$ Solution如果没有换根操作，那么我们只需要对这棵树的 $\text{DFS}$ 序建立线段树，支持区间修改和区间查询。 接下来考虑换根操作。此时我们显然不能真的把根换掉，根只能一直为 $1$ 节点，而是要对根和操作的节点的关系进行分类讨论！ 由于操作 $2$ 和操作 $3$ 在位置关系分析上的本质是相同的，所以我们只需要考虑位置关系和如何求 LCA 即可。 位置关系设当前整棵树的根节点为 $R$，询问的子树根节点为 $X$，那么我们可以发现这两者存在以下 $3$ 种关系。 对于每种位置关系的图示，$R$ 和 $X$ 均标记在节点上，蓝色的节点表示需要被操作的节点。 如果 $R$ 就是 $X$： 此时整棵树的所有节点都需要被操作。 如果 $R$ 不在 $X$ 的子树内： 此时我们可以发现 $X$ 这棵子树的形态与原图的形态一致，所以只要对以 $1$ 为根节点时的子树 $X$ 进行操作即可。 如果 $R$ 位于 $X$ 的子树内： 此时情况比较复杂，需要被操作的节点为： 所有节点除去以 $X$ 到 $R$ 的路径上的第一个节点（这个点满足既是 $R$ 的祖先，又是 $X$ 的儿子）为根的子树。那么我们可以根据容斥原理，先对整棵树进行操作，再对那个子树进行相反的操作（如果是查询则减去贡献，如果是修改则减去）。 那么怎么求这个点呢？我们记 $deep_i$ 表示 $i$ 在原图中的深度，让 $R$ 往上移动 $deep_R-deep_X-1$ 个点即可，这个过程显然可以用倍增实现。 如何求 LCA其实也是之前的分类讨论的套路啦！QAQ 设当前整棵树的根节点为 $r$，修改的节点为 $x,y$。在以 $1$ 为根节点的前提下，我们也可以分类讨论！（以下内容参考 $\text{Codeforces}$ 官方题解） 如果 $x,y$ 都在 $r$ 的子树内，那么 $\text{LCA}$ 显然为 $\text{LCA}(x,y)$。 如果 $x,y$ 只有一个在 $r$ 的子树内，那么 $\text{LCA}$ 肯定为 $r$。 如果 $x,y$ 都不在 $r$ 的子树内，我们可以先找到 $p=\text{LCA}(x,r)$，$q=\text{LCA}(y,r)$。如果 $p$ 和 $q$ 不相同，那么我们选择其中较深的一个；如果 $p$ 和 $q$ 相同，那么 $\text{LCA}$ 就是 $p$ 或 $q$。 综上所述，我们可以发现我们要求的 $\text{LCA}$ 就是 $\text{LCA}(x,y)$，$\text{LCA}(x,r)$，$\text{LCA}(y,r)$ 这三者中深度最大的！ 时间复杂度：$O(n\log n)$（当然带着巨大常数） Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define lson rt&lt;&lt;1#define rson rt&lt;&lt;1|1const int N=1e5+5,M=2e5+5,logN=17+1;int n,m,root,idx,a[N],f[N][logN],dfn[N],seq[N],sz[N],dep[N];int tot,lnk[N],ter[M],nxt[M];long long seg[N&lt;&lt;2],tag[N&lt;&lt;2];void pushup(int rt) &#123; seg[rt]=seg[lson]+seg[rson];&#125;void build(int rt,int l,int r) &#123; if(l==r) &#123; seg[rt]=a[seq[l]]; return; &#125; int mid=(l+r)&gt;&gt;1; build(lson,l,mid); build(rson,mid+1,r); pushup(rt);&#125;void update(int rt,int l,int r,long long k) &#123; seg[rt]+=1LL*(r-l+1)*k; tag[rt]+=k;&#125;void pushdown(int rt,int l,int r) &#123; if(!tag[rt]) return; int mid=(l+r)&gt;&gt;1; update(lson,l,mid,tag[rt]); update(rson,mid+1,r,tag[rt]); tag[rt]=0;&#125;void modify(int x,int y,int rt,int l,int r,int k) &#123; if(x&lt;=l&amp;&amp;r&lt;=y) &#123; update(rt,l,r,k); return; &#125; pushdown(rt,l,r); int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) modify(x,y,lson,l,mid,k); if(mid&lt;y) modify(x,y,rson,mid+1,r,k); pushup(rt);&#125;long long query(int x,int y,int rt,int l,int r) &#123; if(x&lt;=l&amp;&amp;r&lt;=y) return seg[rt]; pushdown(rt,l,r); int mid=(l+r)&gt;&gt;1; long long ret=0; if(x&lt;=mid) ret+=query(x,y,lson,l,mid); if(mid&lt;y) ret+=query(x,y,rson,mid+1,r); return ret;&#125;void add(int u,int v) &#123; ter[++tot]=v,nxt[tot]=lnk[u],lnk[u]=tot;&#125;void dfs(int u,int fa) &#123; dep[u]=dep[fa]+1,f[u][0]=fa,dfn[u]=++idx,seq[idx]=u,sz[u]=1; for(int i=1;(1&lt;&lt;i)&lt;=dep[u];++i) f[u][i]=f[f[u][i-1]][i-1]; for(int i=lnk[u];i;i=nxt[i]) &#123; int v=ter[i]; if(v==fa) continue; dfs(v,u),sz[u]+=sz[v]; &#125;&#125;int lca(int u,int v) &#123; if(dep[u]&gt;dep[v]) u^=v^=u^=v; for(int i=17;~i;--i) if(dep[f[v][i]]&gt;=dep[u]) v=f[v][i]; if(u==v) return u; for(int i=17;~i;--i) if(f[u][i]^f[v][i]) u=f[u][i],v=f[v][i]; return f[u][0];&#125;int getlca(int u,int v,int p) &#123; int x=lca(u,v),y=lca(u,p),z=lca(v,p); if(dep[y]&gt;dep[x]) x=y; if(dep[z]&gt;dep[x]) x=z; return x;&#125;int jump(int u,int d) &#123; for(int i=17;~i;--i) if(d&amp;(1&lt;&lt;i)) u=f[u][i]; return u;&#125;void treeModify(int u,int k) &#123; int l=dfn[u],r=dfn[u]+sz[u]-1; if(u==root) modify(1,n,1,1,n,k); else if(dfn[root]&lt;l||dfn[root]&gt;r) modify(l,r,1,1,n,k); else &#123; int son=jump(root,dep[root]-dep[u]-1); modify(1,n,1,1,n,k),modify(dfn[son],dfn[son]+sz[son]-1,1,1,n,-k); &#125;&#125;long long treeQuery(int u) &#123; int l=dfn[u],r=dfn[u]+sz[u]-1; if(u==root) return query(1,n,1,1,n); else if(dfn[root]&lt;l||dfn[root]&gt;r) return query(l,r,1,1,n); else &#123; int son=jump(root,dep[root]-dep[u]-1); return query(1,n,1,1,n)-query(dfn[son],dfn[son]+sz[son]-1,1,1,n); &#125;&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) scanf("%d",&amp;a[i]); for(int i=1;i&lt;n;++i) &#123; int u,v; scanf("%d%d",&amp;u,&amp;v); add(u,v),add(v,u); &#125; dfs(1,0); build(1,1,n); root=1; while(m--) &#123; int opt; scanf("%d",&amp;opt); if(opt==1) &#123; scanf("%d",&amp;root); &#125; else if(opt==2) &#123; int u,v,x; scanf("%d%d%d",&amp;u,&amp;v,&amp;x); treeModify(getlca(u,v,root),x); &#125; else &#123; int x; scanf("%d",&amp;x); printf("%lld\n",treeQuery(x)); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>Codeforces</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOI 2018」归程]]></title>
    <url>%2Farticles%2Fproblem-NOI-2018-Return%2F</url>
    <content type="text"><![CDATA[Description 题目链接：UOJ 393 魔力之都可以抽象成一个 $n$ 个节点、$m$ 条边的无向连通图。我们依次用 $l,a$ 描述一条边的长度、海拔。 作为季风气候的代表城市，魔力之都时常有雨水相伴，因此道路积水总是不可避免的。由于整个城市的排水系统连通，因此有积水的边一定是海拔相对最低的一些边。 我们用水位线来描述降雨的程度，它的意义是：所有海拔不超过水位线的边都是有积水的。 Yazid 是一名来自魔力之都的 OIer，刚参加完 ION2018 的他将踏上归程，回到他温暖的家。 Yazid 的家恰好在魔力之都的 $1$ 号节点。对于接下来 $Q$ 天，每一天 Yazid 都会告诉你他的出发点 $v$ ，以及当天的水位线 $p$。 每一天，Yazid 在出发点都拥有一辆车。这辆车由于一些故障不能经过有积水的边。Yazid 可以在任意节点下车，这样接下来他就可以步行经过有积水的边。但车会被留在他下车的节点并不会再被使用。 需要特殊说明的是，第二天车会被重置，这意味着： 车会在新的出发点被准备好。 Yazid 不能利用之前在某处停放的车。 Yazid 非常讨厌在雨天步行，因此他希望在完成回家这一目标的同时，最小化他步行经过的边的总长度。请你帮助 Yazid 进行计算。 本题 $T$ 组数据，并且强制在线。 数据范围：$T\le 3$，$n\le 2\times 10^5$，$m,Q\le 4\times 10^5$，$l\le 10^4$，$a\le 10^9$ Solution我们先分析一下询问的本质：将 $1$ 到 $v$ 的路径分成两个部分，一段全部开始，后一段全部走路。那我们可以枚举一个断点 $u$，在满足 $u$ 到 $v$ 的路径上所有的边的海拔都大于 $p$ 的情况下，要求 $1$ 到 $u$ 的最短路最短。 我们怎么求出从 $v$ 出发可以到达的点呢？这些点显然满足从 $v$ 出发，路径上所有边的海拔都大于 $p$。由此可以想到，这些路径一定在原图的最大生成树上！ 至此，已经可以发现能用 $\text{Kruskal}$ 重构树求解了。关于 $\text{Kruskal}$ 重构树的求法，请见「算法笔记」Kruskal 重构树。 我们把每条边按照海拔降序排列，求出关于海拔的最大生成树。由于这样的重构树是一个小根堆（每个节点子树内的所有节点的点权都不小于该节点），对于每次询问求出包含 $v$ 的子树中根节点深度最小并且海拔（点权）大于 $p$ 的子树 $x$，那么 $x$ 子树内的所有节点都可以由 $v$ 开车到达！ 求解深度最小的满足条件的节点，可以直接用树上倍增解决，这个倍增数组可以在 $\text{Kruskal}$ 的过程中求出来。 现在，这棵子树内的所有点都可以作为上文所说的断点，我们只需要求出子树内的点到点 $1$ 的最短距离的最小值。我们可以预处理每个点到 $1$ 的最短距离，然后对于每棵子树求个 $\min$ 即可。由于重构树的求解过程中我们可以知道这棵树的形态，所以这个取 $\min$ 的过程不需要 $\text{DFS}$，而是可以直接在 $\text{Kruskal}$ 中完成！ UOJ 的 hack 数据很神仙啊！ 时间复杂度：$O(T\cdot n\log n)$（此处认为 $n,m,Q$ 三者同阶） Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;typedef std::pair&lt;int,int&gt; pii;#define mk std::make_pairinline char nc() &#123; static char buf[1000000],*p1=buf,*p2=buf; return p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++;&#125;template &lt;class Tp&gt; inline void read(register Tp &amp;s) &#123; s=0;char c=nc();for(;c&lt;'0'||c&gt;'9';c=nc());for(;c&gt;='0'&amp;&amp;c&lt;='9';s=s*10+(c^48),c=nc());&#125;const int N=4e5+5,M=8e5+5,logN=19+1;int n,m,tot,lnk[N],ter[M],nxt[M],val[M],fa[N],f[N][logN],dis[N],hei[N];bool vis[N];struct Edge &#123; int u,v,h; bool operator &lt; (const Edge &amp;rhs) const &#123; return h&gt;rhs.h; &#125;&#125;e[M];void add(int u,int v,int w) &#123; ter[++tot]=v,nxt[tot]=lnk[u],val[tot]=w,lnk[u]=tot;&#125;void input() &#123; tot=0,memset(lnk,0,sizeof(lnk)); read(n),read(m); for(int i=1;i&lt;=m;++i) &#123; int u,v,w,h; read(u),read(v),read(w),read(h); add(u,v,w),add(v,u,w); e[i].u=u,e[i].v=v,e[i].h=h; &#125;&#125;void dijkstra(int s) &#123; memset(dis,0x7f,sizeof(dis)); memset(vis,0,sizeof(vis)); std::priority_queue&lt;pii,std::vector&lt;pii&gt;,std::greater&lt;pii&gt; &gt; q; q.push(mk(dis[s]=0,s)); while(!q.empty()) &#123; int u=q.top().second; q.pop(); if(vis[u]) continue; vis[u]=1; for(int i=lnk[u];i;i=nxt[i]) &#123; int v=ter[i]; if(dis[v]&gt;dis[u]+val[i]) &#123; dis[v]=dis[u]+val[i]; if(!vis[v]) q.push(mk(dis[v],v)); &#125; &#125; &#125;&#125;int find(int x) &#123; return fa[x]==x?x:fa[x]=find(fa[x]);&#125;void exKruskal() &#123; std::sort(e+1,e+m+1); for(int i=1;i&lt;=n+n;++i) fa[i]=i; int idx=n; for(int i=1;i&lt;=m;++i) &#123; int fu=find(e[i].u),fv=find(e[i].v); if(fu==fv) continue; fa[fu]=fa[fv]=++idx,hei[idx]=e[i].h; dis[idx]=std::min(dis[fu],dis[fv]); f[fu][0]=f[fv][0]=idx; &#125; for(int j=1;(1&lt;&lt;j)&lt;=idx;++j) for(int i=1;i&lt;=idx;++i) f[i][j]=f[f[i][j-1]][j-1];&#125;int query(int u,int p) &#123; for(int i=19;~i;--i) if(f[u][i]&amp;&amp;hei[f[u][i]]&gt;p) u=f[u][i]; return dis[u];&#125;void solve() &#123; int q,k,s; read(q),read(k),read(s); int lastans=0; while(q--) &#123; int v,p; read(v),read(p); v=(v+k*lastans-1)%n+1; p=(p+1LL*k*lastans)%(s+1); printf("%d\n",lastans=query(v,p)); &#125;&#125;int main() &#123; int T; for(scanf("%d",&amp;T);T--;) &#123; input(); dijkstra(1); exKruskal(); solve(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Kruskal 重构树</tag>
        <tag>UOJ</tag>
        <tag>NOI</tag>
        <tag>倍增</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法笔记」Kruskal 重构树]]></title>
    <url>%2Farticles%2Falgorithm-Extended-Kruskal%2F</url>
    <content type="text"><![CDATA[自从做了 「NOI 2018」归程 之后，才知道有 $\text{Kruskal}$ 重构树这个冷门又神奇的东西。 概述$\text{Kruskal}$ 重构树是基于 $\text{Kruskal}$ 最小生成树算法的一种算法，它主要通过将边权转化为点权来实现，其中有一些非常奇妙的性质！ 构造除了连边，其他过程都和 $\text{Kruskal}$ 最小生成树算法完全一样。 当我们需要在 $u,v$ 之间连一条权值为 $w$ 的边时，$\text{Kruskal}$ 重构树算法是这样实现的： 新建节点 $x$，将 $x$ 的点权设为 $w$。 设 $u,v$ 所属集合分别为 $S_u$ 和 $S_v$，那么连边 $(x,S_u)$ 和 $(x,S_v)$，此处连有向边即可，注意没有边权！ 将 $u$ 和 $v$ 所属集合都改为 $x$。 其余过程直接套用 $\text{Kruskal}$ 即可！ 重构树的根应该为 $2n-1$，也就是最后一个点。原因为：如果以 $1\sim n$ 中的任何一个点作为根会破坏重构树的形态；连边时向下连边，只有以 $2n-1$ 为根时才能遍历整棵树。 构造重构树的复杂度和 $\text{Kruskal}$ 一样，都是 $O(n\log n)$。 性质 最后形成一棵有 $2n-1$ 个节点的树。 我们需要将 $n$ 个原来的点最后放到同一个集合中，那么需要进行 $n-1$ 次合并。每次合并都会新建 $1$ 个节点和 $2$ 条无向边。那么一共会有 $2n-1$ 个点和 $2n-2$ 条边。 重构树中的叶子节点为原树中的节点，其余每个节点代表了一条边。 我们每次将 $x$ 和下方的 $u,v$ 连边，这个证明很显然吧！ 原树 $u$ 到 $v$ 路径上的边权最大值为重构树上 $u$ 和 $v$ 的 $\text{LCA}$ 的点权。 根据 $\text{Kruskal}$ 的过程，我们把边按照权值从小到大排序，那么对于所有非叶子节点，它的点权（原图的边权）一定不大于父亲节点的点权，所以路径上的最大值即为 $\text{LCA}$ 的点权。 例题本文以「BZOJ 3732」Network 为例（虽然此题可以直接用倍增解决，但是这里使用 $\text{Kruskal}$ 重构树的方法实现） 题目链接：BZOJ 3732 Description给你 $n$ 个点 $m$ 条边的无向图，每条边的长度为 $d_i$。现在有 $k$ 个询问 ，每次询问 $u,v$ 之间的所有路径中，最长边的最小值是多少？ 数据范围：$1\le n\le 1.5\times 10^4$，$1\le m\le 3\times 10^4$，$1\le k\le 2\times 10^4$，$1\le d_i\le 10^9$ Solution首先我们可以发现一个性质：最长边最小的路径一定在这张图的最小生成树上。那么我们只要求出这张图的最小生成树，然后倍增求出最大值即可。 然而现在不是讨论倍增的时候！QAQ 我们不建立最小生成树，而是建立重构树。根据上面的性质 $(3)$，每次询问的答案就是 $\text{LCA}(u,v)$ 的点权。 时间复杂度：$O(m\log m+k\log n)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int N=3e4+5,M=6e4+5,logN=15+1;int n,m,q,tot,fa[N],lnk[N],val[N],ter[M],nxt[M],f[N][logN],dep[N];struct Edge&#123; int u,v,w; bool operator &lt; (const Edge &amp;rhs) const &#123; return w&lt;rhs.w; &#125;&#125;e[M];void add(int u,int v) &#123; ter[++tot]=v,nxt[tot]=lnk[u],lnk[u]=tot;&#125;int find(int x) &#123; return fa[x]==x?x:fa[x]=find(fa[x]);&#125;void kruskal() &#123; std::sort(e+1,e+m+1); int lim=n+n; for(int i=1;i&lt;=lim;++i) fa[i]=i; for(int idx=n,i=1;i&lt;=m;++i) &#123; int fu=find(e[i].u),fv=find(e[i].v); if(fu==fv) continue; fa[fu]=fa[fv]=++idx,val[idx]=e[i].w; add(idx,fu),add(idx,fv); if(idx==lim-1) break; &#125;&#125;void dfs(int u,int fa) &#123; dep[u]=dep[fa]+1,f[u][0]=fa; for(int i=1;(1&lt;&lt;i)&lt;=dep[u];++i) f[u][i]=f[f[u][i-1]][i-1]; for(int i=lnk[u];i;i=nxt[i]) if(ter[i]!=fa) dfs(ter[i],u);&#125;int lca(int u,int v) &#123; if(dep[u]&gt;dep[v]) u^=v^=u^=v; for(int i=15;~i;--i) if(dep[f[v][i]]&gt;=dep[u]) v=f[v][i]; if(u==v) return u; for(int i=15;~i;--i) if(f[u][i]^f[v][i]) u=f[u][i],v=f[v][i]; return f[u][0];&#125;int main() &#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;q); for(int i=1;i&lt;=m;++i) scanf("%d%d%d",&amp;e[i].u,&amp;e[i].v,&amp;e[i].w); kruskal(); dfs(2*n-1,0); while(q--) &#123; int u,v; scanf("%d%d",&amp;u,&amp;v); printf("%d\n",val[lca(u,v)]); &#125; return 0;&#125; 习题 「NOIP 2013」货车运输 「NOI 2018」归程 「BZOJ 3551」Peaks 加强版]]></content>
      <tags>
        <tag>算法笔记</tag>
        <tag>Kruskal 重构树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP 2018 提高组题解]]></title>
    <url>%2Farticles%2Fsolution-NOIP-2018-Senior%2F</url>
    <content type="text"><![CDATA[退役选手的 NOIP 2018 提高组题解 QAQ 题面Day1 Day2 数据下载地址：NOIP 2018 提高组测试数据 铺设道路Description有 $n$ 个连续的区域，第 $i$ 个区域下陷的深度为 $d_i$。你每次可以选择一段连续的区间 $[L,R]$，使这段区间内每个区域的深度减少 $1$，但是必须保证任何时刻 $d_i\geqslant 0$。求将所有区域的深度都变为 $0$ 的最短时间。 数据范围：$1\le n\le 10^5$，$0\le d_i\le 10^4$ Solution我在考场上的第一个反应就是分治，对于当前区间找到最小值，这个最小值一定把区间拆成了若干段，对这些段递归计算。 时间复杂度：$O(n\log n)$ 其实此题还有另一个结论：$\sum_{i=1}^n \max(0,d_i-d_{i-1})$，其中 $d_0=0$。 这个结论可以用递推证明，令 $f_i$ 表示填好前 $i$ 个区域所需的最短时间。那么我们对当前的 $d_i$ 分类讨论。 如果 $d_i\le d_{i-1}$，那么我们可以在填 $d_{i-1}$ 时顺便把 $d_i$ 填好，即 $f_i=f_{i-1}$。 如果 $d_i&gt;d_{i-1}$，那么我们需要单独把 $d_i$ 高出的部分填上，即 $f_i=f_{i-1}+(d_i-d_{i-1})$。 由于我们需要的只是 $f_n$，所以就是上面那个式子了！ 时间复杂度：$O(n)$ Code第一种做法： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;const int N=1e5+5,D=1e4+5;int n,a[N],st[N][20],Log[N],ans;std::vector&lt;int&gt; b[D];void init() &#123; memset(st,0x3f,sizeof(st)); for(int i=1;i&lt;=n;++i) st[i][0]=a[i],b[a[i]].push_back(i); for(int i=0;(1&lt;&lt;i)&lt;=n;++i) Log[1&lt;&lt;i]=i; for(int i=1;i&lt;=n;++i) Log[i]=std::max(Log[i-1],Log[i]); for(int j=1;(1&lt;&lt;j)&lt;=n;++j) for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;++i) &#123; st[i][j]=std::min(st[i][j-1],st[i+(1&lt;&lt;(j-1))][j-1]); &#125;&#125;int query(int l,int r) &#123; int k=Log[r-l+1]; return std::min(st[l][k],st[r-(1&lt;&lt;k)+1][k]);&#125;void solve(int l,int r,int lst) &#123; if(l&gt;r) return; int mn=query(l,r); ans+=mn-lst; int st=std::lower_bound(b[mn].begin(),b[mn].end(),l)-b[mn].begin(); int ed=std::upper_bound(b[mn].begin(),b[mn].end(),r)-b[mn].begin(); int p=l-1; for(int i=st;i&lt;ed;++i) solve(p+1,b[mn][i]-1,mn),p=b[mn][i]; solve(p+1,r,mn);&#125;int main() &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;++i) scanf("%d",&amp;a[i]); init(); solve(1,n,0); printf("%d\n",ans); return 0;&#125; 第二种做法： 123456789#include &lt;cstdio&gt;int main() &#123; int n,ans=0; scanf("%d",&amp;n); for(int x,p=0;n--;p=x) scanf("%d",&amp;x),x&gt;p&amp;&amp;(ans+=x-p); printf("%d\n",ans); return 0;&#125; 货币系统Description有 $n$ 种不同面额的货币，第 $i$ 种货币的面额为 $a_i$，每种货币都有无限张，我们把这个货币系统记作 $(n,a)$。两个货币系统 $(n,a)$ 和 $(m,b)$ 是等价的，当且仅当对于任意的非负整数 $x$，要么能被两个货币系统都表示出来，要么两者都无法表示。 现在给出一个货币系统 $(n,a)$，你需要求出一个货币系统 $(m,b)$ 使得两者等价并最小化 $m$。 本题 $T$ 组数据。 数据范围：$1\le T\le 20$，$1\le n\le 100$，$1\le a_i\le 25000$ Solution通过感性证明可以得到：新的货币系统内的货币一定属于原来的货币系统。 那么我们把货币从小到大排序，如果某个货币 $a_i$ 能被之前的货币表示出来，那么这个 $a_i$ 一定是多余的；否则 $a_i$ 一定属于新的货币系统。这个过程显然用一个完全背包就能实现了！（我在考场竟然写了一个 $\text{bitset}$ 优化的多重背包 QAQ） 时间复杂度：$O(n\cdot a_i)$ Code12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;const int N=105;int n,a[N];bool f[25005];int main() &#123; int T; for(scanf("%d",&amp;T);T--;) &#123; scanf("%d",&amp;n); int mx=0; for(int i=1;i&lt;=n;++i) scanf("%d",&amp;a[i]),mx=mx&gt;a[i]?mx:a[i]; std::sort(a+1,a+n+1); memset(f,0,sizeof(f)); f[0]=1; int ans=0; for(int i=1;i&lt;=n;++i) &#123; if(!f[a[i]]) &#123; ++ans; for(int j=a[i];j&lt;=mx;++j) f[j]|=f[j-a[i]]; &#125; &#125; printf("%d\n",ans); &#125; return 0;&#125; 赛道修建DescriptionC 城要举办赛车比赛，需要在城内修建 $m$ 条赛道。C 城有 $n$ 个路口和 $n-1$ 条适合修建赛道的双向通行的道路，第 $i$ 条道路的长度为 $l_i$，所有路口都直接或间接连通。一条赛道由一组互不相同的道路组成，满足从起点出发依次经过这些道路到达终点。一条赛道的长度等于经过的各道路的长度之和。为保证安全，要求每条道路至多被一条赛道经过。 你的任务是设计一种赛道修建的方案，使得修建的 $m$ 条赛道中长度最小的赛道长度最大。 数据范围：$2\le n\le 5\times 10^4$，$1\le m&lt;n$，$1\le l_i\le 10^4$ Solution首先，看到“最大化最小值”可以想到二分答案 $ans$，那么将问题转化为：是否可以选择 $m$ 条长度至少是 $ans$ 的链。 考虑以 $u$ 为根的子树，最优解中有一些链完全在子树内部，还可能有一条链经过 $u$ 向子树外扩展。在子树内部的链的数量相同的情况下，我们肯定要尽量使可以往上扩展的链尽可能长（如果没有，那么这个长度就是 $0$）。 我们用 $f(x)$ 表示子树 $x$ 内部最多有多少条链，$g(x)$ 表示当子树内部链最多时，剩下的以 $x$ 结尾的链最长是多少。 考虑怎么用这两个值进行转移。对于 $u$ 的每个孩子 $v$，它为 $u$ 提供了长度为 $len(v)=g(v)+w(u,v)$ 的可以用于拼接的链，以及 $f(v)$ 的答案。如果 $len(v)\geqslant ans$，那么可以直接选择这条链并使答案 $f(u)$ 增加 $1$。否则我们可以选择两条满足 $len(v_1)+len(v_2)\geqslant ans$ 的链进行匹配并使答案 $f(u)$ 增加 $1$，接下来我们分析选择两条链匹配的问题。 我们要使得 $len(v)$ 匹配的对数最多。这显然就是一个双指针贪心的过程。但是我们还要使剩下的一条链尽可能长。那我们稍微改变一下算法：每次考虑 $len$ 最小的 $v$，并找到最小的 $len(v’)$ 满足 $len(v)+len(v’)\geqslant ans$（如果不存在就不考虑 $v$ 这条链），把 $v$ 和 $v’$ 这两条链进行匹配。这样这样把所有的 $len(v)$ 匹配完之后，可以证明 $g(u)$ 就是未匹配的最长的链。 时间复杂度：$O(n\log n\log T)$（其中 $T$ 为二分答案的值域，上界为 $\sum l_i$） Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;set&gt;const int N=5e4+5,M=1e5+5;int n,m,len,tot,lnk[N],ter[M],nxt[M],val[M];int f[N],g[N];void add(int u,int v,int w) &#123; ter[++tot]=v,nxt[tot]=lnk[u],val[tot]=w,lnk[u]=tot;&#125;void dfs(int u,int fa) &#123; std::vector&lt;int&gt; p; std::multiset&lt;int&gt; s; for(int i=lnk[u];i;i=nxt[i]) &#123; int v=ter[i]; if(v==fa) continue; dfs(v,u); f[u]+=f[v]; int sum=g[v]+val[i]; if(sum&gt;=len) ++f[u]; else s.insert(sum),p.push_back(sum); &#125; std::sort(p.begin(),p.end()); for(int i=0;i&lt;(int)p.size()&amp;&amp;!s.empty();++i) &#123; std::multiset&lt;int&gt;::iterator now=s.find(p[i]); if(now==s.end()) continue; std::multiset&lt;int&gt;::iterator nxt=s.lower_bound(len-p[i]); if(nxt==now) ++nxt; if(nxt==s.end()) continue; if(*now+*nxt&gt;=len) &#123; s.erase(now),s.erase(nxt); ++f[u]; &#125; &#125; if(!s.empty()) g[u]=*s.rbegin();&#125;bool check() &#123; memset(f,0,sizeof(f)); memset(g,0,sizeof(g)); dfs(1,0); return f[1]&gt;=m;&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); int l=0,r=0; for(int i=1;i&lt;n;++i) &#123; int u,v,w; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); add(u,v,w),add(v,u,w); r+=w; &#125; int ans=0; while(l&lt;=r) &#123; len=(l+r)&gt;&gt;1; if(check()) ans=len,l=len+1; else r=len-1; &#125; printf("%d\n",ans); return 0;&#125; 旅行DescriptionX 国有 $n$ 个城市，之间有 $m$ 条双向道路（不存在重边和自环，保证所有城市直接或间接连通）。小 Y 的旅行方案如下：任意选定一个城市作为起点，然后从起点开始沿道路走向一个没有去过的城市，或者沿着第一次访问该城市时经过的道路后退到上一个城市。在小 Y 的旅行方案中，每个城市都要被访问到。 小 Y 在第一次访问某个城市时，会记录下这个城市的编号，这样会形成一个长度为 $n$ 的序列，你需要求出字典序最小的序列。 数据范围：$1\le n\le 5000$，$m=n-1$ 或 $m=n$ Solution由于每次访问一个新的点（除了起点），一定会经过一条新的边。除了起点，我们一共要访问 $n-1$ 个点，那么会有 $n-1$ 条边，所以最终的路径会形成一棵生成树。 我们对 $m=n-1$ 和 $m=n$ 的情况分开考虑。 当 $m=n-1$ 时 我们一定选择编号为 $1$ 的点作为起点，可以发现题目中的限制等价于对原图进行 $\text{DFS}$，形成的序列就是 $\text{DFS}$ 序，我们要让 $\text{DFS}$ 序字典序最小，那么只需要对儿子节点排序，按照编号从小到大访问即可。 时间复杂度：$O(n\log n)$ 当 $m=n$ 时 根据之前证明的结论，我们可以知道一定有一条边不会被经过。那么我们只要枚举这条边。如果剩下的是一棵树，那么就按照树的方法进行 $\text{DFS}$，在所有情况中取字典序最小的作为答案。注意：并不是每次 $\text{DFS}$ 都需要进行排序，我们可以事先对每个节点的相邻节点排序。 时间复杂度：$O(n^2)$ 然而这题是可以优化到 $O(n\log n)$ 的！ 如果我们把环单独考虑，那么在每棵树上肯定是正常走，走到环上之后肯定会走较小的那一条边。因此我们可以把环找出来，很容易确定下来在环上的走的方向，接下来就可以直接 $\text{DFS}$ 求解了！ Code第一种做法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;const int N=5005;int n,m,tot,sz[N],e[N][N],ans[N],now[N],du,dv;bool vis[N],flg;bool check(int u,int v) &#123; return !((u==du&amp;&amp;v==dv)||(u==dv&amp;&amp;v==du));&#125;bool cmp() &#123; for(int i=1;i&lt;=n;++i) &#123; if(now[i]&lt;ans[i]) return 1; if(now[i]&gt;ans[i]) return 0; &#125; return 0;&#125;bool dfs(int u) &#123; ++tot; if(u&lt;ans[tot]) flg=1; if(u&gt;ans[tot]&amp;&amp;!flg) return 1; now[tot]=u,vis[u]=1; for(int i=1;i&lt;=sz[u];++i) &#123; int v=e[u][i]; if(!vis[v]&amp;&amp;check(u,v)) if(dfs(v)) return 1; &#125; return 0;&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;++i) &#123; int u,v; scanf("%d%d",&amp;u,&amp;v); e[u][++sz[u]]=v,e[v][++sz[v]]=u; &#125; for(int i=1;i&lt;=n;++i) std::sort(e[i]+1,e[i]+sz[i]+1); ans[1]=5001; if(m==n-1) &#123; dfs(1); memcpy(ans,now,sizeof(now)); &#125; else &#123; for(int i=1;i&lt;=n;++i) &#123; du=i; for(int j=1;j&lt;=sz[i];++j) &#123; dv=e[i][j]; if(dv&gt;du) continue; memset(vis,0,sizeof(vis)),tot=flg=0; dfs(1); if(tot==n&amp;&amp;cmp()) memcpy(ans,now,sizeof(now)); &#125; &#125; &#125; for(int i=1;i&lt;=n;++i) printf("%d%c",ans[i]," \n"[i==n]); return 0;&#125; 第二种做法： 1// 我也不会写啊 QAQ 填数游戏咕咕咕 保卫王国咕咕咕]]></content>
      <tags>
        <tag>题解</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu 2396」yyy loves Maths VII]]></title>
    <url>%2Farticles%2Fproblem-Luogu-2396-yyy-Loves-Maths-VII%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Luogu 2396 yyy 有 $n$ 张卡片，每张卡片上都有一个数字 $a_i$，每次 yyy 可以选择向前走 $a_i$ 步并丢弃第 $i$ 张卡片。当他手上没有卡片的时候他就赢了；但是有 $m$ 个“厄运数字”，在“厄运数字”的位置有陷阱，只要 yyy 停在这个格子上他就输了（即使终点是陷阱，那么也输了）。你需要算出 yyy 能赢的方案数，答案对 $1000000007$ 取模。 数据范围：$1\le n\le 24$，$0\le m\le 2$ Solution我们首先可以确定这是一道 $\text{DP}$ 题目。由于并没有给出 $a_i$ 的具体范围，因此无法把距离设计进状态；又发现每张牌只能用一次并且没有顺序限制，观察到 $n$ 的范围也很小，我们可以考虑状压 $\text{DP}$。 我们定义 $f[i]$ 表示使用了集合 $i$ 内的卡片有多少种赢的方案。转移时，我们记 $dis[i]$ 表示使用了集合 $i$ 内的卡片到达的位置，显然当 $dis[i]$ 为“厄运数字”时不能转移。否则我们枚举这次使用的卡片 $j$（$j\in i$），那么有转移方程：$f[i]=\sum_{j=1}^n[j\in i]\cdot f[i\ \text{XOR}\ j]$（其中 $i\ \text{XOR}\ j$ 本质是从集合 $i$ 中删去元素 $j$）。 时间复杂度：$O(2^n\log n)$ Code123456789101112131415161718192021222324252627#include &lt;cstdio&gt;const int N=24;const int mod=1e9+7;int n,m,b1,b2,dis[1&lt;&lt;N],f[1&lt;&lt;N];void upd(int &amp;x,int y) &#123;(x+=y)&gt;=mod&amp;&amp;(x-=mod);&#125;void solve(int x) &#123; for(int i=x,j;i;i^=j) j=i&amp;-i,upd(f[x],f[x^j]);&#125;int main() &#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;++i) scanf("%d",&amp;dis[1&lt;&lt;i]); scanf("%d",&amp;m); if(m&gt;0) scanf("%d",&amp;b1); if(m&gt;1) scanf("%d",&amp;b2); f[0]=1; int msk=(1&lt;&lt;n)-1; for(int i=1;i&lt;=msk;++i) &#123; int j=i&amp;-i; dis[i]=dis[i^j]+dis[j]; if(dis[i]==b1||dis[i]==b2) continue; solve(i); &#125; printf("%d\n",f[msk]); return 0;&#125;]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>Luogu</tag>
        <tag>状压 DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 5028」小 Z 的加油店]]></title>
    <url>%2Farticles%2Fproblem-BZOJ-5028-Little-Z-Gas-Station%2F</url>
    <content type="text"><![CDATA[Description 题目链接：BZOJ 5028 小 Z 经营一家加油店。小 Z 加油的方式非常奇怪。他有一排共 $n$ 个瓶子，第 $i$ 个瓶子的容量为 $v_i$。每次别人来加油，他会让别人选连续一段的瓶子 $[l,r]$，他可以用这些瓶子装汽油，但他只有三种操作：把一个瓶子完全加满；把一个瓶子完全倒空；把一个瓶子里的汽油倒进另一个瓶子，直到倒出瓶子空了或者倒进的瓶子满了。 现在有 $m$ 个事件，事件的种类一共有 $2$ 种： 1 l r：询问 $[l,r]$ 这一段瓶子能倒出的汽油量最少是多少（不能为 $0$）。 2 l r x：将 $[l,r]$ 这段区间内的瓶子内的容量都增加 $x$。 数据范围：$1\le n,m\le 10^5$，$1\le v_i,x\le 1000$ Solution根据装汽油的方式，我们可以注意到：区间 $[l,r]$ 这一段瓶子能倒出的汽油量最少为 $\gcd\{v_i\}(l\le i\le r)$。 先考虑没有修改操作，那么我们只要倍增预处理出 $\gcd$ 就行了。如果增加了修改操作，单点修改是非常的，但如果是区间修改就无法维护 $\gcd$，所以需要考虑 $\gcd$ 的性质。根据 $\gcd$ 的一种常见求法辗转相减法，可以得到 $\gcd(a,b)=\gcd(a,b-a)$，所以求区间 $[l,r]$ 的 $\gcd$ 等价于求这个区间的差分数组的 $\gcd$。 于是我们用线段树维护差分数组的区间 $\gcd$ 和区间和，支持单点修改和区间查询即可。注意：由于差分数组上的第 $l$ 个元素的值和它之前的元素有关，所以需要单独查询第 $l$ 个数的值，将这个值和 $[l+1,r]$ 的 $\gcd$ 取 $\gcd$。 时间复杂度：$O(m\log^2 n)$ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define lson rt&lt;&lt;1#define rson rt&lt;&lt;1|1const int N=1e5+5;int n,m,a[N],seg[N&lt;&lt;2],sum[N&lt;&lt;2];int gcd(int x,int y) &#123;return y?gcd(y,x%y):x;&#125;void pushup(int rt) &#123; sum[rt]=sum[lson]+sum[rson]; seg[rt]=gcd(seg[lson],seg[rson]);&#125;void build(int rt,int l,int r) &#123; if(l==r) &#123; sum[rt]=seg[rt]=a[l]; return; &#125; int mid=(l+r)&gt;&gt;1; build(lson,l,mid); build(rson,mid+1,r); pushup(rt);&#125;void modify(int x,int rt,int l,int r,int k) &#123; if(l==r) &#123; seg[rt]+=k,sum[rt]+=k; return; &#125; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) modify(x,lson,l,mid,k); else modify(x,rson,mid+1,r,k); pushup(rt);&#125;int querySum(int x,int y,int rt,int l,int r) &#123; if(x&lt;=l&amp;&amp;r&lt;=y) return sum[rt]; int mid=(l+r)&gt;&gt;1,ret=0; if(x&lt;=mid) ret+=querySum(x,y,lson,l,mid); if(mid&lt;y) ret+=querySum(x,y,rson,mid+1,r); return ret;&#125;int queryGcd(int x,int y,int rt,int l,int r) &#123; if(x&lt;=l&amp;&amp;r&lt;=y) return seg[rt]; int mid=(l+r)&gt;&gt;1,ret=0; if(x&lt;=mid) ret=gcd(ret,queryGcd(x,y,lson,l,mid)); if(mid&lt;y) ret=gcd(ret,queryGcd(x,y,rson,mid+1,r)); return ret;&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) scanf("%d",&amp;a[i]); for(int i=n;i&gt;=1;--i) a[i]-=a[i-1]; build(1,1,n); while(m--) &#123; int opt,l,r; scanf("%d%d%d",&amp;opt,&amp;l,&amp;r); if(opt==1) &#123; int ans=gcd(querySum(1,l,1,1,n),queryGcd(l+1,r,1,1,n)); printf("%d\n",std::abs(ans)); &#125; else &#123; int x; scanf("%d",&amp;x); modify(l,1,1,n,x); if(r&lt;n) modify(r+1,1,1,n,-x); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>BZOJ</tag>
        <tag>差分</tag>
        <tag>GCD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 1080D」Olya and magical square]]></title>
    <url>%2Farticles%2Fproblem-Codeforces-1080D-Olya-and-Magical-Square%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Codeforces 1080D 给你一个大小为 $2^n\times 2^n$ 的正方形，每次可以把一个正方形切割成 $4$ 个相同的正方形（田字形切割）。求是否可以切割恰好 $k$ 次，使得最终的图形可以从左下角经过若干相同边长的正方形走到右上角（只能往上和往右走）。如果可以，输出 YES 和 $\log_2{\text{路径上正方形的边长}}$（任意一个解）；否则输出 NO。 本题 $T$ 组数据。 数据范围：$1\le T\le 10^3$，$1\le n\le 10^9$，$1\le k\le 10^{18}$ Solution我们首先可以观察到一个性质：如果 $n&gt;31$，那么我们可以对整个正方形切割一次，再对左上角的正方形随意切割，显然左上角的正方形的能够被切割的次数一定不小于 $10^{18}$。因此当 $n&gt;31$ 时直接输出 YES 和 $n-1$ 即可！ 对于 $1\le n\le 31$ 的情况，我们枚举路径上的正方形的边长 $2^i$，计算出最少的切割次数 $L$ 和最多的切割次数 $R$，可以证明 $[L,R]$ 这个区间内的所有切割次数都可以被构造出来。只要有任何一个 $i$ 使得 $L\le k\le R$ 的时候则有解；否则无解。 如何计算最少的切割次数：考虑只切割出我们要走的路径的格子。每次只对边缘那一圈的格子切割，第一次需要切割 $1$ 次，第二次需要切割 $3$ 次，第三次需要切割 $7$ 次……因此最少的切割次数为 $\sum_{j=1}^{n-i}2^j-1$。 如何计算最多的切割次数：对于每个边长为 $2^i$ 的正方形预处理出它的最多切割次数，递推式为 $f(i)=4\times f(i-1)+1$，那么当路径上正方形边长为 $2^i$ 时，最多的切割次数为 $f(n)-(2\times 2^{n-i}-1)\times f(i)$ 即 $f(n)-(2^{n-i+1}-1)\times f(i)$（其中 $2\times 2^{n-i}-1$ 表示路径上的正方形个数）。 时间复杂度：$O(TN^2)$（其中 $1\le N\le 31$） Code1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;long long pw[35];int check(int n,long long k) &#123; for(int i=0;i&lt;n;++i) &#123; int p=n-i; long long l=0; for(int j=1;j&lt;=p;++j) l+=(1LL&lt;&lt;j)-1; if(l&gt;k) continue; long long r=pw[n]-((1LL&lt;&lt;(p+1))-1)*pw[i]; if(r&lt;k) continue; return i; &#125; return -1;&#125;int main() &#123; int T; for(int i=1;i&lt;=32;++i) pw[i]=4LL*pw[i-1]+1; for(scanf("%d",&amp;T);T--;) &#123; int n; long long k; scanf("%d%I64d",&amp;n,&amp;k); if(n&gt;31) &#123; printf("YES %d\n",n-1); &#125; else &#123; int ans=check(n,k); if(ans&lt;0) puts("NO"); else printf("YES %d\n",ans); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>贪心</tag>
        <tag>Codeforces</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「UVa 10140」Prime Distance]]></title>
    <url>%2Farticles%2Fproblem-UVa-10140-Prime-Distance%2F</url>
    <content type="text"><![CDATA[Description 题目链接：UVa 10140 给定区间 $[L,R]$，求这个区间中相邻的两个质数的差的最小值和最大是分别是多少，并输出对应的 $2$ 个质数；如果没有则输出 There are no adjacent primes.。 本题多组数据。 数据范围：$1\le L&lt;R&lt;2^{31}$，$R-L\le 10^6$ Solution首先我们发现：$R-L$ 的范围很小，我们应该要能够快速求出 $L\sim R$ 之间的质数。 显然有推论：任意一个合数 $x$ 必定包含一个不超过 $\sqrt x$ 的质因子。 所以我们可以筛出 $[1,\sqrt R]$ 之间的所有质数，对于每个质数 $p$，把 $[L,R]$ 中能被 $p$ 整除的数标记为合数。最终没有被标记的数就是质数，对相邻的质数两两比较，找出差值最小和最大的即可。 时间复杂度：$O(\sum_{p\le \sqrt R}\frac{R-L}{p})=O(\sqrt R\log^2\sqrt R+(R-L)\log^2 R)$（该复杂度摘自：李煜东《算法进阶指南》） Code123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cstring&gt;const int N=1e6+5;int tot,p[N];bool flg[N],vis[N];void init() &#123; for(int i=2;i&lt;N;++i) &#123; if(!flg[i]) p[++tot]=i; for(int j=1;j&lt;=tot&amp;&amp;i*p[j]&lt;N;++j) &#123; flg[i*p[j]]=1; if(i%p[j]==0) break; &#125; &#125;&#125;void chkmin(long long &amp;x,long long a,long long b,long long &amp;p1,long long &amp;p2) &#123; if(x&gt;b-a) x=b-a,p1=a,p2=b;&#125;void chkmax(long long &amp;x,long long a,long long b,long long &amp;p1,long long &amp;p2) &#123; if(x&lt;b-a) x=b-a,p1=a,p2=b;&#125;int main() &#123; init(); long long l,r; while(~scanf("%lld%lld",&amp;l,&amp;r)) &#123; memset(vis,1,sizeof(vis)); if(l==1) vis[0]=0; for(int i=1;i&lt;=tot;++i) &#123; for(long long j=l/p[i];j*p[i]&lt;=r;++j) &#123; long long x=p[i]*j; if(j&gt;1&amp;&amp;x&gt;=l) vis[x-l]=0; &#125; &#125; long long p=0,p1,p2,p3,p4,mn=1LL&lt;&lt;60,mx=0; for(long long i=l;i&lt;=r;++i) &#123; if(!vis[i-l]) continue; if(p) chkmin(mn,p,i,p1,p2),chkmax(mx,p,i,p3,p4); p=i; &#125; if(!mx) puts("There are no adjacent primes."); else printf("%lld,%lld are closest, %lld,%lld are most distant.\n",p1,p2,p3,p4); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>线性筛</tag>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI 2009」梦幻布丁]]></title>
    <url>%2Farticles%2Fproblem-HNOI-2009-Pudding%2F</url>
    <content type="text"><![CDATA[Description 题目链接：BZOJ 1483 有 $n$ 个布丁摆成一行，每个布丁都有一个颜色 $a_i$，进行 $m$ 次操作。操作共有 $2$ 种： 1 x y：将颜色为 $x$ 的布丁全部变成颜色 $y$ 的布丁。 2：询问当前一共有多少段颜色（例如颜色分别为 $1,2,2,1$ 的 $4$ 个布丁一共有 $3$ 段颜色）。 数据范围：$1\le n,m\le 10^5$，$0&lt;a_i,x,y&lt;10^6$ Solution我们可以把每种颜色的布丁集合想象成是一个队列。那么就有若干个长度总和为 $n$ 的队列，每次操作需要合并 $x$ 和 $y$。如果我们暴力合并，那么合并一次复杂度最坏为 $O(n)$。 但是有个叫做启发式合并的东西！它的本质很简单：每次把短的合并到长的上面，那么合并一次的复杂度为 $O(|短的队列|)$。这样看上去貌似没有什么差别嘛 QAQ，接下来我们分析一下均摊复杂度。 考虑用贡献法来分析。我们令两个集合的分别为 $A$ 和 $B$，且 $|A|&lt;|B|$，那么我们把 $A$ 暴力加入到 $B$ 中。那么 $A$ 中的元素所在的集合大小变成 $|A|+|B|$，也就是说至少变成了原来的两倍。所以每个元素至多被加入 $\log n$ 次，总的复杂度为 $O(n\log n)$。 对于这道题目，我们先求出原序列的答案，对于每一种颜色都用类似链表的数据结构串起来，并记录下尾节点。每次修改，都根据启发式合并的方法来暴力合并，然后处理一下此次合并对答案的影响（显然答案是不增的）。 但是如果我们把 $1$ 染成 $2$ 并且 $|S_1|&gt;|S_2|$，那么我们应该把 $2$ 接到 $1$ 的后面。这样会有一个问题：本次修改后这个链的颜色是 $1$（颜色为 $2$ 的链被删除了），如果接下来修改颜色 $2$（显然这是合法的），会使得找不到颜色 $2$ 而只能找到颜色 $1$ 了。所以我们需要使用一个 $f$ 数组，表示当我们要寻找颜色 $x$ 时，实际上需要寻找颜色为 $f[x]$ 的链。如果遇到上面这种情况就要交换交换 $f[x]$ 和 $f[y]$。 时间复杂度：$O(n\log n)$ Code1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cstdio&gt;const int N=1e5+5,M=1e6+5;int n,m,c[N],sz[M],st[M],f[M],hd[M],nxt[N],ans;void merge(int x,int y) &#123; for(int i=hd[x];i;i=nxt[i]) ans-=(c[i-1]==y)+(c[i+1]==y); for(int i=hd[x];i;i=nxt[i]) c[i]=y; nxt[st[x]]=hd[y],hd[y]=hd[x],sz[y]+=sz[x]; hd[x]=st[x]=sz[x]=0;&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) &#123; scanf("%d",&amp;c[i]),f[c[i]]=c[i]; ans+=c[i]!=c[i-1]; if(!hd[c[i]]) st[c[i]]=i; ++sz[c[i]],nxt[i]=hd[c[i]],hd[c[i]]=i; &#125; while(m--) &#123; int opt; scanf("%d",&amp;opt); if(opt==2) printf("%d\n",ans); else &#123; int x,y; scanf("%d%d",&amp;x,&amp;y); if(x==y) continue; if(sz[f[x]]&gt;sz[f[y]]) std::swap(f[x],f[y]); if(!sz[f[x]]) continue; merge(f[x],f[y]); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>HNOI</tag>
        <tag>链表</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 1080C」Masha and two friends]]></title>
    <url>%2Farticles%2Fproblem-Codeforces-1080C-Masha-and-Two-Friends%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Codeforces 1080C 在一个 $n\times m$ 的国际象棋棋盘内，其中 $(1,1)$ 的格子为白色，首先将一个子矩形全都染成白色，再将一个子矩形全都染成黑色（两次染色有先后顺序）。求最后有多少个白色格子和黑色格子。 本题 $T$ 组数据。 数据范围：$1\le T\le 10^3$，$1\le n,m\le 10^9$ Solution因为只有两次染色，所以我们只需要分类讨论就行了！ 首先我们记 $B(x_1,y_1,x_2,y_2)$ 和 $W(x_1,y_1,x_2,y_2)$ 分别为矩形 $(x_1,y_1),(x_2,y_2)$ 内的黑色和白色格子数量。经过推算我们可以得到，白色格子的增量为：$B(x_1,y_1,x_2,y_2)-B((x_1,y_1,x_2,y_2)\cap(x_3,y_3,x_4,y_4))-W(x3,y3,x4,y4)$。其中第二项括号内的 $\cap$ 表示两个矩形的交集（如果没有交集，则第二项的值为 $0$）。 对于如何求 $B$ 和 $W$，直接分类讨论或者拆成 $4$ 个矩形容斥均可！ 时间复杂度：$O(T)$ Code123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;algorithm&gt;long long getblack(int x1,int y1,int x2,int y2) &#123; bool opt=(x1+y1)&amp;1; int n=x2-x1+1,m=y2-y1+1; if(opt) return 1LL*n*(m/2)+((m&amp;1)?(n/2)+(n&amp;1):0); else return 1LL*n*(m/2)+((m&amp;1)?(n/2):0);&#125;long long getwhite(int x1,int y1,int x2,int y2) &#123; return 1LL*(x2-x1+1)*(y2-y1+1)-getblack(x1,y1,x2,y2);&#125;int main() &#123; int T; for(scanf("%d",&amp;T);T--;) &#123; int n,m,x1,y1,x2,y2,x3,y3,x4,y4; scanf("%d%d",&amp;n,&amp;m),n^=m^=n^=m; long long s1=getwhite(1,1,n,m); scanf("%d%d%d%d%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;x3,&amp;y3,&amp;x4,&amp;y4); int u=std::max(x1,x3),d=std::min(x2,x4); int l=std::max(y1,y3),r=std::min(y2,y4); if(u&lt;=d&amp;&amp;l&lt;=r) &#123; s1+=getblack(x1,y1,x2,y2)-getblack(u,l,d,r)-getwhite(x3,y3,x4,y4); &#125; else &#123; s1+=getblack(x1,y1,x2,y2)-getwhite(x3,y3,x4,y4); &#125; printf("%I64d %I64d\n",s1,1LL*n*m-s1); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>Codeforces</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「POJ 3764」The xor-longest Path]]></title>
    <url>%2Farticles%2Fproblem-POJ-3764-the-Xor-Longest-Path%2F</url>
    <content type="text"><![CDATA[Description 题目链接：POJ 3764 给定一棵有 $n$ 个节点的树，每条边有一个权值 $a_i$。你需要在树上找一条简单路径，使得这条路径上的边权异或和最大。 数据范围：$1\le n\le 10^5$，$0\le a_i&lt;2^{31}$ Solution首先我们对这个问题进行转化：设 $f(u,v)$ 表示从 $u$ 到 $v$ 的简单路径上的边权异或和。那么根据异或的性质，有 $f(u,v)=f(1,u)\oplus f(1,v)$，故问题转化为 $\max_{1\le i\le n,1\le j\le n}f(1,i)\oplus f(1,j)$，可以 $O(n^2)$ 解决，但是无法通过此题。 接下来考虑如何优化。这个式子的本质其实是：对于每一个 $f(1,i)$，找到一个 $f(1,j)$ 使得 $f(1,u)\oplus f(1,v)$ 最大。我们可以非常套路地贪心，使得答案的高位尽量为 $1$。对于每个点求出它到根的路径的异或和 $dis_i$ 并插入 $\text{Trie}$ 树，再对于每个 $dis_i$ 在 $\text{Trie}$ 树上找贪心地找到对应的 $dis_j$。 贪心策略：尽量在 $\text{Trie}$ 树上走和当前位不同的节点；如果没有，则只能妥协走当前节点仅有的儿子。 时间复杂度：$O(n\log a_i)$ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;const int N=1e5+5,M=2e5+5;int n,tot,lnk[N],ter[M],nxt[M],val[M];int dis[N],idx,ch[30*N][2];void add(int u,int v,int w) &#123; ter[++tot]=v,nxt[tot]=lnk[u],val[tot]=w,lnk[u]=tot;&#125;void dfs(int u,int fa) &#123; for(int i=lnk[u];i;i=nxt[i]) &#123; int v=ter[i]; if(v==fa) continue; dis[v]=dis[u]^val[i],dfs(v,u); &#125;&#125;void ins(int x) &#123; int u=0; for(int i=30;~i;--i) &#123; int b=(x&gt;&gt;i)&amp;1; if(!ch[u][b]) ch[u][b]=++idx,memset(ch[idx],0,sizeof(ch[idx])); u=ch[u][b]; &#125;&#125;int query(int x) &#123; int u=0,ret=0; for(int i=30;~i;--i) &#123; int b=(x&gt;&gt;i)&amp;1; if(ch[u][b^1]) u=ch[u][b^1],ret|=1&lt;&lt;i; else u=ch[u][b]; &#125; return ret;&#125;int main() &#123; while(~scanf("%d",&amp;n)) &#123; memset(lnk,0,sizeof(lnk)),tot=idx=0; for(int i=1;i&lt;n;++i) &#123; int u,v,w; scanf("%d%d%d",&amp;u,&amp;v,&amp;w),++u,++v; add(u,v,w),add(v,u,w); &#125; dfs(1,0); int ans=0; memset(ch[0],0,sizeof(ch[0])); for(int i=1;i&lt;=n;++i) ins(dis[i]); for(int i=1;i&lt;=n;++i) ans=std::max(ans,query(dis[i])); printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>位运算</tag>
        <tag>POJ</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CTSC 2017」吉夫特]]></title>
    <url>%2Farticles%2Fproblem-CTSC-2017-Gift%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Luogu 3773 给定一个长度为 $n$ 的数列 $a_i$，求有多少个长度大于等于 $2$ 的不上升子序列 $a_{b_1},a_{b_2},\cdots,a_{b_k}$ 满足 \prod_{i=2}^k\binom{a_{b_{i-1}}}{a_{b_i}}\bmod 2=\binom{a_{b_1}}{a_{b_2}}\times\binom{a_{b_2}}{a_{b_3}}\times\cdots\times\binom{a_{b_{k-1}}}{a_{b_k}}\bmod 2>0输出这个个数对 $1000000007$ 取模的结果。 数据范围：$1\le n\le 211985$，$1\le a_i\le 233333$。所有的 $a_i$ 互不相同。 Solution看到这么大一串累乘式子，肯定要先寻找规律呀！ 由于 $\bmod 2$ 的值为 $1$，那么意味着式子的值为奇数。又因为 $2$ 是质数，所以根据 $\text{Lucas}$ 定理，可以得到 \binom{n}{m}\bmod 2=\binom{n\bmod 2}{m\bmod 2}\times\binom{\left\lfloor\frac{n}{2}\right\rfloor}{\left\lfloor\frac{m}{2}\right\rfloor}我们将 $n$ 和 $m$ 化为二进制。当 $\binom{n}{m}$ 为奇数时，只需要满足没有任何一位上 $n$ 是 $0$ 且 $m$ 为 $1$（如果某一位上 $n$ 是 $0$ 而 $m$ 是 $1$，那么 $\binom{n}{m}$ 根据 $\text{Lucas}$ 定理展开后必有 $\binom{1}{0}$ 这一项，原式为偶数）。 经过上述分析，我们就可以发现：当 $\binom{n}{m}$ 为奇数时，当且仅当 $m\ \text{AND}\ n=m$，也就是说 $m$ 在二进制下是 $n$ 的子集。 于是我们就把这个问题转化成了一个可以 $\text{DP}$ 的问题。接下来定义 $\text{DP}$ 状态：$f[i]$ 表示以 $i$ 这个数结尾有多少个长度至少为 $1$ 的序列（注意：这里使用“至少为 $1$”可以方便转移）。转移时枚举 $a_i$ 的子集 $j$，那么在 $j$ 之前可以接 $f[a_i]+1$ 种序列（$f[a_i]$ 为以 $a_i$ 结尾的序列数量，而 $1$ 则为不选择 $a_i$）。 注意：由于状态为“至少为 $1$”的序列个数，所以最终答案要减去 $n$。 时间复杂度：$O(n\cdot 2^{cnt(a_i)})$（其中 $cnt(x)$ 表示 $x$ 在二进制下 $1$ 的个数） Code12345678910111213141516171819202122#include &lt;cstdio&gt;const int N=3e5+5;const int mod=1e9+7;int n,f[N];int main() &#123; scanf("%d",&amp;n); int ans=0; for(int x,i=1;i&lt;=n;++i) &#123; scanf("%d",&amp;x); int sum=f[x]+1; for(int j=x;j;j=(j-1)&amp;x) &#123; f[j]+=sum; if(f[j]&gt;=mod) f[j]-=mod; &#125; ans+=sum; if(ans&gt;=mod) ans-=mod; &#125; ans-=n; if(ans&lt;0) ans+=mod; printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>Luogu</tag>
        <tag>CTSC</tag>
        <tag>Lucas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOIP 2017」宝藏]]></title>
    <url>%2Farticles%2Fproblem-NOIP-2017-Treasure%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Luogu 3959 参与考古挖掘的小明得到了一份藏宝图，藏宝图上标出了 $n$ 个深埋在地下的宝藏屋， 也给出了这 $n$ 个宝藏屋之间可供开发的 $m$ 条道路和它们的长度。从地面打通一条到某个宝藏屋的道路是很困难的，而开发宝藏屋之间的道路则相对容易很多。 赞助商决定免费赞助小明打通一条从地面到某个宝藏屋的通道，通往哪个宝藏屋则由小明来决定。在此基础上，小明还需要考虑如何开凿宝藏屋之间的道路。每开凿出一条新道路，小明就会与考古队一起挖掘出由该条道路所能到达的宝藏屋的宝藏。另外，小明不想开发无用道路，即两个已经被挖掘过的宝藏 屋之间的道路无需再开发。 新开发一条道路的代价是：$L\times K$。其中 $L$ 代表这条道路的长度，$K$ 代表从赞助商帮你打通的宝藏屋到这条道路起点的宝藏屋所经过的宝藏屋的数量（包括赞助商帮你打通的宝藏屋和这条道路起点的宝藏屋）。 你需要求出小明挖掘出所有宝藏屋的最小代价。 数据范围：$1\le n\le 12$，$0\le m\le 1000$，$L\le 5\times 10^5$ Solution我第一次看到这题时，差点以为是裸的 $\text{Prim}$！但是仔细分析了一波，发现层数对答案也是有影响的，直接贪心肯定是错误的。而直到我看到这个 $n\le 12$ 的数据范围，正解状压 $\text{DP}$ 也就呼之欲出了。 显然根据题意，挖掘的道路肯定会形成一棵树，那么我们可以按层数 $\text{DP}$。我们定义状态 $f[i][S]$ 表示当前距离根的深度为 $i$，已经打通了集合 $S$ 内的所有宝藏屋所需的最小花费。 考虑如何转移。首先枚举上一层的状态 $S$，令当前层的状态 $T$ 遍历 $S$ 的补集 $C$，转移方程即为： f[i][S\cup T]=\min\{f[i-1][S]+(i-1)\times\text{cost}\}其中 $\text{cost}$ 表示从集合 $S$ 内的宝藏屋开始打通集合 $T$ 内的宝藏屋的最小花费，可以在枚举 $S$ 后预处理得到。注意：当 $T$ 内的任何一个宝藏屋无法通过 $S$ 内的宝藏屋打通时，不能转移！ 最终的答案为 $\min\{f[i][2^n-1]\}$（其中 $2^n-1$ 为全集）。 时间复杂度：$O(3^n\cdot n)$（复杂度证明见下文） Code123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;const int N=15,M=1&lt;&lt;13;const int inf=1&lt;&lt;30;int n,m,dis[N],g[N][N],f[N][M];void init() &#123; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j) g[i][j]=inf; memset(f,0x3f,sizeof(f)); for(int i=1;i&lt;=n;++i) f[1][1&lt;&lt;(i-1)]=0;&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); init(); for(int u,v,w;m--;) &#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); g[u][v]=g[v][u]=std::min(g[u][v],w); &#125; for(int S=0;S&lt;(1&lt;&lt;n);++S) &#123; for(int i=1;i&lt;=n;++i) &#123; dis[i]=inf; for(int j=1;j&lt;=n;++j) if(S&amp;(1&lt;&lt;(j-1))) dis[i]=std::min(dis[i],g[j][i]); &#125; int C=((1&lt;&lt;n)-1)^S; for(int T=C;T;T=C&amp;(T-1)) &#123; int sum=0; bool ok=1; for(int i=1;i&lt;=n;++i) if(T&amp;(1&lt;&lt;(i-1))) &#123; if(dis[i]==inf) &#123;ok=0;break;&#125; sum+=dis[i]; &#125; if(!ok) continue; for(int i=1;i&lt;=n;++i) f[i][S|T]=std::min(f[i][S|T],f[i-1][S]+sum*(i-1)); &#125; &#125; int ans=inf; for(int i=1;i&lt;=n;++i) ans=std::min(ans,f[i][(1&lt;&lt;n)-1]); printf("%d\n",ans); return 0;&#125; Complexity顺便在这里证明一下子集的子集的个数是 $3^n$ 个吧！ 二项式定理推一波式子可以知道 $n$ 个数的子集个数为： \sum_{k=0}^n\binom{n}{k}2^k简单转化一下 \sum_{k=0}^n\binom{n}{k}2^k 1^{n-k}根据二项式定理，即 $(x+y)^n=\sum_{k=0}^n\binom{n}{k}x^k y^{n-k}$，可以得到原式即为 (2+1)^n=3^n综上所述，$n$ 个元素的集合的子集的子集个数为 $3^n$。 通俗的证明首先回忆一下子集的个数为 $2^n$ 个是如何证明的：每个数选或者不选有 $2$ 种状态，那么共有 $2^n$ 个子集。 那么我们模仿这个过程来证明子集的子集个数。对于 $n$ 个元素，设子集为 $S$，$S$ 的子集 $S’$，元素 $x$ 有以下状态： $x\notin S$，自然 $x\notin S’$ $x\in S$，并且 $x\notin S’$ $x\in S$，并且 $x\in S’$ 每个元素的状态有 $3$ 种，那么子集的子集个数为 $3^n$ 个。]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>Luogu</tag>
        <tag>状压 DP</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AGC 027C」ABland Yard]]></title>
    <url>%2Farticles%2Fproblem-AGC-027C-ABland-Yard%2F</url>
    <content type="text"><![CDATA[Description 题目链接：AGC 027C 给出一个 $n$ 个点，$m$ 条边的无向图（可能有自环）。每个节点有一个值 A 或 B，你可以从任意一个节点出发，经过一些节点后（可以重复经过）并将经过节点的值顺次写出来，就可以得到一个字符串。求是否满足对于任何一个满足只包含 A 或 B 的字符串都可以被这张图构造出来。 数据范围：$n,m\le 2\times 10^5$ Solution这题看上去不是很可做，所以我们可以猜测结论：一张图满足条件，当且仅当包含一个由 AA 和 BB 交替出现的环。 其实这个结论很好证明，我们考虑反证法： 如果环内连续的 A 或 B 的个数小于 $2$，那么无法构成 AA 或 BB。 如果环内连续的 A 或 B 的个数大于 $2$，那么必然存在一个结尾为 ABBA 或 BAAB 的串无法构成。 如果我们 $\text{DFS}​$ 找环，那么细节太多了我太懒了不想写，所以我们可以换一种思路，利用拓扑排序的思想，每次将只与一种字符相连的点删掉，那么剩下的点一定即和 A 相连又和 B 相连，代表 AABB 这样循环的串。因此如果所有点都删掉了，那么说明不满足条件输出 No，否则满足条件输出 Yes。 时间复杂度：$O(n+m)$ Code12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;queue&gt;const int N=2e5+5,M=4e5+5;int n,m,tot,lnk[N],ter[M],nxt[M],deg[N][2];char col[N];bool vis[N];void add(int u,int v) &#123; ter[++tot]=v,nxt[tot]=lnk[u],lnk[u]=tot;&#125;bool check() &#123; for(int i=1;i&lt;=n;++i) if(!vis[i]) return 0; return 1;&#125;int main() &#123; scanf("%d%d%s",&amp;n,&amp;m,col+1); while(m--) &#123; int u,v; scanf("%d%d",&amp;u,&amp;v); add(u,v),add(v,u); ++deg[u][col[v]=='B']; ++deg[v][col[u]=='B']; &#125; std::queue&lt;int&gt; q; for(int i=1;i&lt;=n;++i) &#123; if(!deg[i][0]||!deg[i][1]) q.push(i),vis[i]=1; &#125; while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=lnk[u];i;i=nxt[i]) &#123; int v=ter[i]; if(vis[v]) continue; if(!--deg[v][col[u]=='B']) q.push(v),vis[v]=1; &#125; &#125; puts(check()?"No":"Yes"); return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>AtCoder</tag>
        <tag>结论</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOI 2014」起床困难综合征]]></title>
    <url>%2Farticles%2Fproblem-NOI-2014-Waking-Up-Difficulty%2F</url>
    <content type="text"><![CDATA[Description 题目链接：BZOJ 3668 在深邃的太平洋海底中，出现了一条名为 drd 的巨龙。历经千辛万苦，atm 终于来到了 drd 所在的地方，准备与其展开艰苦卓绝的战斗。drd 的防御战线由 $n$ 扇防御门组成。每扇防御门包括一个运算 $op$ 和一个参数 $t$，其中运算一定是 $\text{OR},\text{XOR},\text{AND}$ 中的一种，参数则一定为非负整数。如果还未通过防御门时攻击力为 $x$，则其通过这扇防御门后攻击力将变为 $x\ op\ t$（$x$ 和 $t$ 经过 $op$ 运算后的结果）。最终 drd 受到的伤害为对方初始攻击力 $x$ 依次经过所有 $n$ 扇防御门后转变得到的攻击力。 由于 atm 水平有限，他的初始攻击力只能为 $0$ 到 $m$ 之间的一个整数。为了节省体力，他希望通过选择合适的初始攻击力使得他的攻击能让 drd 受到最大的伤害，请你帮他计算一下，他的一次攻击最多能使 drd 受到多少伤害。 数据范围：$2\le n\le 10^5$，$2\le m\le 10^9$，$0\le t\le 10^9$ Solution对于这种二进制的题目，由于每一位时完全独立的，所以第一感觉就是按位贪心！我们贪心 $m$ 的每一位的值，选择能够使答案的这一位最大的值就行了。 细节的处理：我们使用 $\text{DFS}$ 就行实现，这样可以方便处理贴紧上界的情况。如果对于 $m$ 这一位的所有取值，答案的这一位都相同，那么最小化 $m$。 时间复杂度：$O(n\log m)$ Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int N=1e5+5;int n,m,len,a[N],bin[31],ans,opt[2];char s[N][5];void init() &#123; for(;m;m&gt;&gt;=1) bin[++len]=m&amp;1; while(len&lt;30) bin[++len]=0;&#125;int solve(int d,int x) &#123; for(int i=1;i&lt;=n;++i) &#123; char opt=s[i][1]; int num=(a[i]&gt;&gt;(d-1))&amp;1; if(opt=='A') x&amp;=num; if(opt=='O') x|=num; if(opt=='X') x^=num; &#125; return x;&#125;void work(int len,bool full) &#123; if(!len) return; int up=full?bin[len]:1; opt[0]=opt[1]=-1; for(int i=0;i&lt;=up;++i) opt[i]=solve(len,i); ans+=std::max(opt[0],opt[1])*(1&lt;&lt;(len-1)); if(!full) work(len-1,0); else work(len-1,bin[len]?(opt[1]&gt;opt[0]):1);&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); init(); for(int i=1;i&lt;=n;++i) scanf("%s%d",s[i]+1,&amp;a[i]); work(len,1); printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>贪心</tag>
        <tag>位运算</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOIP 2015」运输计划]]></title>
    <url>%2Farticles%2Fproblem-NOIP-2015-Transportation-Plan%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Luogu 2680 L 国有 $n$ 个星球，有 $n-1$ 条双向航道连通了 L 国的所有星球，每条航道连通两个星球，第 $i$ 条航道通过的时间为 $t_i$。 小 P 掌管的物流公司有 $m$ 个运输计划，每个运输计划形如：有一艘物流飞船需要从 $u_i$ 号星球沿最快的路径到 $v_i$ 号星球去。注意：任意两艘飞船之间不会产生任何干扰。 在运输计划开始前，小 P 可以自由选择一条航道改造成虫洞，飞船驶过虫洞不消耗时间。在虫洞建设完成后，这 $m$ 个运输计划会同时开始，所有飞船一起出发。当这 $m$ 个运输计划都完成时，小 P 的物流公司的阶段性工作就完成了。求出小 P 的物流公司完成阶段性工作所需要的最短时间。 数据范围：$n,m\le 3\times 10^5$，$0\le t_i\le 1000$ Solution我们首先注意到最终的答案为：所有运输计划的最大值。而我们要最小化答案，所以可以先二分答案。 设每条链的长度为 $len_i$，现在二分得到的答案为 $x$。如果第 $i$ 条链的长度 $len_i&gt;x$，那么意味选择修改的边必须要在第 $i$ 条链上。我们统计出需要修改的链的数量 $cnt$，并把这些链上的所有边打上标记，这个过程可以使用树上差分（对于边差分）或者树链剖分（复杂度多一个 $\log$）实现。当一条边被标记的次数等于 $cnt$ 并且它的长度 $\geqslant\text{最长的链的长度}-x$ 时，这个 $x$ 为合法的，因为我们可以修改这条边，使得最长的链的长度减小到 $\le x$；否则 $x$ 这个答案不合法。 时间复杂度：$O(n\log n)$ Code一个小技巧：树上差分最后可以使用 $\text{DFS}$ 序进行前缀和计算。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;const int N=3e5+5,M=1e6+5;int n,m,tot,idx,lnk[N],ter[M],nxt[M],val[M],up[N],dep[N],dis[N],seq[N];int mx,s[N],t[N],p[N],len[N],f[N][21],d[N];void add(int u,int v,int w) &#123; ter[++tot]=v,nxt[tot]=lnk[u],val[tot]=w,lnk[u]=tot;&#125;void dfs(int u,int fa) &#123; seq[++idx]=u,f[u][0]=fa,dep[u]=dep[fa]+1; for(int i=1;(1&lt;&lt;i)&lt;=dep[u];++i) f[u][i]=f[f[u][i-1]][i-1]; for(int i=lnk[u];i;i=nxt[i]) &#123; int v=ter[i]; if(v==fa) continue; dis[v]=dis[u]+val[i],up[v]=val[i]; dfs(v,u); &#125;&#125;int LCA(int x,int y) &#123; if(dep[x]&gt;dep[y]) x^=y^=x^=y; for(int i=20;~i;--i) if(dep[f[y][i]]&gt;=dep[x]) y=f[y][i]; if(x==y) return x; for(int i=20;~i;--i) if(f[x][i]^f[y][i]) x=f[x][i],y=f[y][i]; return f[x][0];&#125;bool check(int x) &#123; memset(d,0,sizeof(d)); int cnt=0; for(int i=1;i&lt;=m;++i) &#123; if(len[i]&gt;x) ++d[s[i]],++d[t[i]],d[p[i]]-=2,++cnt; &#125; for(int i=n;i&gt;=1;--i) &#123; int k=seq[i]; d[f[k][0]]+=d[k]; if(d[k]==cnt&amp;&amp;up[k]&gt;=mx-x) return 1; &#125; return 0;&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;n;++i) &#123; int u,v,w; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); add(u,v,w),add(v,u,w); &#125; dfs(1,0); for(int i=1;i&lt;=m;++i) &#123; scanf("%d%d",&amp;s[i],&amp;t[i]); p[i]=LCA(s[i],t[i]); len[i]=dis[s[i]]+dis[t[i]]-2*dis[p[i]]; mx=std::max(mx,len[i]); &#125; int l=0,r=mx,ans; while(l&lt;=r) &#123; int mid=1LL*(l+r)&gt;&gt;1; if(check(mid)) ans=mid,r=mid-1; else l=mid+1; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>Luogu</tag>
        <tag>LCA</tag>
        <tag>树上差分</tag>
        <tag>NOIP</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JLOI 2014」松鼠的新家]]></title>
    <url>%2Farticles%2Fproblem-JLOI-2014-the-New-House-of-Squirrel%2F</url>
    <content type="text"><![CDATA[Description 题目链接：BZOJ 3631 松鼠的新家新家有 $n$ 个房间，并且有 $n-1$ 根树枝连接，每个房间都可以相互到达。 松鼠想邀请小熊维尼前来参观，并且还指定一份参观指南，他希望维尼能够按照他的指南顺序：按照 $a_1,a_2\cdots a_n$ 的房间顺序去参观新家，并且每走到一个房间，他就可以从房间拿一块糖果吃。因为松鼠参观指南上的最后一个房间 $a_n$ ，所以当维尼在参观的最后到达餐厅时就不需要再拿糖果吃了。 现在松鼠希望知道为了保证维尼有糖果吃，他需要在每一个房间各放至少多少个糖果。 数据范围：$2\le n\le 3\times 10^5$ Solution对于这种树上链增加相同值的问题，都可以使用树上差分来解决。具体的树上差分过程不再赘述，这里主要分析一下这题的细节注意。 首先这是链上点增加 $1$ 的权值的问题，我们可以用标准的点差分。但是我们注意到，每个 $a_i(1&lt; i&lt;n)$，我们在以 $a_i$ 为终点的链（之前的链）和以 $a_i$ 为起点的链（之后的链）都增加了一次，因此我们最后要减去一个 $1$；对于 $a_n$，按照题意这个点作为最后的点不需要放置糖果，也需要减去 $1$。那么我对所有的 $a_i(1&lt;i\le n)$ 在最后都要减去一个 $1$。 时间复杂度：$O(n\log n)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;const int N=3e5+5,6e5+5;int n,tot,a[N],dep[N],f[N][21],lnk[N],ter[M],nxt[M],c[N];void add(int u,int v) &#123; ter[++tot]=v,nxt[tot]=lnk[u],lnk[u]=tot;&#125;void dfs(int u,int fa) &#123; dep[u]=dep[fa]+1,f[u][0]=fa; for(int i=1;(1&lt;&lt;i)&lt;=dep[u];++i) f[u][i]=f[f[u][i-1]][i-1]; for(int i=lnk[u];i;i=nxt[i]) if(ter[i]^fa) dfs(ter[i],u);&#125;int lca(int x,int y) &#123; if(dep[x]&gt;dep[y]) x^=y^=x^=y; for(int i=20;i&gt;=0;--i) if(dep[f[y][i]]&gt;=dep[x]) y=f[y][i]; if(x==y) return x; for(int i=20;i&gt;=0;--i) if(f[x][i]^f[y][i]) x=f[x][i],y=f[y][i]; return f[x][0];&#125;void solve(int u,int fa) &#123; for(int i=lnk[u];i;i=nxt[i]) &#123; if(ter[i]^fa) solve(ter[i],u),c[u]+=c[ter[i]]; &#125;&#125;int main() &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;++i) scanf("%d",&amp;a[i]); for(int u,v,i=1;i&lt;n;++i) &#123; scanf("%d%d",&amp;u,&amp;v); add(u,v),add(v,u); &#125; dfs(1,0); for(int i=1;i&lt;n;++i) &#123; int p=lca(a[i],a[i+1]); ++c[a[i]],++c[a[i+1]],--c[p],--c[f[p][0]]; &#125; solve(1,0); for(int i=2;i&lt;=n;++i) --c[a[i]]; for(int i=1;i&lt;=n;++i) printf("%d\n",c[i]); return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>JLOI</tag>
        <tag>树上差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 527D」Clique Problem]]></title>
    <url>%2Farticles%2Fproblem-Codeforces-527D-Clique-Problem%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Codeforces 527D 数轴上有 $n​$ 个点，第 $i​$ 个点的坐标为 $x_i​$，权值为 $w_i​$。对于任意两个点 $i,j​$ 之间存在一条边当且仅当 $|x_i-x_j|\geqslant w_i+w_j​$。求出这张图的最大团的点数（团就是两两之间有边的顶点集合）。 数据范围：$1\le n\le 2\times 10^5$，$0\le x_i\le 10^9$，$1\le w_i\le 10^9$ Solution我们把每个点转化成线段 $[x_i-w_i,x_i+w_i]$，我们令 $l_i=x_i-w_i$，$r_i=x_i+w_i$。那么问题就转化为：对于任意两个点 $i,j$ 之间存在一条边当且仅当 $l_i\geqslant r_j$。我们以左端点为第一关键字，右端点为第二关键字进行排序，然后直接扫一遍求解就行了。 时间复杂度：$O(n\log n)$ Code123456789101112131415161718192021#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int N=2e5+5;int n,l[N],r[N],id[N];bool cmp(int x,int y) &#123; return r[x]==r[y]?l[x]&lt;l[y]:r[x]&lt;r[y];&#125;int main() &#123; scanf("%d",&amp;n); for(int x,w,i=1;i&lt;=n;++i) &#123; scanf("%d%d",&amp;x,&amp;w); l[i]=x-w,r[i]=x+w,id[i]=i; &#125; std::sort(id+1,id+n+1,cmp); int ans=0,las=-2e9; for(int i=1;i&lt;=n;++i) if(las&lt;=l[id[i]]) ++ans,las=r[id[i]]; printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 4245」OR-XOR]]></title>
    <url>%2Farticles%2Fproblem-BZOJ-4245-OR-XOR%2F</url>
    <content type="text"><![CDATA[Description 题目链接：BZOJ 4245 给定一个长度为 $n$ 的序列 $a_i$，将它划分为 $m$ 段连续的区间。设第 $i$ 段的费用 $c_i$ 为该段内所有数字的异或和，则总费用为 $c_1\ \text{OR}\ c_2\ \text{OR}\cdots\ \text{OR}\ c_m$，求出总费用的最小值。 数据范围：$1\le m\le n\le 5\times 10^5$，$0\le a_i\le 10^{18}$ Solution我们要让答案最小，那么可以贪心地让最高位尽可能为 $0$。我们先预处理出前缀异或和 $sum_i$，然后从高位到低位枚举答案的第 $i$ 位是否可以为 $0$。统计出 $n$ 个前缀异或和第 $i$ 位为 $0$ 的个数 $cnt$。如果 $cnt\geqslant m$ 并且 $sum_n$ 的第 $i$ 位也为 $0$，那么第 $i$ 位可以为 $0$；否则第 $i$ 位只能为 $1$。 考虑正确性的证明：根据题目要求，我们需要找 $m$ 个右端点，使得每个区间的异或和都为 $0$。由于到当前位置时一定保证了之前每个区间第 $i$ 位答案都是 $0$。所以如果当前位置的前缀异或和的第 $i$ 位为 $0$，那么这个新的区间第 $i$ 位的答案也一定是 $0$。特殊的，$n$ 一定是最后一个区间的右端点，所以如果 $sum_n$ 的第 $i$ 位为 $1$，那么这个区间的答案和最终答案的第 $i$ 位一定不可能为 $0$。 对于每一位计算完之后，要对于所有前缀异或和在第 $i$ 位为 $1$ 的进行标记，表示这一位不可能作为右端点了。 时间复杂度：$O(n\log a_i)$ Code123456789101112131415161718192021222324#include &lt;cstdio&gt;const int N=5e5+5;int n,m;long long a[N],sum[N];bool flg[N];int main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) scanf("%lld",&amp;a[i]),sum[i]=sum[i-1]^a[i]; for(int i=1;i&lt;=n;++i) flg[i]=1; long long ans=0; for(int j=62;j&gt;=0;--j) &#123; int cnt=0; for(int i=1;i&lt;=n;++i) if(flg[i]&amp;&amp;((sum[i]&gt;&gt;j)&amp;1)==0) ++cnt; if(cnt&gt;=m&amp;&amp;((sum[n]&gt;&gt;j)&amp;1)==0) &#123; for(int i=1;i&lt;=n;++i) if((sum[i]&gt;&gt;j)&amp;1) flg[i]=0; &#125; else &#123; ans|=1LL&lt;&lt;j; &#125; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>贪心</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 351B」Jeff and Furik]]></title>
    <url>%2Farticles%2Fproblem-Codeforces-351B-Jeff-and-Furik%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Codeforces 351B 给出一个长度为 $n$ 的排列 $p_i$，Jeff 和 Furik 会分别轮流进行操作，Jeff 先手。每次操作时，Jeff 会选择相邻的两个数 $p_i,p_{i+1}$ 交换位置；Furik 会抛一枚硬币，如果硬币正面朝上，那么他会随机选择一对 $i$ 和 $i+1$ 且满足 $p_i&gt;p_{i+1}$ 并交换他们；否则他会随机选择一对 $i$ 和 $i+1$ 且满足 $p_i&lt;p_{i+1}$ 并交换他们。当这个序列递增时，游戏结束。假设 Jeff 希望尽快结束游戏（即他希望两人剩余的操作次数最少），求出一共需要的操作次数的期望。 数据范围：$1\le n\le 3000$ Solution我们对 Jeff 和 Furik 的操作分开考虑： Jeff：每次操作减少 $1$ 个逆序对。 Furik：每次操作有 $\frac{1}{2}$ 的概率增加 $1$ 个逆序对，有 $\frac{1}{2}$ 的概率减少 $1$ 个逆序对。 根据期望的可加性，我们可以知道每两次操作，有 $\frac{1}{2}$ 的概率增加 $2$ 的逆序对，有 $\frac{1}{2}$ 的概率逆序对数量不变。因此，每两次操作期望减少 $1$ 个逆序对，答案就是 $2\times\text{逆序对个数}$。 但是如果根据以上思路，我们会发现样例都过不了。其实这里有一些细节问题：需要对逆序对的奇偶性分类讨论！ 有奇数个逆序对：那么最后 Jeff 进行操作后序列已经递增。操作次数为 $2\times\text{逆序对个数}-1$。 有偶数个逆序对：没有边界的问题，答案就是 $2\times\text{逆序对个数}$。 时间复杂度：$O(n\log n)$ Code1234567891011121314151617181920212223#include &lt;cstdio&gt;const int N=3005;int n,a[N],bit[N],cnt;void add(int x,int val) &#123; for(;x&lt;=n;x+=x&amp;-x) bit[x]+=val;&#125;int query(int x) &#123; int res=0; for(;x;x-=x&amp;-x) res+=bit[x]; return res;&#125;int main() &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;++i) scanf("%d",&amp;a[i]); for(int i=n;i&gt;=1;--i) &#123; cnt+=query(a[i]-1); add(a[i],1); &#125; printf("%d.000000\n",(cnt&lt;&lt;1)-(cnt&amp;1)); return 0;&#125;]]></content>
      <tags>
        <tag>Codeforces</tag>
        <tag>概率期望</tag>
        <tag>逆序对</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 914D」Bash and a Tough Math Puzzle]]></title>
    <url>%2Farticles%2Fproblem-Codeforces-914D-Bash-and-a-Tough-Math-Puzzle%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Codeforces 914D 给定一个长度为 $n$ 的数列 $a_i$ 和 $q$ 次操作，有 $2$ 种操作： 1 l r x：询问是否可以改动至多一个数使得下标在 $[l,r]$ 内的数的的 $\gcd$ 为 $x$。如果可以则输出 $\text{YES}$ 否则输出 $\text{NO}$。 2 i y：将 $a_i$ 修改为 $y$。 数据范围：$1\le n\le 5\times 10^5$，$1\le q\le 4\times 10^5$，$1\le a_i\le 10^9$ Solution这是一道线段树裸题 QAQ 我们只需要直接查询区间内不能整除 $x$ 的数的数量 $cnt$。 如果 $cnt&gt;1$，那么不可能通过修改至多 $1$ 个数达到要求。 如果 $cnt=1$，那么直接将那个数修改成 $x$ 即可。 如果 $cnt=0$，那么任意选择一个数修改成 $x$ 即可。 时间复杂度：$O(n\log^2 n)$ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#define lson rt&lt;&lt;1#define rson rt&lt;&lt;1|1const int N=5e5+5;int n,q,cnt,seg[N&lt;&lt;2];int gcd(int x,int y) &#123; return y?gcd(y,x%y):x;&#125;void pushup(int rt) &#123; seg[rt]=gcd(seg[lson],seg[rson]);&#125;void build(int rt,int l,int r) &#123; if(l==r) &#123; scanf("%d",&amp;seg[rt]); return; &#125; int mid=(l+r)&gt;&gt;1; build(lson,l,mid); build(rson,mid+1,r); pushup(rt);&#125;void modify(int x,int rt,int l,int r,int val) &#123; if(l==r) &#123; seg[rt]=val; return; &#125; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) modify(x,lson,l,mid,val); else modify(x,rson,mid+1,r,val); pushup(rt);&#125;void query(int x,int y,int rt,int l,int r,int d) &#123; if(cnt&gt;1) return; if(l==r) &#123; ++cnt; return; &#125; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid&amp;&amp;seg[lson]%d) query(x,y,lson,l,mid,d); if(mid&lt;y&amp;&amp;seg[rson]%d) query(x,y,rson,mid+1,r,d);&#125;int main() &#123; scanf("%d",&amp;n); build(1,1,n); for(scanf("%d",&amp;q);q--;) &#123; int opt; scanf("%d",&amp;opt); if(opt==1) &#123; int l,r,x; scanf("%d%d%d",&amp;l,&amp;r,&amp;x); cnt=0,query(l,r,1,1,n,x); puts(cnt&gt;1?"NO":"YES"); &#125; else &#123; int x,k; scanf("%d%d",&amp;x,&amp;k); modify(x,1,1,n,k); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>GCD</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOIP 2012」疫情控制]]></title>
    <url>%2Farticles%2Fproblem-NOIP-2012-the-Disease-Control%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Luogu 1084 H 国有 $n$ 个城市由 $n−1$ 条双向道路连通成一棵树，$1$ 号城市是首都，也就是根节点。H 国的首都爆发了传染病。为了控制疫情，不让疫情扩散到边境城市（叶子节点所表示的城市），当局决定让军队在一些城市建立检查点，使得从首都到边境城市的每一条路径上都至少有一个检查点。除了首都，任何一个城市都可以建立检查点。 现在，在 H 国的一些城市中已经驻扎有军队，且一个城市可以驻扎多个军队。一支军队可以在有道路连接的城市间移动，并在最多一个城市建立检查点。军队移动需要的时间等于经过的道路的长度 $w$。请问最少需要多少个小时才能控制疫情。注意：不同的军队可以同时移动。 数据范围：$2\le m\le n\le 5\times 10^4$，$0&lt;w&lt;10^9$ Solution预处理我们可以发现，节点的深度越小，控制的节点（子树内的节点）越多，所以我们可以贪心地把军队尽量向上提。据此，我们需要把每个点往上的距离预处理，用倍增优化。 二分答案题目要求的是：军队最大的移动时间的最小值，所以我们可以非常自然地想到二分答案，把问题转化为判定性问题（即是否可以在确定的时间内完成）。 判断合法根据前面的分析，我们在 $\text{check}$ 的时候要尽量把军队往上走。当二分答案后，设答案为 $x$，这里会有两种情况：军队在 $x$ 的时间内可以到达根节点，军队在 $x$ 的时间内无法到达根节点。 首先解决军队的上提问题 如果一个军队无法到达根节点，那么他最高的位置一定是最优的，让他待在那里就可以了！ 如果一个军队可以得到根节点，那我们求出他到达后还可以走多少时间 $rest$ 以及到达 $1$ 前的儿子 $id$，以便接下来的处理。 如果还有叶子没有被控制，那我们肯定是把军队调到 $1$ 的某个儿子，因此我们需要处理出 $1$ 的儿子有多少个需要被控制，记录它们和根节点的距离 $dist$。 最后处理可以到达 $1$ 的军队的去向。 先将这些军队按照 $rest$ 从小到大排序。如果某一个军队的 $id$ 需要被控制，那么就让他不要到达 $1$ 而直接待在 $id$ 就行了。因为如果他不回去，肯定需要别的军队过来控制这个 $id$，这样显然花费时间更大。 再将这些军队按照 $rest$ 从大到小排序，把需要被控制的点按照 $dist$ 从大到小排序。把这两个序列从前往后一一对比就行了！ 是否合法的判断：如果步骤 $3$ 中军队用完了可还有节点需要被控制，那么不合法；否则合法。 时间复杂度：$O(n\log^2 n)$ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;const int N=5e4+5,M=1e5+5;int n,m,tot,a[N],lnk[N],ter[M],nxt[M],val[M],f[N][16];long long g[N][16];bool tag[N];struct data &#123; long long val; int id; bool operator &lt; (const data &amp;rhs) const &#123; return val&lt;rhs.val; &#125;&#125; army[N],rest[N];void add(int u,int v,int w) &#123; ter[++tot]=v,nxt[tot]=lnk[u],val[tot]=w,lnk[u]=tot;&#125;void dfs(int u,int fa) &#123; for(int i=lnk[u];i;i=nxt[i]) &#123; int v=ter[i]; if(v^fa) f[v][0]=u,g[v][0]=val[i],dfs(v,u); &#125;&#125;void putTag(int u,int fa) &#123; bool res=1,flg=0; for(int i=lnk[u];i;i=nxt[i]) &#123; int v=ter[i]; if(v^fa) putTag(v,u),res&amp;=tag[v],flg=1; &#125; if(u!=1&amp;&amp;res&amp;&amp;flg) tag[u]=1;&#125;void RMQ() &#123; for(int j=1;j&lt;=15;++j) for(int i=1;i&lt;=n;++i) &#123; f[i][j]=f[f[i][j-1]][j-1]; g[i][j]=g[i][j-1]+g[f[i][j-1]][j-1]; &#125;&#125;bool check(long long lim) &#123; memset(tag,0,sizeof(tag)); int cntArmy=0,cntRest=0; for(int i=1;i&lt;=m;++i) &#123; int x=a[i]; long long sum=0; for(int j=15;~j;--j) if(f[x][j]&gt;1&amp;&amp;sum+g[x][j]&lt;=lim) sum+=g[x][j],x=f[x][j]; if(f[x][0]==1&amp;&amp;sum+g[x][0]&lt;=lim) army[++cntArmy]=data&#123;lim-sum-g[x][0],x&#125;; else tag[x]=1; &#125; putTag(1,0); for(int i=lnk[1];i;i=nxt[i]) &#123; int v=ter[i]; if(!tag[v]) rest[++cntRest]=data&#123;val[i],v&#125;; &#125; std::sort(army+1,army+cntArmy+1); std::sort(rest+1,rest+cntRest+1); int j=1; for(int i=1;i&lt;=cntArmy;++i) &#123; if(!tag[army[i].id]) tag[army[i].id]=1; else if(army[i].val&gt;=rest[j].val) tag[rest[j].id]=1; while(tag[rest[j].id]&amp;&amp;j&lt;=cntRest) ++j; &#125; return j&gt;cntRest;&#125;int main() &#123; scanf("%d",&amp;n); long long sum=0; for(int u,v,w,i=1;i&lt;n;++i) &#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); add(u,v,w),add(v,u,w),sum+=w; &#125; dfs(1,0),RMQ(); scanf("%d",&amp;m); for(int i=1;i&lt;=m;++i) scanf("%d",&amp;a[i]); long long l=0,r=sum,ans=-1; while(l&lt;=r) &#123; long long mid=(l+r)&gt;&gt;1; check(mid)?(ans=mid,r=mid-1):l=mid+1; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>Luogu</tag>
        <tag>DFS</tag>
        <tag>倍增</tag>
        <tag>NOIP</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu 4927」梦美与线段树]]></title>
    <url>%2Farticles%2Fproblem-Luogu-4927-Yumemi-Hoshino-and-Segment-Tree%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Luogu 4927 有一棵维护区间和的线段树，每个节点的权值是该节点所对应区间的元素 $a_i$ 的权值和。梦美会从这棵线段树的根节点开始游历，当她要进入子节点时，假设左右儿子的权值为 $sum_l$ 和 $sum_r$，当前节点的权值为 $sum_{cnr}$，那么梦美会以 $\frac{sum_l}{sum_{cnr}}$ 的概率进入左子树，否则进入右子树。 梦美有时会把下标在 $[l,r]$ 的序列的元素权值加上 $v$。梦美每次游历时，梦美会把经过的节点权值累加，现在她希望求出这个权值的期望。答案化成最简分数为 $\frac{p}{q}$，输出 $p\cdot q^{-1}\bmod 998244353$。 数据范围：$1\le n,m\le 10^5$，$1\le a_i,v\le 10^9$ Solution计算答案我们考虑期望原来的定义：$\frac{\text{所有情况的结果总和}}{\text{总情况数}}$。由于没给节点的权值都是左右儿子的权值和，经过的概率也和权值有关，我们记 $val_i$ 为节点 $i$ 的权值，那么可以看做是从根节点 $1$ 出发进行 $val_1$ 次游历，那么走到每一个节点的次数就是这个节点的权值。 那么所有情况的结果总和就是 ${val_i}^2$，总情况数就是 $val_1$。因此，如果没有修改操作，我们只要维护每个点的 ${val_i}^2$ 即可。 修改操作如果某一个节点的代表的长度为 $len$，原来的权值为 $val$，区间加 $v$，那么这个节点的权值变为 $val+len\times v$，权值的平方的增量为 $(val+len\times v)^2-val^2=2\times val\times len\times v-len^2\times v^2$，那么我们就需要维护 $val$ 和 $len^2$ 和 $val\times len$。 如何维护其中 $val$ 和 $len^2$ 很好维护，只是 $val\times len$ 比较麻烦。 对于一个节点而言，区间加之后它的权值由 $val$ 变成了 $val+len\times v$，那么 $val\times len$ 变成了 $(val+len\times v)\times len$，增量为 $len^2\times v$，而其中的 $len^2$ 我们可以维护了，因此 $val\times len$ 也可以轻松维护了！ 代码里 $val[i]$ 表示节点 $i$ 的权值，$ans[i]$ 表示子树 $i$ 的答案，$len[i]$ 表示子树内所有节点的 $len^2$ 的和，$sum[i]$ 表示子树内所有节点的 $val\times len$ 的和。 注意：这题卡 $\text{long long}$ 因此要用 $\text{unsigned long long}$ 或者 $\text{__int128}$ 或者手写高精度！ 时间复杂度：$O(n\log n)$ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#define lson rt&lt;&lt;1#define rson rt&lt;&lt;1|1const int N=1e5+5;const int mod=998244353;int n,m;__int128 val[N&lt;&lt;2],ans[N&lt;&lt;2],len[N&lt;&lt;2],sum[N&lt;&lt;2],tag[N&lt;&lt;2];__int128 gcd(__int128 x,__int128 y) &#123;return y?gcd(y,x%y):x;&#125;int pow(int x,int p) &#123; int res=1; for(;p;p&gt;&gt;=1,x=1LL*x*x%mod) if(p&amp;1) res=1LL*x*res%mod; return res;&#125;void print(__int128 x) &#123; if(x&gt;9) print(x/10); putchar(x%10+'0');&#125;void update(int rt,int l,int r,__int128 x) &#123; tag[rt]+=x; ans[rt]+=2*x*sum[rt]+len[rt]*x*x; val[rt]+=x*(r-l+1); sum[rt]+=x*len[rt];&#125;void pushup(int rt,int l,int r) &#123; val[rt]=val[lson]+val[rson]; sum[rt]=sum[lson]+sum[rson]+val[rt]*(r-l+1); ans[rt]=val[rt]*val[rt]+ans[lson]+ans[rson];&#125;void pushdown(int rt,int l,int r) &#123; if(!tag[rt]) return; int mid=(l+r)&gt;&gt;1; update(lson,l,mid,tag[rt]); update(rson,mid+1,r,tag[rt]); tag[rt]=0;&#125;void build(int rt,int l,int r) &#123; if(l==r) &#123; int x; scanf("%d",&amp;x); sum[rt]=val[rt]=x,ans[rt]=1LL*x*x,len[rt]=1; return; &#125; int mid=(l+r)&gt;&gt;1; build(lson,l,mid); build(rson,mid+1,r); pushup(rt,l,r); len[rt]=len[lson]+len[rson]+1LL*(r-l+1)*(r-l+1);&#125;void modify(int x,int y,int rt,int l,int r,__int128 k) &#123; if(x&lt;=l&amp;&amp;r&lt;=y) &#123; update(rt,l,r,k); return; &#125; pushdown(rt,l,r); int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) modify(x,y,lson,l,mid,k); if(mid&lt;y) modify(x,y,rson,mid+1,r,k); pushup(rt,l,r);&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); build(1,1,n); for(int opt,l,r,v;m--;) &#123; scanf("%d",&amp;opt); if(opt==1) &#123; scanf("%d%d%d",&amp;l,&amp;r,&amp;v); modify(l,r,1,1,n,v); &#125; else &#123; __int128 x=ans[1],y=val[1],d=gcd(x,y); x/=d,y/=d,x%=mod; print(y==1?x:1LL*x*pow(y%mod,mod-2)%mod),puts(""); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法笔记」莫队算法]]></title>
    <url>%2Farticles%2Falgorithm-Mo-Algorithm%2F</url>
    <content type="text"><![CDATA[莫队算法，通过对询问离线、分块和排序，看似暴力却能巧妙优化复杂度。 概述莫队算法的用武之地是一类询问可以离线，且可以通过区间 $[l,r]$ 的答案在 $O(1)$ 或 $O(\log n)$ 得到区间 $[l\pm 1,r]$ 或 $[l,r\pm 1]$ 的答案的问题。它通过对询问离线、分块和排序，巧妙地将时间复杂度从 $O(nm)$ 优化到 $O((n+m)\sqrt n)$。 例题我们以 「国家集训队 2009」小 Z 的袜子 为例。 小 Z 有 $n$ 只袜子，每只袜子都有一个颜色 $c_i$。他有 $m$ 次询问，每次询问给出一个区间 $[l,r]$，求出在这个区间里随机抽 $2$ 只袜子，这 $2$ 只袜子有多大的概率颜色相同。 数据范围：$n,m\le 5\times 10^4$ 算法分析例题中区间的信息没有区间可加性，因此无法用数据结构进行维护， 首先我们分析一下是否可以使用莫队解决，对于区间 $[l,r]$，答案为 $\dfrac{\sum_{i=1}^n \binom{f(i)}{2}}{\binom{r-l+1}{2}}$（其中 $f(i)$ 表示当前区间内颜色 $i$ 出现的次数）。如果要求出区间 $[l+1,r]$ 的答案，只比原先少了一个 $c_l$，我们把分子分母分开考虑： 分子：在颜色 $c_l$ 中选择的方案数变少，减少了 $f(c_l)-1$ 种方案数。 分母：就是新的区间长度 $r-l$ 中选 $2$ 个数的方案数 $\binom{r-l}{2}$。 对于向其他几种新区间的转移过程也是可以的，读者可以自行尝试分析。接下来我们就来了解一下莫队算法的过程！ 排序把所有的询问离线，把询问左端点 $l_i$ 以 $\Theta(\sqrt{n})$ 的大小进行分块，记第 $i$ 个询问左端点所在的块为 $b_i$，以 $b_i$ 为第一关键字，$r_i$ 为第二关键字进行排序。那么整体的 $b_i$ 是有序的，同一个块中的 $r_i$ 是有序的。 询问其实这个转移并没有什么技巧，反而非常非常非常暴力！ 如果我们已经知道了 $[L,R]$ 的信息，现在需要计算 $[l,r]$ 的答案，那我们直接把 $L$ 暴力移动到 $l$，把 $R$ 暴力移动到 $r$ 即可。 证明了解完莫队的暴力转移过程，我们就要优美地证明这个过程并不暴力！ 离线询问的整个过程中，只有 $L$ 和 $R$ 在不断移动并且两者独立，所以我们分别考虑。 左端点 相同块：左端点每次最多移动 $O(\sqrt n)$ 的距离，有 $O(m)$ 个询问。那么同一个块中左端点的移动距离为 $O(m\sqrt n)$。 跨越块：左端点每次最多移动 $O(\sqrt n)$ 的距离，有 $O(\sqrt n)$ 次跨越块。那么跨越块导致左端点的移动距离为 $O(n)$。 右端点 相同块：右端点每次最多移动 $O(n)$ 的距离，有 $O(\sqrt n)$ 个块。那么同一个块中右端点移动距离为 $O(n\sqrt n)$。 跨越块：右端点每次最多移动 $O(n)$ 的距离，有 $O(\sqrt n)$ 次跨越块。那么跨越块导致右端点移动距离为 $O(n\sqrt n)$。 综上所述，莫队算法的复杂度为 $O((n+m)\sqrt n)$。 代码莫队的代码非常套路，这份代码就当做是一个模板吧！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;const int N=5e4+5;int n,m,a[N],b[N],cnt[N];long long res,ansx[N],ansy[N];struct ques &#123; int l,r,id; bool operator &lt; (const ques &amp;rhs) const &#123; return b[l]==b[rhs.l]?r&lt;rhs.r:l&lt;rhs.l; &#125;&#125; q[N];long long query(int x) &#123;return 1LL*x*(x-1)/2;&#125;void add(int x) &#123;res+=cnt[x]++;&#125;void del(int x) &#123;res-=--cnt[x];&#125;long long gcd(long long x,long long y) &#123;return y?gcd(y,x%y):x;&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); int len=sqrt(n); for(int i=1;i&lt;=n;++i) b[i]=(i-1)/len+1; for(int i=1;i&lt;=n;++i) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=m;++i) scanf("%d%d",&amp;q[i].l,&amp;q[i].r),q[i].id=i; std::sort(q+1,q+m+1); int l=1,r=0; for(int i=1;i&lt;=m;++i) &#123; int x=q[i].l,y=q[i].r; if(x==y) &#123; ansx[q[i].id]=0; ansy[q[i].id]=1; continue; &#125; while(x&lt;l) add(a[--l]); while(x&gt;l) del(a[l++]); while(y&lt;r) del(a[r--]); while(y&gt;r) add(a[++r]); ansx[q[i].id]=res; ansy[q[i].id]=query(y-x+1); &#125; for(int i=1;i&lt;=m;++i) &#123; long long d=gcd(ansx[i],ansy[i]); printf("%lld/%lld\n",ansx[i]/d,ansy[i]/d); &#125; return 0;&#125; 习题 「BZOJ 2038」小 Z 的袜子 「SDOI 2009」HH 的项链 「Luogu 2709」小 B 的询问 「Luogu 3674」小清新人渣的本愿 扩展如果我们把块的大小设为 $\Theta\left(\dfrac{n}{\sqrt{m}}\right)$，那么莫队算法的复杂度为 $O(n\sqrt m)$（复杂度分析同上）。]]></content>
      <tags>
        <tag>算法笔记</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 4300」绝世好题]]></title>
    <url>%2Farticles%2Fproblem-BZOJ-4300-the-Best-Problem%2F</url>
    <content type="text"><![CDATA[Description 题目链接：BZOJ 4300 给定一个长度为 $n$ 的数列 $a_i$，求 $a_i$ 的子序列 $b_i$ 的最长长度 $len$，满足 $b_i\ \text{AND}\ b_{i-1}\neq 0$（$2\le i\le len$）。 数据范围：$n\le 10^5$，$a_i\le 2\times 10^9$ Solution我们可以设计出一个不朴素的 $\text{DP}$ 状态 $f[i]$ 表示考虑前 $i$ 个数的最长长度，转移为 $f[i]=\max\{f[j]+1\}$（$a_i\ \text{AND}\ a_j\neq 0$）。 考虑优化，发现这个东西和 $\text{LIS}$ 非常类似。由于 $a\ \text{AND}\ b\neq 0$ 意味着一定有一位为 $1$，所以我们用 $f[i]$ 表示第 $i$ 位为 $1$ 的最长长度。每次读入一个 $x$，我们记 $s=\max\{f[i]\}+1$（$x$ 的第 $i$ 位为 $1$），然后用 $s$ 去更新 $f[i]$，最后的答案即为 $\max\{f[i]\}$。 时间复杂度：$O(n\log a_i)$ Code12345678910111213141516171819#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int N=35;int n,f[N];int main() &#123; scanf("%d",&amp;n); for(int x;n--;) &#123; scanf("%d",&amp;x); int mx=1; for(int i=0;i&lt;=30;++i) if(x&amp;(1&lt;&lt;i)) mx=std::max(mx,f[i]+1); for(int i=0;i&lt;=30;++i) if(x&amp;(1&lt;&lt;i)) f[i]=std::max(f[i],mx); &#125; int ans=0; for(int i=0;i&lt;=30;++i) ans=std::max(ans,f[i]); printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>BZOJ</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「hihoCoder 1509」异或排序]]></title>
    <url>%2Farticles%2Fproblem-hihoCoder-1509-XOR-Sorting%2F</url>
    <content type="text"><![CDATA[Description 题目链接：hihoCoder 1509 给定一个长度为 $n$ 的非负整数序列 $a_i$ 你需要求有多少个非负整数 $S$ 满足以下两个条件： $0\le S&lt;2^{60}$ 对于所有 $1\le i&lt;n$，都有 $a_i\oplus S\le a_{i+1}\oplus S$（其中 $\oplus$ 为异或） 数据范围：$1\le n\le 50$，$0\le a_i&lt;2^{60}$ Solution对于两个数比较大小，我们回归它的本质：比较从最高位开始第一个不相同的位置。如果有两个数 $x$ 和 $y$，满足 $x\oplus S\le y\oplus S$。我们从他们的最高位开始考虑，$x$ 和 $y$ 在二进制下相同的数位和 $S$ 对应的位置异或的结果肯定一样，我们只关系第一个不相同的位置。打个比方： x=101001100\\ y=101010010那么 $x$ 和 $y$ 前 $4$ 位是相同的，第 $5$ 位是第一个不同的位置。$x$ 在这一位是 $0$，$y$ 在这一位是 $1$，如果要满足 $x\oplus S\le y\oplus S$，那么 $S$ 在这一位必须为 $1$。而我们注意到一旦有一位答案不同，那么 $S$ 接下来的位置就没有限制了。 当 $S$ 某一个位置的限制有冲突时就是无解情况，否则答案为 $2^{没有限制的位的个数}$。 时间复杂度：$O(n\log a_i)$ Code1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#define fail return puts("0"),0const int N=60;int n,num[N];long long now,las;int main() &#123; for(int i=59;i&gt;=0;--i) num[i]=-1; scanf("%d",&amp;n),--n; scanf("%lld",&amp;las); for(;n--;las=now) &#123; scanf("%lld",&amp;now); for(int i=59;i&gt;=0;--i) &#123; if(((now&gt;&gt;i)&amp;1)==((las&gt;&gt;i)&amp;1)) continue; if((las&gt;&gt;i)&amp;1) &#123; if(num[i]==-1) num[i]=1; else if(num[i]==0) fail; &#125; if((now&gt;&gt;i)&amp;1) &#123; if(num[i]==-1) num[i]=0; else if(num[i]==1) fail; &#125; break; &#125; &#125; int ans=0; for(int i=59;~i;--i) if(num[i]==-1) ++ans; printf("%lld\n",1LL&lt;&lt;ans); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>位运算</tag>
        <tag>hihoCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SPOJ 4168」SQFREE - Square-free integers]]></title>
    <url>%2Farticles%2Fproblem-SPOJ-4168-SQFREE%2F</url>
    <content type="text"><![CDATA[Description 题目链接：SPOJ 4168 求 $n$ 以内有多少个数不能被任何一个完全平方数（除 $1$ 以外）整除。 本题 $T$ 组数据。 数据范围：$1\le T\le 100$，$1\le n\le 10^{14}$ Solution这个问题直接考虑无从下手，因此我们可以从反面考虑：求有多少个数是完全平方数的倍数。 枚举 $i$（$2\le i\le \sqrt n$），那么对于答案的贡献为 $\dfrac{n}{i^2}$，但是这样会重复计算：如 $36$ 在 $i=2,3$ 时都会被计算到，所以需要容斥。 我们强制这里的 $i$ 没有重复质因子，这样一来虽然会算重复，但是不会遗漏。如果 $i$ 的质因子个数为奇数，那么对答案为正的贡献，否则为负的贡献。可以证明这个容斥是正确的。 时间复杂度：$O(T\sqrt n)$ Code123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;const int N=1e7+5;int tot,p[N/10],f[N];bool flg[N];void init() &#123; for(int i=2;i&lt;N;++i) &#123; if(!flg[i]) p[++tot]=i; for(int j=1;j&lt;=tot&amp;&amp;i*p[j]&lt;N;++j) &#123; flg[i*p[j]]=1; if(i%p[j]==0) break; &#125; &#125;&#125;void dfs(int st,int sum,int cnt) &#123; f[sum]=cnt&amp;1?1:-1; for(int i=st;i&lt;=tot;++i) &#123; long long now=1LL*sum*p[i]; if(now&gt;N) break; dfs(i+1,now,cnt+1); &#125;&#125;int main() &#123; init(); dfs(1,1,0); int T; for(scanf("%d",&amp;T);T--;) &#123; long long n; scanf("%lld",&amp;n); long long ans=0; for(int i=2;1LL*i*i&lt;=n;++i) if(f[i]) ans+=f[i]*n/(1LL*i*i); printf("%lld\n",n-ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>容斥</tag>
        <tag>SPOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 981D」Bookshelves]]></title>
    <url>%2Farticles%2Fproblem-Codeforces-981D-Bookshelves%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Codeforces 981D 给出 $n​$ 本书，每本书有一个价值 $a_i​$。将这 $n​$ 本书按照顺序放到 $k​$ 个书架上（连续若干本书放在一个书架上，接下来连续若干本放在下一个书架上），定义一个书架的美观程度为这个书架上所有书的价值总和，定义 $k​$ 个书架的美观程度为每个书架美观程度的按位与和，求这 $k​$ 个书架的最大美观程度。 数据范围：$1\le k\le n\le 50$，$0&lt;a_i&lt;2^{50}$ Solution对于按位与和，我们可以从高位到低位贪心选择。这个贪心的证明显然：如果一位为 $1$ 肯定比这一位为 $0$ 且后面都为 $1$ 更优。 如果当前最优解为 $ans$，接下来贪心第 $i$ 位，我们用 $\text{DP}$ 验证 $ans’=ans\ \text{OR}\ 2^i$ 这个答案是否可行。$\text{DP}$ 的状态定义为：$f[i][j]$ 表示前 $i$ 本书放到 $j$ 个书架是否可以得到答案 $x$ 使得 $ans’\in x$（$x\ \text{AND}\ ans’=ans’$）。转移方程为 $f[i][j]|=f[k][j-1]\ \text{AND}\ [sum(k+1,i)\ \text{AND}\ x=x]$，如果 $f[n][k]=1$ 则直接更新答案。 时间复杂度：$O(n^2 k\log \sum a_i)$ Code12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstring&gt;const int N=55;int n,k;long long a[N];bool f[N][N];bool check(long long x) &#123; memset(f,0,sizeof(f)); f[0][0]=1; for(int i=1;i&lt;=n;++i) &#123; for(int j=1;j&lt;=k;++j) &#123; for(int k=0;k&lt;i;++k) &#123; f[i][j]|=f[k][j-1]&amp;(((a[i]-a[k])&amp;x)==x); &#125; &#125; &#125; return f[n][k];&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;++i) scanf("%lld",&amp;a[i]),a[i]+=a[i-1]; long long ans=0; for(int i=60;i&gt;=0;--i) &#123; long long now=ans|(1LL&lt;&lt;i); if(check(now)) ans|=(1LL&lt;&lt;i); &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>贪心</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP 2018 普及组题解]]></title>
    <url>%2Farticles%2Fsolution-NOIP-2018-Junior%2F</url>
    <content type="text"><![CDATA[退役选手的 NOIP 2018 普及组题解 QAQ 题面 数据下载地址：NOIP 2018 普及组测试数据 标题统计Description输入一行可能带空格的字符串，求除空格外有多少个字符。 Solution使用 $\text{scanf}$ 或 $\text{cin}$ 读入每个字符串（不包含空格），然后统计字符串的长度之和即可。 时间复杂度：$O(|s|)$ Code12345678910#include &lt;cstdio&gt;#include &lt;cstring&gt;int main() &#123; char s[6]; int ans=0; while(~scanf("%s",s+1)) ans+=strlen(s+1); printf("%d\n",ans); return 0;&#125; 龙虎斗Description在数轴上有 $n$ 个点，第 $i$ 个点的位置为 $i$，权值为 $c_i$。现在给第 $p_1$ 个点的权值增加 $s_1$，你必须再给一个点的权值增加 $s_2$ 满足对于给定的一个坐标为 $m$ 的点，使得 $\sum_{i=1}^n c_i(i-m)$ 的绝对值最小。 Solution首先，我们直接把 $s_1$ 位工兵增加到第 $p_1$ 号兵营，设 $s=\sum_{i=1}^n c_i(i-m)$ 我们考虑如果在第 $p_2$ 的位置增加 $s_2$ 位工兵，那么可以得到 $s’=s+s_2(p_2-m)$。我们只需要求出使得 $s’$ 的绝对值最小的 $p_2$。我们可以直接枚举 $p_2$，在 $O(1)$ 的时间内计算出 $s_2$，更新答案的过程中要注意字典序最小的要求。 时间复杂度：$O(n)$ Code12345678910111213141516171819202122#include &lt;cstdio&gt;const int N=1e5+5;int n,m,p1;long long c[N],s1,s2;int main() &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;++i) scanf("%lld",&amp;c[i]); scanf("%d%d%lld%lld",&amp;m,&amp;p1,&amp;s1,&amp;s2); c[p1]+=s1; long long sum=0,mn=1LL&lt;&lt;62; for(int i=1;i&lt;=n;++i) sum+=1LL*(i-m)*c[i]; int ans; for(int i=1;i&lt;=n;++i) &#123; long long now=sum+1LL*(i-m)*s2; if(now&lt;0) now=-now; if(now&lt;mn) mn=now,ans=i; &#125; printf("%d\n",ans); return 0;&#125; 摆渡车Description有 $n$ 名同学在同一地点等车去同一目的地，第 $i$ 个人在第 $t_i$ 分钟开始等车。现在只有一辆车可以载人（车的容量可以视为无限大），往返一趟需要的时间为 $m$ 分钟。这辆车需要把所有同学都送到目的地。如果这辆车能在任何时间出发，回到等车地点后又可以即刻出发，求出这些同学的等车时间之和最小为多少。 Solution引理：对于每个乘客，如果他开始等待的时刻为 $t$，那么搭载他的车的发车时间 $t_0\in [t,t+m)$。 证明：如果存在一种发车时间 $\geqslant t+m$，那么发车时间一定可以提早若干个 $m$ 使得 $t_0$ 到达 $[t,t+m)$。这样不会影响其他 $\geqslant t+m$ 的发车时间，不会干扰后面的人等车。 我们考虑 $\text{DP}$ 状态设计：$f[i][j]$ 表示搭载了前 $i$ 个人，搭载第 $i$ 个人的摆渡车的发车时间为 $t_i+j$ 的最小等候时间总和。朴素的转移方程为： f[i][j]=\min_{0\le k]]></content>
      <tags>
        <tag>题解</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu 2257」YY 的 GCD]]></title>
    <url>%2Farticles%2Fproblem-Luogu-2257-YY-GCD%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Luogu 2257 求如下式子的值： \sum_{i=1}^n\sum_{i=1}^m [\gcd(i,j)=\text{prime}]本题 $T​$ 组数据。 数据范围：$T=10^4$，$n,m\le 10^7$ Solution以下所有过程中默认 $n\le m$！ 首先我们很自然想到枚举质数 \sum_{p\in\text{prime}}\sum_{i=1}^n\sum_{i=1}^m [\gcd(i,j)=p]根据套路提出 $p$ \sum_{p\in\text{prime}}\sum_{i=1}^{\left\lfloor\frac{n}{p}\right\rfloor}\sum_{i=1}^{\left\lfloor\frac{m}{p}\right\rfloor} [\gcd(i,j)=1]替换 $\gcd$ 得到 \sum_{p\in\text{prime}}\sum_{i=1}^{\left\lfloor\frac{n}{p}\right\rfloor}\sum_{i=1}^{\left\lfloor\frac{m}{p}\right\rfloor}\sum_{d\mid \gcd(i,j)} \mu(d)枚举 $d$ \sum_{d=1}^{\left\lfloor\frac{n}{p}\right\rfloor}\mu(d)\sum_{p\in\text{prime}}\sum_{i=1}^{\left\lfloor\frac{n}{p}\right\rfloor}\sum_{i=1}^{\left\lfloor\frac{m}{p}\right\rfloor} [d\mid\gcd(i,j)]由于 $x$ 以内 $d$ 的倍数有 $\left\lfloor\frac{x}{d}\right\rfloor$ 个 \sum_{p\in\text{prime}}\sum_{d=1}^{\left\lfloor\frac{n}{p}\right\rfloor}\mu(d)\left\lfloor\frac{n}{pd}\right\rfloor\left\lfloor\frac{m}{pd}\right\rfloor这个式子直接求解的复杂度为 $O(\text{质数个数}*\sqrt{n}))$ 的，无法通过此题！ 考虑优化：令 $k=pd$，代入得 \sum_{p\in\text{prime}}\sum_{d=1}^{\left\lfloor\frac{n}{p}\right\rfloor}\mu(\frac{k}{p})\left\lfloor\frac{n}{k}\right\rfloor\left\lfloor\frac{m}{k}\right\rfloor枚举 $k$ \sum_{k=1}^n\sum_{p\in\text{prime},p\mid k}\mu(\frac{k}{p})\left\lfloor\frac{n}{k}\right\rfloor\left\lfloor\frac{m}{k}\right\rfloor设 $f(x)=\sum_{p\in\text{prime},p\mid x}\mu(\frac{x}{p})$ ，询问转化为 \sum_{k=1}^n f(k)\left\lfloor\frac{n}{k}\right\rfloor\left\lfloor\frac{m}{k}\right\rfloor如果我们能求出 $f$ 的前缀和就能解决问题了，因此考虑对线性筛！ $f(x)=\sum_{p\in\text{prime},p\mid x}\mu(\frac{x}{p})$，设 $x$ 的最小质因子为 $y$，即 $x=i\times y$ $x\in\text{prime}$：显然有 $f(x)=\mu(1)=1$ $i\bmod y=0$，即 $x$ 有多个最小质因子： 当 $i$ 没有多个相同质因子时，那么当且仅当枚举的 $p=y$ 时，$\mu(\frac{x}{p})=\mu(i)$ 不为 $0$，故 $f(x)=\mu(i)$ 当 $i$ 也有多个相同质因子时，那么对于任何枚举的 $p$，都有 $\mu(\frac{x}{p})$ 的值都为 $0$，此时仍然有 $\mu(\frac{x}{p})=\mu(i)$，故 $f(x)=\mu(i)$ $i\bmod y\neq 0$，即 $x$ 有一个最小质因子： 因为有 $f(i)=\sum_{p\in\text{prime},p\mid i}\mu(\frac{i}{p})$，$f(x)=\sum_{p\in\text{prime},p\mid x}\mu(\frac{i\times y}{p})$ 根据 $\mu$ 的线性筛过程，有 $\mu(\frac{i\times y}{p})=-\mu(\frac{i}{p})$，因此 $f(i)$ 中的每一项能都在 $f(x)$ 中找到对应的一项。而 $x$ 比 $i$ 多且仅多了一个质因子 $y$，因此 $f(x)$ 比 $f(i)$ 多了一项 $\mu(\frac{i\times y}{y})=\mu(i)$，故 $f(x)=-f(i)+\mu(i)$ 综上所述，我们可以得到 $f$ 的线性筛方程 f(x)= \begin{cases} \mu(1) & x\in\text{prime}\\ \mu(i) & i\bmod y=0\\ -f(i)+\mu(i) & i\bmod y\neq 0 \end{cases}通过求 $f$ 的前缀和，我们可以利用数论分块通过本题！ 时间复杂度：$O(n+T\sqrt{n})$ Code1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int N=1e7+5,lnN=15;int n,m,tot,p[N/lnN],mu[N],f[N];bool flg[N];void init() &#123; mu[1]=flg[1]=1; for(int i=2;i&lt;N;++i) &#123; if(!flg[i]) p[++tot]=i,mu[i]=-1,f[i]=1; for(int j=1;j&lt;=tot&amp;&amp;i*p[j]&lt;N;++j) &#123; int x=i*p[j]; flg[x]=1; if(i%p[j]==0) &#123; f[x]=mu[i]; mu[x]=0; break; &#125; else &#123; f[x]=-f[i]+mu[i]; mu[x]=-mu[i]; &#125; &#125; f[i]+=f[i-1]; &#125;&#125;int main() &#123; init(); int T; for(scanf("%d",&amp;T);T--;) &#123; scanf("%d%d",&amp;n,&amp;m); long long ans=0; if(n&gt;m) n^=m^=n^=m; for(int i=1,j;i&lt;=n;i=j+1) &#123; j=std::min(n/(n/i),m/(m/i)); ans+=1LL*(f[j]-f[i-1])*(n/i)*(m/i); &#125; printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>莫比乌斯反演</tag>
        <tag>数论分块</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI 2015」约数个数和]]></title>
    <url>%2Farticles%2Fproblem-SDOI-2015-Sum-of-Divisors%2F</url>
    <content type="text"><![CDATA[Description 题目链接：BZOJ 3994 求如下式子的值： \sum_{i=1}^n\sum_{j=1}^m d(ij)本题 $T$ 组数据。 数据范围：$1\le T,n,m\le 5\times 10^4$ Solution首先给出一个公式： d(ij)=\sum_{x\mid i}\sum_{y\mid j} [\gcd(x,y)=1]因此所求为 \sum_{i=1}^n\sum_{j=1}^m\sum_{x\mid i}\sum_{y\mid j} [\gcd(x,y)=1]改变求和顺序，先枚举因数 $x$ 和 $y$ \sum_{x=1}^n\sum_{y=1}^m \left\lfloor\frac{n}{x}\right\rfloor \left\lfloor\frac{m}{y}\right\rfloor [\gcd(x,y)=1]将 $x,y$ 换成 $i,j$ 吧 QAQ \sum_{i=1}^n\sum_{j=1}^m \left\lfloor\frac{n}{i}\right\rfloor \left\lfloor\frac{m}{j}\right\rfloor[\gcd(i,j)=1]开始莫比乌斯反演！设 f(x)=\sum_{i=1}^n\sum_{j=1}^m \left\lfloor\frac{n}{i}\right\rfloor \left\lfloor\frac{m}{j}\right\rfloor[\gcd(i,j)=x] \\ g(x)=\sum_{x\mid d} f(d) \\则有 g(x)=\sum_{i=1}^n\sum_{j=1}^m \left\lfloor\frac{n}{i}\right\rfloor \left\lfloor\frac{m}{j}\right\rfloor[x\mid\gcd(i,j)]我们把 $x$ 提出就可以消除 $\gcd$ 的影响 g(x)=\sum_{i=1}^{\frac{n}{x}}\sum_{j=1}^{\frac{m}{x}} \left\lfloor\frac{n}{ix}\right\rfloor \left\lfloor\frac{m}{jx}\right\rfloor再根据 $f(x)$ 的定义，得到答案为 $f(1)$ 又因为 f(n)=\sum_{n\mid d}\mu(\frac{d}{n})g(d)故 f(1)=\sum_{1\mid d}\mu(\frac{d}{1})g(d)=\sum_{i=1}^n \mu(i)g(i)接下来再考虑如何求 $g(x)$，我们可以先计算 $s(x)=\sum_{i=1}^{x} \left\lfloor\frac{x}{i}\right\rfloor$，就可以 $O(1)$ 计算 $g(x)$。 时间复杂度：$O(T\sqrt{n})$ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int N=5e4+5;int tot,mu[N],p[N];long long s[N];bool flg[N];void init() &#123; mu[1]=1; for(int i=2;i&lt;=5e4;++i) &#123; if(!flg[i]) p[++tot]=i,mu[i]=-1; for(int j=1;j&lt;=tot&amp;&amp;i*p[j]&lt;=5e4;++j) &#123; flg[i*p[j]]=1; if(i%p[j]==0) &#123; mu[i*p[j]]=0; break; &#125; else &#123; mu[i*p[j]]=-mu[i]; &#125; &#125; &#125; for(int i=1;i&lt;=5e4;++i) mu[i]+=mu[i-1]; for(int x=1;x&lt;=5e4;++x) &#123; long long res=0; for(int i=1,j;i&lt;=x;i=j+1) j=x/(x/i),res+=1LL*(j-i+1)*(x/i); s[x]=res; &#125;&#125;int main() &#123; init(); int T; for(scanf("%d",&amp;T);T--;) &#123; int n,m; scanf("%d%d",&amp;n,&amp;m); if(n&gt;m) n^=m^=n^=m; long long ans=0; for(int i=1,j;i&lt;=n;i=j+1) &#123; j=std::min(n/(n/i),m/(m/i)); ans+=1LL*(mu[j]-mu[i-1])*s[n/i]*s[m/i]; &#125; printf("%lld\n",ans); &#125; return 0;&#125; Extended如何证明 Solution 中的公式？ d(ij)=\sum_{x\mid i}\sum_{y\mid j} [\gcd(x,y)=1]我们考虑把每个因子一一映射。 如果 $ij$ 的因子 $k$ 中有一个因子 $p^c$，$i$ 中有因子 $p^a$，$j$ 中有因子 $p^b$。我们规定： 如果 $c\le a$，那么在 $i$ 中选择。 如果 $c&gt;a$，那么我们把 $c$ 减去 $a$，在 $j$ 中选择 $p^{c-a}$（在 $j$ 中选择 $p^e$ 表示的是 $p^{a+e}$） 对于 $ij$ 的因子 $k$ 的其他因子同理。于是对于任何一个 $k$ 有一个唯一的映射，且每一个选择对应着唯一的 $k$。 通过如上过程，我们发现：对于 $ij$ 的因子 $k=\prod {p_i}^{c_i}$，我们不可能同时在 $i$ 和 $j$ 中选择 $p_i$（优先在 $i$ 中选择，如果不够就只在 $j$ 中选择不够的指数），故 $x$ 和 $y$ 必须互质。 等式得证。]]></content>
      <tags>
        <tag>数论</tag>
        <tag>莫比乌斯反演</tag>
        <tag>BZOJ</tag>
        <tag>数论分块</tag>
        <tag>SDOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「UVa 1347」Tour]]></title>
    <url>%2Farticles%2Fproblem-UVa-1347-Tour%2F</url>
    <content type="text"><![CDATA[Description 题目链接：UVa 1347 给定 $n$ 个点 $(x_i,y_i)$，求一条路径从最左边的点开始向右走到最右边的点，再向左走回到起点（必须严格向左向右），使得除了出发点每个点恰好经过一次。两点之间的距离为欧几里得距离。求最小路径长度，保留两位小数。 数据范围：$1\le n\le 1000$ Solution直接考虑先向右再向左走不方便思考。我们可以把题目改为：两个人同时从最左边的点出发，沿着两条不同的路径走，最后都达到最右边的点。于是我们可以用 $f_{i,j}$ 表示两个人分别走到 $i,j$ 还需要还需要走多长距离。但是如何转移呢？这种方法显然无法记录每个点是否被访问过。因此这个状态定义不当，导致转移困难 QAQ 我们修改一下状态 $f_{i,j}$ 表示 $1\sim\max(i,j)$ 都访问过，且两个人当前在 $i$ 和 $j$，还需要走的路程，可得 $f_{i,j}=f_{j,i}$，因此我们强制 $i&gt;j$。这样无论哪个人下一步只能走到标号比 $i$ 大的点。由于我们定义 $1\sim\max(i,j)$ 都访问过，所以下一步只允许一个人走到 $i+1$ 而不能到 $i+2,i+3,\cdots$，故 $f_{i,j}$ 只能转移到 $f_{i+1,j}$ 和 $f_{i+1,i}$（此处第二个人走到 $i+1$ 应该写成 $f_{i,i+1}$，但是根据定义只能写成 $f_{i+1,i}）$。 这样的转移是否会漏解呢？如果第一个人直接走到了 $i+2$，那么他再也无法到 $i+1$ 了，只能考第二个人到 $i+1$。那么我们直接让第二个人到 $i+1$ 即可，并不会漏解！ 转移方程为： f_{i,j}=\min(f_{i+1,j}+dist_{i,i+1},f_{i+1,i}+dist_{j,i+1})边界是 $f_{n-1,j}=dist_{n-1,n}+dist_{j,n}$。因为第一步一定是某个人走到了第 $2$ 个点，故答案为 $f_{2,1}+dist_{1,2}$。 以上过程中，$dist_{a,b}$ 表示点 表示点 $a$ 和 和 b$ 之间的欧几里得距离。 时间复杂度：$O(n^2)$ Code12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#define FOR(i,a,b) for(int i=a;i&lt;=b;++i)#define REP(i,a,b) for(int i=a;i&gt;=b;--i)const int N=1005;int n,x[N],y[N];double dis[N][N],f[N][N];double distance(int x1,int y1,int x2,int y2) &#123; int xx=x1-x2,yy=y1-y2; return sqrt(xx*xx+yy*yy);&#125;int main() &#123; while(~scanf("%d",&amp;n)) &#123; FOR(i,1,n) scanf("%d%d",&amp;x[i],&amp;y[i]); FOR(i,1,n) FOR(j,1,n) dis[i][j]=distance(x[i],y[i],x[j],y[j]); REP(i,n-1,1) FOR(j,1,i-1) &#123; if(i==n-1) f[n-1][j]=dis[n-1][n]+dis[j][n]; else f[i][j]=std::min(f[i+1][j]+dis[i][i+1],f[i+1][i]+dis[j][i+1]); &#125; printf("%.2lf\n",f[2][1]+dis[1][2]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法笔记」Master 定理]]></title>
    <url>%2Farticles%2Falgorithm-Master-Theorem%2F</url>
    <content type="text"><![CDATA[在算法分析中，主定理提供了用渐近符号表示许多由分治法得到的递推关系式的方法。 关系式假设有递归关系式 $T(n)=a\cdot T\left(\dfrac{n}{b}\right)+f(n)$，其中 $n$ 为问题规模，$a$ 为递推的子问题的数量，$\dfrac{n}{b}$ 为每个子问题的规模（假设基本一样），$f(n)$ 为额外需要进行的计算工作。 关系式中，$a\geqslant1$，$b&gt;1$，$f(n)$ 为函数，$T(n)$ 为非负整数。 主定理记 $c_{\text{crit}}=\log_b a$，则有如下分类讨论： 如果存在常数 $c&lt;c_{\text{crit}}$，满足 $f(n)=O(n^c)$，那么 $T(n)=\Theta(n^{c_{\text{crit}}})$ 如果存在常数 $k\geqslant 0$，满足 $f(n)=\Theta(n^{c_{\text{crit}}}\log^k n)$，那么 $T(n)=\Theta(n^{c_{\text{crit}}}\log^{k+1} n)$ 如果存在常数 $c&gt;c_{\text{crit}}$，满足 $f(n)=\Omega(n^c)$，那么 $T(n)=\Theta(f(n))$ 注意情形 $3$ 的正则条件：存在常数 $k&lt;1$ 以及充分大的 $n$，满足 $a\cdot f\left(\dfrac{n}{b}\right)\le k\cdot f(n)$]]></content>
      <tags>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JSOI 2010」连通数]]></title>
    <url>%2Farticles%2Fproblem-JSOI-2010-Number-of-Connectivity%2F</url>
    <content type="text"><![CDATA[Description 题目链接：BZOJ 2208 在一个有向图中，如果点 $u$ 可以直接或间接到达点 $v$，那么称 $(u,v)$ 是可达顶点对。现在给出一个有向图，求出其中可达顶点对的对数。 数据范围：$n\le 2000$ Solution我们很容易得到一个 $O(n^3)$ 的朴素算法：直接传递闭包！ 这个过程是可以通过 $\text{bitset}$ 优化的，因此我们可以将常数减小通过本题（貌似这道题可以直接用 $O(nm)$ 的暴力水过）。 时间复杂度：$O(n^3/32)$ Code1234567891011121314151617181920#include &lt;cstdio&gt;#include &lt;bitset&gt;const int N=2005;int n;char s[N];std::bitset&lt;N&gt; f[N];int main() &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;++i) &#123; scanf("%s",s+1); for(int j=1;j&lt;=n;++j) f[i][j]=s[j]=='1'; f[i][i]=1; &#125; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j) if(f[j][i]) f[j]|=f[i]; int ans=0; for(int i=1;i&lt;=n;++i) ans+=f[i].count(); printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>bitset</tag>
        <tag>JSOI</tag>
        <tag>传递闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SPOJ 1716」GSS3 - Can you answer these queries III]]></title>
    <url>%2Farticles%2Fproblem-SPOJ-1716-GSS3%2F</url>
    <content type="text"><![CDATA[Description 题目链接：SPOJ 1716 维护一个长度为 $n$ 的序列 $A$，进行 $m$ 次询问或操作： 0 x y：将 $A_x$ 单调修改为 $y$ 1 x y：求出 $\max\{\sum_{k=i}^j A_k\}(x\le i\le j\le y)$。 数据范围：$N,M\le 5\times 10^4$，$|A_i|\le 10^4$ Solution首先分析询问的本质：求出区间最大子段和！ 很显然我们可以使用线段树维护序列，本题的难点主要在如何进行上传操作，即$\text{push up}$。 将子树 $l$ 和 $r$ 的节点信息上传到子树 $rt$ 时，对于 $rt$ 维护的序列中，和最大的子段有两种情况： 子段不经过中点，那么 $rt$ 的答案为 $l$ 和 $r$ 的答案的最大值。 子段经过了中点。这种情况比较复杂，因为我们无法知道子树的答案所对应的序列。这也是本题的难点所在。 接下来对第 $2$ 种情况进行重点分析： 我们记 $res$ 为区间最长子段和，$sum$ 为区间和，$prel$ 和 $prer$ 分别表示从区间左端点和右端点开始的最大子段和。 考虑这些信息如何上传：$sum$ 可以直接上传，$prel[rt]=\max(prel[l],sum[l]+prel[r])$（$prer$ 同理），$res[rt]=\max(res[l],res[r],prer[l]+prel[r])$ 时间复杂度：$O(m\log n)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define lson rt&lt;&lt;1#define rson rt&lt;&lt;1|1using std::max;const int N=5e4+5;int n,m,a[N];struct Tree &#123; int prel,prer,res,sum;&#125;seg[N&lt;&lt;2];void pushup(int rt) &#123; Tree L=seg[lson],R=seg[rson]; seg[rt].sum=L.sum+R.sum; seg[rt].prel=max(L.prel,L.sum+R.prel); seg[rt].prer=max(R.prer,R.sum+L.prer); seg[rt].res=max(L.prer+R.prel,max(L.res,R.res));&#125;void build(int rt,int l,int r) &#123; if(l==r) &#123; seg[rt].prel=seg[rt].prer=seg[rt].res=seg[rt].sum=a[l]; return; &#125; int mid=(l+r)&gt;&gt;1; build(lson,l,mid); build(rson,mid+1,r); pushup(rt);&#125;void modify(int x,int rt,int l,int r,int val) &#123; if(l==r) &#123; seg[rt].prel=seg[rt].prer=seg[rt].res=seg[rt].sum=val; return; &#125; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) modify(x,lson,l,mid,val); else modify(x,rson,mid+1,r,val); pushup(rt);&#125;Tree query(int x,int y,int rt,int l,int r) &#123; if(x&lt;=l&amp;&amp;r&lt;=y) return seg[rt]; int mid=(l+r)&gt;&gt;1; if(y&lt;=mid) return query(x,y,lson,l,mid); if(mid&lt;x) return query(x,y,rson,mid+1,r); Tree L=query(x,mid,lson,l,mid),R=query(mid+1,y,rson,mid+1,r),res; res.sum=L.sum+R.sum; res.prel=max(L.prel,L.sum+R.prel); res.prer=max(R.prer,R.sum+L.prer); res.res=max(L.prer+R.prel,max(L.res,R.res)); return res;&#125;int main() &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;++i) scanf("%d",&amp;a[i]); build(1,1,n); for(scanf("%d",&amp;m);m--;) &#123; int opt,x,y; scanf("%d%d%d",&amp;opt,&amp;x,&amp;y); if(opt) printf("%d\n",query(x,y,1,1,n).res); else modify(x,1,1,n,y); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>SPOJ</tag>
        <tag>最大子段和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「TJOI2016/HEOI2016」排序]]></title>
    <url>%2Farticles%2Fproblem-TJOI-2016-HEOI-2016-Sorts%2F</url>
    <content type="text"><![CDATA[Description 题目链接：BZOJ 4552 对一个长度为 $n$ 的排列 $a$ 进行 $m$ 次局部排序： 0 l r：将区间 $[l,r]$ 中的数字进行升序排序。 1 l r：将区间 $[l,r]$ 中的数字进行降序排列。 操作结束后，需要求出 $a_p$ 的值。 数据范围：$1\le n,m\le 10^5$ Solution这题直接进行模拟排序一定超时，所以我们考虑如何在较快的时间内完成排序。 对最后 $a_q$ 的值 $x$ 进行二分，令 $v_i=[a_i&gt;x]$。此时问题转化为了判定性问题：求最后 $a_q$ 的值和 $x$ 的大小关系。 对于一个 $01$ 序列，我们可以使用线段树在 $O(\log n)$ 的时间内进行模拟排序（区间查询和覆盖）。 时间复杂度：$O(m\log^2 n)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;cstdio&gt;#define lson rt&lt;&lt;1#define rson rt&lt;&lt;1|1const int N=1e5+5;int n,m,pos,a[N],ll[N],rr[N],opt[N],seg[N&lt;&lt;2],tag[N&lt;&lt;2],v[N];void update(int rt,int l,int r,int val) &#123; seg[rt]=val*(r-l+1); tag[rt]=val;&#125;void pushup(int rt) &#123; seg[rt]=seg[lson]+seg[rson];&#125;void pushdown(int rt,int l,int r) &#123; if(tag[rt]==-1) return; int mid=(l+r)&gt;&gt;1; update(lson,l,mid,tag[rt]); update(rson,mid+1,r,tag[rt]); tag[rt]=-1;&#125;void build(int rt,int l,int r) &#123; tag[rt]=-1; if(l==r) &#123; seg[rt]=v[l]; return; &#125; int mid=(l+r)&gt;&gt;1; build(lson,l,mid); build(rson,mid+1,r); pushup(rt);&#125;void modify(int x,int y,int rt,int l,int r,int val) &#123; if(x&gt;y) return; if(x&lt;=l&amp;&amp;r&lt;=y) &#123; update(rt,l,r,val); return; &#125; pushdown(rt,l,r); int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) modify(x,y,lson,l,mid,val); if(mid&lt;y) modify(x,y,rson,mid+1,r,val); pushup(rt);&#125;int query(int x,int y,int rt,int l,int r) &#123; if(x&lt;=l&amp;&amp;r&lt;=y) return seg[rt]; pushdown(rt,l,r); int mid=(l+r)&gt;&gt;1,res=0; if(x&lt;=mid) res+=query(x,y,lson,l,mid); if(mid&lt;y) res+=query(x,y,rson,mid+1,r); return res;&#125;int check(int x) &#123; for(int i=1;i&lt;=n;++i) v[i]=(a[i]&gt;x); build(1,1,n); for(int i=1;i&lt;=m;++i) &#123; int l=ll[i],r=rr[i],o=opt[i]; int cnt1=query(l,r,1,1,n),cnt0=r-l+1-cnt1; if(o) &#123; modify(l,l+cnt1-1,1,1,n,1); modify(l+cnt1,r,1,1,n,0); &#125; else &#123; modify(l,l+cnt0-1,1,1,n,0); modify(l+cnt0,r,1,1,n,1); &#125; &#125; return query(pos,pos,1,1,n);&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=m;++i) scanf("%d%d%d",&amp;opt[i],&amp;ll[i],&amp;rr[i]); scanf("%d",&amp;pos); int l=1,r=n,ans; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(mid)) l=mid+1; else ans=mid,r=mid-1; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>BZOJ</tag>
        <tag>HEOI</tag>
        <tag>二分答案</tag>
        <tag>TJOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 3680」吊打 XXX]]></title>
    <url>%2Farticles%2Fproblem-BZOJ-3680-XXX%2F</url>
    <content type="text"><![CDATA[Description 题目链接：BZOJ 3680 给出平面中的 $n$ 个点，求这 $n$ 个点的带权类费马点（费马点：在三角形内到各个顶点距离之和最小的点）。 数据范围：$n\le 10000$ Solution显然此题可以用爬山算法或者模拟退火求解。 具体算法请见我的博客：「算法笔记」爬山算法 模拟退火 时间复杂度：$O(\text{rp})$ （乱搞算法只看人品） Code爬山算法： 123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cmath&gt;const int N=10005;int n,x[N],y[N],w[N];double ansx,ansy;void hillclimb() &#123; double t=1000; while(t&gt;1e-8) &#123; double nowx=0,nowy=0; for(int i=1;i&lt;=n;++i) &#123; double dx=x[i]-ansx,dy=y[i]-ansy; double dis=sqrt(dx*dx+dy*dy); nowx+=(x[i]-ansx)*w[i]/dis; nowy+=(y[i]-ansy)*w[i]/dis; &#125; ansx+=nowx*t,ansy+=nowy*t; if(t&gt;0.5) t*=0.5; else t*=0.97; &#125;&#125;int main() &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;++i) &#123; scanf("%d%d%d",&amp;x[i],&amp;y[i],&amp;w[i]); ansx+=x[i],ansy+=y[i]; &#125; ansx/=n,ansy/=n; hillclimb(); printf("%.3lf %.3lf\n",ansx,ansy); return 0;&#125; 模拟退火： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;const int N=10005;int n,x[N],y[N],w[N];double ansx,ansy,dis;double Rand() &#123; return (double)rand()/RAND_MAX;&#125;double calc(double xx,double yy) &#123; double res=0; for(int i=1;i&lt;=n;++i) &#123; double dx=x[i]-xx,dy=y[i]-yy; res+=sqrt(dx*dx+dy*dy)*w[i]; &#125; if(res&lt;dis) dis=res,ansx=xx,ansy=yy; return res;&#125;void simulateAnneal() &#123; double t=100000; double nowx=ansx,nowy=ansy; while(t&gt;0.001) &#123; double nxtx=nowx+t*(Rand()*2-1); double nxty=nowy+t*(Rand()*2-1); double delta=calc(nxtx,nxty)-calc(nowx,nowy); if(exp(-delta/t)&gt;Rand()) nowx=nxtx,nowy=nxty; t*=0.97; &#125; for(int i=1;i&lt;=1000;++i) &#123; double nxtx=ansx+t*(Rand()*2-1); double nxty=ansy+t*(Rand()*2-1); calc(nxtx,nxty); &#125;&#125;int main() &#123; srand(time(0)); scanf("%d",&amp;n); for(int i=1;i&lt;=n;++i) &#123; scanf("%d%d%d",&amp;x[i],&amp;y[i],&amp;w[i]); ansx+=x[i],ansy+=y[i]; &#125; ansx/=n,ansy/=n,dis=calc(ansx,ansy); simulateAnneal(); printf("%.3lf %.3lf\n",ansx,ansy); return 0;&#125;]]></content>
      <tags>
        <tag>模拟退火</tag>
        <tag>随机化</tag>
        <tag>BZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ZROI 2018」提高组十连测]]></title>
    <url>%2Farticles%2Ftraining-ZROI-2018-TG-10%2F</url>
    <content type="text"><![CDATA[蒟蒻的蜕变，神犇出现，终将与 Au 有缘！ Day1A. 「ZYB建围墙」显然，如果房子数量恰好能填充满一整个正六边形，那么在这个正六边形外面围一圈肯定是最优的。 那么我们只要考虑：在正六边形的基础上如果要增加一个房子，我们只要多使用长度为 $1$ 的墙就可以将一条边向外扩展一层（相邻两边的长度均增加 $1$，扩展的边长度减少 $1$）。 再考虑向外扩展后一层后，能多围的房子数量。假设当前正六边形的边长为 $x$，那么扩展 $6$ 次（每次扩展不同的边），每次的增加量分别是 $x-1$，$x$，$x$，$x$，$x$，$x+1$（很显然，连续扩展 $6$ 次后正好又是下一个正六边形了）。 那么，我们只要不断尝试增加边长 $x$，当 $x$ 恰好小于 $n$ 时（下一个边长围成的面积大于 $n$），贪心选择扩展次数。当围成的面积等于 $n$ 时需要特判！ 时间复杂度：$O(\sqrt{n})$ 代码 1234567891011121314151617181920#include &lt;cstdio&gt;#define quit(a) return printf("%d\n",a),0int main() &#123; int n; scanf("%d",&amp;n); for(int i=1;;++i) &#123; if(3*i*(i-1)+1==n) quit(6*i); if(3*(i+1)*i+1&gt;n) &#123; int now=3*i*(i-1)+1; int ans=6*i; if(now+(i-1)&gt;=n) quit(ans+1); else now+=i-1; if(now+i&gt;=n) quit(ans+2); else now+=i; if(now+i&gt;=n) quit(ans+3); else now+=i; if(now+i&gt;=n) quit(ans+4); else now+=i; if(now+i&gt;=n) quit(ans+5); else now+=i; if(now+(i+1)&gt;=n) quit(ans+6); else now+=i+1; &#125; &#125; return 0;&#125; B. 「ZYB和售货机」我们首先考虑一个问题：物品是否一定能被选完？ 对此，我们只考虑 $f_i\le i$ 的情况（原因会在正解中解释）。如果我们从 $i$ 向 $f_i$ 连一条有向边，这显然是一个由根是自环的树组成的森林。而且每棵树的边都是朝向根的方向的！ 有向边 $(x,y)$ 有意义当且仅当物品 $x$ 存在且 $y$ 可以被选择。因为边都是朝上的，那么我们从根向子树考虑，发现对于每个节点，其儿子肯定能把它的物品取空（因为每个儿子向父亲取物品，对应的 $a[i]$ 不变）。因此 每一个物品都能被取完。严格地说，每个非叶子节点的物品都能被取完。 如果取消 $f_i\le i$ 的限制，那么形成的有向图是若干 基环内向树（基环树且树上的边都向上）。 现在我们只要考虑这个环。如果存在环上的一个点 $x$，按下这个按钮获得的收益不如另一条连向 $f_x$ 的树边，那么我们就直接把这条环边断开。这样就化为了树的做法，统计一遍即可。 如果不存在这样的点，那么我们就找一个环边价值和树边价值的差最小的点，强制它不能选择环边，统计答案即可。 实际上，我们只要记录到每个节点的最大和次大的边。$\text{DFS}$ 过程中，默认接上最大边的值，维护最大边和次大边的差的最小值。找到环之后，我们显然要断掉环——使连向某个点的边改变（从默认的最大变成次大），此时只要减去维护的最小值即可。 时间复杂度：$O(n)$ 代码 12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int N=100005;int n,idx,mn,f[N],c[N],d[N],w[N],a[N],mx[N],secmx[N],dfn[N];long long ans;void dfs(int x) &#123; if(dfn[x]==idx) &#123; ans-=mn; return; &#125; if(dfn[x]) return; dfn[x]=idx; if(mx[x]) &#123; ans+=1LL*w[mx[x]]*a[x]; mn=std::min(mn,w[mx[x]]-w[secmx[x]]); if(mx[x]^x) dfs(mx[x]); &#125;&#125;int main() &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;++i) scanf("%d%d%d%d",&amp;f[i],&amp;c[i],&amp;d[i],&amp;a[i]); for(int i=1;i&lt;=n;++i) &#123; w[i]=d[f[i]]-c[i]; if(w[i]&lt;0) continue; if(w[i]&gt;w[mx[f[i]]]) &#123; secmx[f[i]]=mx[f[i]]; mx[f[i]]=i; &#125; else if(w[i]&gt;w[secmx[f[i]]]) &#123; secmx[f[i]]=i; &#125; &#125; for(int i=1;i&lt;=n;++i) if(!dfn[i]) mn=(1&lt;&lt;30),idx++,dfs(i); printf("%lld\n",ans); return 0;&#125; C. 「ZYB玩字符串」观察删除 $p$ 的过程，虽然一个完整的 $p$ 可能被截成若干段，但是对于夹在中间的每一段，一定是能被独立删去的。 我们用 $f[i][j]$ 表示区间 $[i,j]$ 是否合法。 如果 $len_p\mid (j-i+1)$，那么 $f[i][j]$ 表示是否能用 $p$ 把这段区间删光。 否则，$f[i][j]$ 表示多余的部分是否恰好为 $p$ 的前缀。 具体转移过程（考虑第 $j$ 个字符）： 如果它和之后的零碎字符拼成一段，那么 f[i][j]=f[i][j]\ \text{OR}\ (f[i][j-1]\ \text{AND}\ s_j=p_{(j-i)\bmod len+1}) 如果对于后面零碎部分而言，$j$ 属于夹在中间的整块，那么 f[i][j]=f[i][j]\ \text{OR}\ (f[i][j-k\times len]\ \text{AND}\ f[j-k\times len+1][j])这样的转移过程，看似复杂度是 $O(|S|^4)$ 的，但是对每个 $p$，先判断字符集的合法性，加入一些可行性或最优性剪枝，复杂度是很不满的。 时间复杂度：非常不满的 $O(|S|^4)$ 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;cstring&gt;#define FOR(i,a,b) for(int i=a;i&lt;=b;++i)using namespace std;int T,n,f[205][205],sz[305],cnt[305];string s,t;bool check(int len) &#123; memset(cnt,0,sizeof(cnt)); FOR(i,1,len) ++cnt[(int)t[i]]; FOR(i,0,300) &#123; if(!sz[i]&amp;&amp;!cnt[i]) continue; if((sz[i]&amp;&amp;!cnt[i])||sz[i]%cnt[i]) return 0; &#125; return 1;&#125;int dfs(int len,int l,int r) &#123; if(~f[l][r]) return f[l][r]; if(l&gt;r) return f[l][r]=1; for(int i=r-len;i&gt;=l;i-=len) &#123; if(dfs(len,l,i)&amp;&amp;dfs(len,i+1,r)) return f[l][r]=1; &#125; if(s[r]==t[(r-l)%len+1]) return f[l][r]=dfs(len,l,r-1); return f[l][r]=0;&#125;int main() &#123; ios::sync_with_stdio(0); cin.tie(0); for(cin&gt;&gt;T;T;--T) &#123; cin&gt;&gt;s; n=(int)s.size(); s=' '+s; memset(sz,0,sizeof(sz)); FOR(i,1,n) ++sz[(int)s[i]]; string ans=s; FOR(len,1,n) &#123; if(n%len||len&gt;(int)ans.size()-1) continue; FOR(i,1,n-len+1) &#123; t=' '+s.substr(i,len); if(!check(len)) continue; memset(f,-1,sizeof(f)); if(dfs(len,1,n)) &#123; if(t.size()&lt;ans.size()) ans=t; else if(t.size()==ans.size()) ans=min(ans,t); &#125; &#125; &#125; ans.erase(ans.begin()); cout&lt;&lt;ans&lt;&lt;'\n'; &#125; return 0;&#125; Day2 咕 Day3 咕咕 Day4 咕咕咕 Day5 咕咕咕咕]]></content>
      <tags>
        <tag>题解</tag>
        <tag>ZROI</tag>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法笔记」Splay 维护二叉查找树]]></title>
    <url>%2Farticles%2Falgorithm-Splay-1%2F</url>
    <content type="text"><![CDATA[$\text{Splay}$ 是一种二叉查找树，它通过不断将某个节点旋转到根节点，使得整棵树仍然满足二叉查找树的性质，并且保持平衡而不至于退化为链。 结构二叉查找树的性质首先肯定是一棵二叉树！ 能够在这棵树上查找某个值的性质：左儿子的值 $&lt;$ 根节点的值 $&lt;$ 右儿子的值。 节点维护信息 $rt$ $tot$ $fa[i]$ $ch[i][0/1]$ $val[i]$ $cnt[i]$ $sz[i]$ 根节点编号 节点个数 父亲 左右儿子编号 节点权值 权值出现次数 子树大小 操作基本操作 $\text{get}(x)$：判断节点 $x$ 是父亲节点的左儿子还是右儿子。 $\text{pushup}(x)​$：在改变节点 $x​$ 的位置前，将节点 $x​$ 的 $\text{size}​$ 更新。 123456bool get(int x) &#123; return x==ch[fa[x]][1];&#125;void pushup(int x) &#123; sz[x]=sz[ch[x][0]]+sz[ch[x][1]]+cnt[x];&#125; 旋转操作为了使 $\text{Splay}$ 保持平衡而进行旋转操作，旋转的本质是将某个节点上移一个位置。 旋转需要保证： 整棵 $\text{Splay}$ 的中序遍历不变（不能破坏二叉查找树的性质）。 受影响的节点维护的信息依然正确有效。 $root$ 必须指向旋转后的根节点。 在 $\text{Splay}$ 中旋转分为两种：左旋和右旋。 具体分析旋转步骤（假设需要旋转的节点为 $x$，$x$ 的父亲为 $y$，$y$ 的父亲为 $z$，以右旋为例） 将 $z$ 的某个儿子（原来 $y$ 所在的儿子位置即 get(y)）指向 $x$，且 $x$ 的父亲指向 $z$。 ch[z][get(y)]=x,fa[x]=z; 将 $y$ 的左儿子指向 $x$ 的右儿子，且 $x$ 的右儿子的父亲指向 $y$。ch[y][0]=ch[x][1],fa[ch[x][1]]=y; 将 $x$ 的右儿子指向 $y$，且 $y$ 的父亲指向 $x$。ch[x][1]=y,fa[y]=x; 分别更新 $y$ 和 $x$ 节点的信息。 pushup(y),pushup(x); 1234567void rotate(int x) &#123; int y=fa[x],z=fa[y],k=get(x); ch[z][get(y)]=x,fa[x]=z; ch[y][k]=ch[x][k^1],fa[ch[x][k^1]]=y; ch[x][k^1]=y,fa[y]=x; pushup(y),pushup(x);&#125; Splay 操作$\text{Splay}$ 规定：每访问一个节点后都要强制将其旋转到根节点。此时旋转操作具体分为 $6$ 种情况讨论（其中 $x$ 为需要旋转到根的节点）。 如果 $x$ 的父亲是根节点，直接将 $x$ 左旋或右旋（图 $1,2$）。 如果 $x$ 的父亲不是根节点，且 $x$ 和父亲的儿子类型相同，首先将其父亲左旋或右旋，然后将 $x$ 右旋或左旋（图 $3,4$）。 如果 $x$ 的父亲不是根节点，且 $x$ 和父亲的儿子类型不同，将 $x$ 左旋再右旋、或者右旋再左旋（图 $5,6$）。 分析起来一大串，其实代码一小段。大家可以自己模拟一下 $6$ 种旋转情况，就能理解 $\text{Splay}$ 的基本思想了。代码 splay(x,g) 表示把 $x$ 旋转到 $g$ 的儿子（当 $g=0$ 时表示旋转到根） 12345678void splay(int x,int g) &#123; while(fa[x]!=g) &#123; int y=fa[x]; if(fa[y]!=g) rotate(get(x)==get(y)?y:x); rotate(x); &#125; if(!g) rt=x;&#125; 查找操作我们有时在 $\text{Splay}$ 中查找一个值就需要查找操作。它的思想就是二叉查找树的查找过程，每次根据待查找的值 $x$ 与当前节点的值的关系，来判断进入左、右儿子。 123456void find(int x) &#123; if(!rt) return; int u=rt; while(x!=val[u]&amp;&amp;ch[u][x&gt;val[u]]) u=ch[u][x&gt;val[u]]; splay(u,0);&#125; 查询排名排名定义为第 $1$ 个等于 $x$ 的值的排名。那么我们只需要把 $x$ 旋转到根节点，返回根的左子树的 $sz$ 再减 $1$ 即可！（代码中没有减 $1$ 的原因是笔者在 $\text{Splay}$ 中事先插入了 $-\text{INF}$ 和 $\text{INF}$） 1234int rnk(int x) &#123; find(x); return sz[ch[rt][0]];&#125; 第 k 大数设 $x$ 为剩余排名，具体步骤如下： 如果 $x$ 大于左子树大小与当前节点大小的和，那么向右子树查找。 如果 $x$ 不大于左子树的大小，那么向左子树查找。 否则直接返回当前节点的值。 代码中将 $x$ 增加 $1$ 的原因同上。 123456789int kth(int x) &#123; ++x; int u=rt; while(1) &#123; if(x&gt;sz[ch[u][0]]+cnt[u]) x-=sz[ch[u][0]]+cnt[u],u=ch[u][1]; else if(x&lt;=sz[ch[u][0]]) u=ch[u][0]; else return u; &#125;&#125; 查询前驱前驱定义为小于 $x$ 的最大的数，那么查询前驱可以转化为：将 $x$ 旋转到根节点， 前驱即为 $x$ 的左子树中最右边的节点。注意当 $x$ 不存在时，根节点的值比 $x$ 小的情况要特判！ 1234567int pre(int x) &#123; find(x); if(val[rt]&lt;x) return rt; int u=ch[rt][0]; while(ch[u][1]) u=ch[u][1]; return u;&#125; 查询后继后继定义为大于 $x$ 的最小的数，查询方法和前驱类似：$x$ 的右子树中最左边的节点。 1234567int suc(int x) &#123; find(x); if(val[rt]&gt;x) return rt; int u=ch[rt][1]; while(ch[u][0]) u=ch[u][0]; return u;&#125; 插入操作插入操作是一个非常重要的操作：按照二叉查找树的性质向下查找，找到待插入的值 $x$ 应该插入的节点并插入。如果 $x$ 原来就存在，那么直接更新 $cnt$，否则新建一个空节点。最后别忘了 $\text{Splay}$ 操作。 1234567891011void ins(int x) &#123; int u=rt,f=0; while(x!=val[u]&amp;&amp;u) f=u,u=ch[u][x&gt;val[u]]; if(u) ++cnt[u]; else &#123; u=++idx; if(f) ch[f][x&gt;val[f]]=u; ch[u][0]=ch[u][1]=0,fa[u]=f,val[u]=x,sz[u]=cnt[u]=1; &#125; splay(u,0);&#125; 删除操作删除操作看似是一个比较复杂的操作，但是如果深入理解了 $\text{Splay}$ 的性质，其实非常简单！ 首先得到 $x$ 的前驱 $lst$ 和后继 $nxt$。将 $lst$ 旋转到根，将 $nxt$ 旋转到 $lst$ 的儿子（显然是右儿子）。 观察这个过程可以发现：如果 $x$ 存在，那么此时 $nxt$ 的左儿子一定就是 $x$，将这个节点的大小减 $1$ （需要 $\text{splay}$ 操作）或者直接删除即可。 1234567void del(int x) &#123; int lst=pre(x),nxt=suc(x); splay(lst,0),splay(nxt,lst); int u=ch[nxt][0]; if(cnt[u]&gt;1) --cnt[u],splay(u,0); else ch[nxt][0]=0;&#125; 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;cstdio&gt;const int N=1e5+5;const int INF=1&lt;&lt;30;int rt,idx,ch[N][2],sz[N],cnt[N],fa[N],val[N];bool get(int x) &#123; return ch[fa[x]][1]==x;&#125;void pushup(int x) &#123; sz[x]=sz[ch[x][0]]+sz[ch[x][1]]+cnt[x];&#125;void rotate(int x) &#123; int y=fa[x],z=fa[y],k=get(x); ch[z][get(y)]=x,fa[x]=z; ch[y][k]=ch[x][k^1],fa[ch[x][k^1]]=y; ch[x][k^1]=y,fa[y]=x; pushup(y),pushup(x);&#125;void splay(int x,int g) &#123; while(fa[x]!=g) &#123; int y=fa[x]; if(fa[y]!=g) rotate(get(x)==get(y)?y:x); rotate(x); &#125; if(!g) rt=x;&#125;void find(int x) &#123; if(!rt) return; int u=rt; while(x!=val[u]&amp;&amp;ch[u][x&gt;val[u]]) u=ch[u][x&gt;val[u]]; splay(u,0);&#125;int rnk(int x) &#123; find(x); return sz[ch[rt][0]];&#125;int kth(int x) &#123; ++x; int u=rt; while(1) &#123; if(x&gt;sz[ch[u][0]]+cnt[u]) x-=sz[ch[u][0]]+cnt[u],u=ch[u][1]; else if(x&lt;=sz[ch[u][0]]) u=ch[u][0]; else return u; &#125;&#125;int pre(int x) &#123; find(x); if(val[rt]&lt;x) return rt; int u=ch[rt][0]; while(ch[u][1]) u=ch[u][1]; return u;&#125;int suc(int x) &#123; find(x); if(val[rt]&gt;x) return rt; int u=ch[rt][1]; while(ch[u][0]) u=ch[u][0]; return u;&#125;void ins(int x) &#123; int u=rt,f=0; while(x!=val[u]&amp;&amp;u) f=u,u=ch[u][x&gt;val[u]]; if(u) ++cnt[u]; else &#123; u=++idx; if(f) ch[f][x&gt;val[f]]=u; ch[u][0]=ch[u][1]=0,fa[u]=f,val[u]=x,sz[u]=cnt[u]=1; &#125; splay(u,0);&#125;void del(int x) &#123; int lst=pre(x),nxt=suc(x); splay(lst,0),splay(nxt,lst); int u=ch[nxt][0]; if(cnt[u]&gt;1) --cnt[u],splay(u,0); else ch[nxt][0]=0,splay(nxt,0);&#125;int main() &#123; ins(-INF),ins(INF); int m; for(scanf("%d",&amp;m);m--;) &#123; int opt,x; scanf("%d%d",&amp;opt,&amp;x); switch(opt) &#123; case 1: ins(x);break; case 2: del(x);break; case 3: printf("%d\n",rnk(x));break; case 4: printf("%d\n",val[kth(x)]);break; case 5: printf("%d\n",val[pre(x)]);break; case 6: printf("%d\n",val[suc(x)]);break; &#125; &#125; return 0;&#125; 例题 「Luogu 3369」普通平衡树 「Luogu 3391」文艺平衡树 「HNOI 2002」营业额统计 「HNOI 2004」宠物收养所 习题 「CQOI2014」排序机械臂 「BZOJ 2827」千山鸟飞绝 「BZOJ 4923」K 小值查询 「HNOI 2012」永无乡 「ZJOI 2007」报表统计 「ZJOI 2006」书架 「NOI 2005」维护数列]]></content>
      <tags>
        <tag>算法笔记</tag>
        <tag>数据结构</tag>
        <tag>Splay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOI 2015」寿司晚宴]]></title>
    <url>%2Farticles%2Fproblem-NOI-2015-Sushi-Dinner%2F</url>
    <content type="text"><![CDATA[Description 题目链接：BZOJ 4197 有 $n-1$ 个寿司，第 $i$ 个寿司的美味度为 $i+1$。小 G 和小 W 每人选择一些寿司来品尝。规定一种方案为不和谐的当且仅当：小 G 和小 W 品尝的寿司中分别存在美味度为 $x$ 和 $y$ 的寿司，且 $x$ 和 $y$ 不互质。求一共有多少种方案是和谐的。 数据范围：$2\le n\le 500$ Solution问题的本质为：两个人在 $2\sim n$ 中选取数字，第一个人和第二个人选择的数字的质因子集合分别为 $S_1$ 和 $S_2$，满足 $S_1\cap S_2=\varnothing$ 的选择方案数。 $30\ \text{pts}\quad n\le 30$注意到 $30$ 以内的质数只有 $10$ 个，考虑使用状压 $\text{DP}$ 计算答案。可以将每个数分解质因数并压成二进制数 $S$（其中 $S$ 的第 $i$ 位表示是否有第 $i$ 个质因子）。 设 $f[i][S_1][S_2]$ 表示考虑到第 $i$ 个数，第一个人选择的数的质因子集合为 $S_1$，第二个人选择的数的质因子为 $S_2$，有如下状态转移方程： $f[i][S_1|k][S_2]+=f[i-1][S_1][S_2]$（$k\cap S_2=\varnothing$） $f[i][S_1][S_2|k]+=f[i-1][S_1][S_2]$（$k\cap S_1=\varnothing$） 其中第一维可以压缩，答案为 $\sum_{S_1\cap S_2=\varnothing}f[n][S_1][S_2]$ $100\ \text{pts}\quad n\le 500$按照之前的状态压缩显然不可行，考虑如何将状态继续压缩。 注意每个数字 $x$ 至多只有一个大于 $\sqrt{x}$ 的质因子，因此我们可以将不大于 $\sqrt{x}$ 的质因子进行 $\text{DP}$，单独考虑大于 $\sqrt{x}$ 的质因子。 小于 $\sqrt{x}_{\max}=\sqrt{500}\approx 22.4$ 的质因子只有 $8$ 个，于是我们对这些质因子按照一般的状压 $\text{DP}$ 进行计算。 考虑大于 $\sqrt{x}$ 的质因子 $p$，如果其中一个人选择了含有质因子 $p$ 的某个数，那么另一个人就不能选择任何含有质因子 $p$ 的数字。设 $g[k][p][S_1][S_2]$ 表示第 $k$ 个人选择了质因子 $p$，第一个人和第二个人选择的小于 $\sqrt{n}$ 的质因子集合分别为 $S_1$ 和 $S_2$，转移显然。 在计算完 $g$ 数组后，再更新 $f$ 的答案。考虑如何将两个数组合并：（稍有常识的人就能发现） $f[S_1][S_2]=g[0][S_1][S_2]+g[1][S_1][S_2]-f[S_1][S_2]-f[S_1][S_2]$ 最后减去 $f[S_1][S_2]$ 是因为两个人都不选这个集合的数的情况被统计了 $2$ 次。 时间复杂度：$O(n\cdot 2^{16})$ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N=505;const int P=8;const int prime[P]=&#123;2,3,5,7,11,13,17,19&#125;;int n,p,f[1&lt;&lt;P][1&lt;&lt;P],g[2][1&lt;&lt;P][1&lt;&lt;P];pair&lt;int,int&gt; s[N];int main() &#123; scanf("%d%d",&amp;n,&amp;p); for(int i=2;i&lt;=n;++i) &#123; int tmp=i; for(int j=0;j&lt;8;++j) while(tmp%prime[j]==0) s[i].second|=(1&lt;&lt;j),tmp/=prime[j]; s[i].first=tmp; &#125; std::sort(s+1,s+n+1); f[0][0]=1; for(int i=2;i&lt;=n;++i) &#123; if(i==2||s[i].first==1||s[i].first!=s[i-1].first) &#123; memcpy(g[0],f,sizeof(f)); memcpy(g[1],f,sizeof(f)); &#125; for(int s1=(1&lt;&lt;P)-1;s1&gt;=0;--s1) for(int s2=(1&lt;&lt;P)-1;s2&gt;=0;--s2) &#123; if(s1&amp;s2) continue; if((s2&amp;s[i].second)==0) (g[0][s1|s[i].second][s2]+=g[0][s1][s2])%=p; if((s1&amp;s[i].second)==0) (g[1][s1][s2|s[i].second]+=g[1][s1][s2])%=p; &#125; if(i==n||s[i].first==1||s[i].first!=s[i+1].first) &#123; for(int s1=(1&lt;&lt;P)-1;s1&gt;=0;--s1) for(int s2=(1&lt;&lt;P)-1;s2&gt;=0;--s2) if((s1&amp;s2)==0) f[s1][s2]=((g[0][s1][s2]+g[1][s1][s2]-f[s1][s2])%p+p)%p; &#125; &#125; int ans=0; for(int i=(1&lt;&lt;P)-1;i&gt;=0;--i) for(int j=(1&lt;&lt;P)-1;j&gt;=0;--j) if((i&amp;j)==0) (ans+=f[i][j])%=p; printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>BZOJ</tag>
        <tag>状压 DP</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法笔记」爬山算法 模拟退火]]></title>
    <url>%2Farticles%2Falgorithm-Simulate-Anneal%2F</url>
    <content type="text"><![CDATA[爬山算法和模拟退火都是基于随机化的算法，常用于求函数极值。当一个问题的方案数量极大甚至无穷时，我们一般考虑这两种算法。爬山算法和模拟退火适用于在一个大的搜寻空间内找寻问题的最优解，但是爬山算法一般只用于单峰函数。 爬山算法爬山算法每次在当前找到的最优方案 $x$ 附近寻找一个新方案（一般随机差值）。如果这个新的解 $x’$ 更优，那么转移到 $x’$ 否则不变。 这种算法对于单峰函数显然可行（你都知道是单峰函数了为什么不三分呢） 但是对于多数需要求解的函数中，爬山算法很容易进入一个局部最优解，如下图（最优解为 $\color{green}{\Uparrow}$，而爬山算法可能找到的最优解为 $\color{red}{\Downarrow}$）。 模拟退火根据爬山算法的过程，我们发现：对于一个当前最优解附近的非最优解，爬山算法直接舍去了这个解。而很多情况下，我们需要去接受这个非最优解从而跳出这个局部最优解，即为模拟退火算法。 什么是退火？（选自百度百科）退火是一种金属热处理工艺，指的是将金属缓慢加热到一定温度，保持足够时间，然后以适宜速度冷却。目的是降低硬度，改善切削加工性；消除残余应力，稳定尺寸，减少变形与裂纹倾向；细化晶粒，调整组织，消除组织缺陷。准确的说，退火是一种对材料的热处理工艺，包括金属材料、非金属材料。而且新材料的退火目的也与传统金属退火存在异同。 由于退火的规律引入了更多随机因素，那么我们得到最优解的概率会大大增加。于是我们可以去模拟这个过程，将目标函数作为能量函数。 模拟退火算法描述我们定义当前温度为 $T$，新状态与已知状态（由已知状态通过随机的方式得到）之间的能量（值）差为 $\Delta E$（$\Delta E\geqslant 0$），则发生状态转移（修改最优解）的概率为 P(\Delta E)= \begin{cases} 1&\text{新状态更优}\\ e^\frac{-\Delta E}{T}&\text{新状态更劣} \end{cases}注意：我们有时为了使得到的解更有质量，会在模拟退火结束后，以当前温度在得到的解附近多次随机状态，尝试得到更优的解（其过程与模拟退火相似）。 如何退火（降温）？模拟退火时我们有三个参数：初始温度 $T_0$，降温系数 $d$，终止温度 $T_k$。其中 $T_0$ 是一个比较大的数，$d$ 是一个非常接近 $1$ 但是小于 $1$ 的数，$T_k$ 是一个接近 $0$ 的正数。 首先让温度 $T=T_0$，然后按照上述步骤进行一次转移尝试，再让 $T=d\cdot T$。当 $T&lt;T_k$ 时模拟退火过程结束，当前最优解即为最终的最优解。 引用一张 Wiki - Simulated Annealing 的图片（随着温度的降低，跳跃越来越不随机，最优解也越来越稳定）。 代码爬山算法和模拟退火代码详见：「BZOJ 3680」吊打XXX 习题 「BZOJ 3680」吊打XXX 「JSOI 2016」炸弹攻击]]></content>
      <tags>
        <tag>算法笔记</tag>
        <tag>模拟退火</tag>
        <tag>随机化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法笔记」莫比乌斯反演]]></title>
    <url>%2Farticles%2Falgorithm-Mobius-Inversion%2F</url>
    <content type="text"><![CDATA[莫比乌斯反演是数论中的重要内容。对于一些函数，如果很难直接求出它的值，而容易求出其倍数和或约数和，那么可以通过莫比乌斯反演求得原函数的值。 积性函数定义若 $\gcd(x,y)=1$ 且 $f(xy)=f(x)f(y)$，则 $f(n)$ 为积性函数。 性质若 $f(x)$ 和 $g(x)$ 均为积性函数，则以下函数也为积性函数： \begin{align*} h(x) & = f(x^p) \\ h(x) & = f^p(x) \\ h(x) & = f(x)g(x) \\ h(x) & = \sum_{d\mid x}f(d)g(\frac{x}{d}) \\ \end{align*}例子 \begin{array} \text{约数个数函数} & d(n)=\sum_{d\mid n}1 \\ \text{约数和函数} & \sigma(n)=\sum_{d\mid n}d \\ \text{约数}\ k\ \text{次幂函数} & \sigma_k(n)=\sum_{d\mid n}d^k \\ \text{欧拉函数} & \varphi(n)=\sum_{i=1}^n [\gcd(i,n)=1] \\ \text{莫比乌斯函数}& \mu(n)= \begin{cases} 1 & n=1 \\ (-1)^k & c_{1,2,\cdots,k}=1\quad(n=\prod_{i=1}^k {p_i}^{c_i}) \\ 0 & c_i>1 \end{cases} \end{array} Dirichlet 卷积定义定义两个数论函数 $f,g$ 的 $\text{Dirichlet}$ 卷积为 (f\ast g)(n)=\sum_{d\mid n}f(d)g(\frac{n}{d})性质$\text{Dirichlet}$ 卷积满足交换律、结合律、分配律。 其中 $\varepsilon$ 为 $\text{Dirichlet}$ 卷积的单位元（任何函数卷 $\varepsilon$ 都为其本身） 例子 \begin{align*} \varepsilon=\mu\ast 1 & \Leftrightarrow\varepsilon(n)=\sum_{d\mid n}\mu(d) \\ d=1\ast 1 & \Leftrightarrow d(n)=\sum_{d\mid n}1 \\ \sigma=d\ast 1 & \Leftrightarrow\varepsilon(n)=\sum_{d\mid n}d \\ \varphi=\mu\ast\operatorname{ID} & \Leftrightarrow\varphi(n)=\sum_{d\mid n}d\cdot\mu(\frac{n}{d}) \\ \end{align*} 莫比乌斯函数定义$\mu$ 为莫比乌斯函数 性质莫比乌斯函数不但是积性函数，还有如下性质： \mu(n)= \begin{cases} 1 & n=1 \\ 0 & n\ \text{含有平方因子} \\ (-1)^k & k\ \text{为}\ n\ \text{的本质不同质因子个数} \\ \end{cases}证明 \varepsilon(n)= \begin{cases} 1 & n=1 \\ 0 & n\neq 1 \\ \end{cases}其中 $\varepsilon(n)=\sum_{d\mid n}\mu(d)$ 即 $\varepsilon=\mu\ast 1$ 设 n=\prod_{i=1}^k{p_i}^{c_i},n'=\prod_{i=1}^k p_i那么 \sum_{d\mid n}\mu(d)=\sum_{d\mid n'}\mu(d)=\sum_{i=0}^k C_k^i\cdot(-1)^k根据二项式定理，易知该式子的值在 $k=0$ 即 $n=1$ 时值为 $1$ 否则为 $0$，这也同时证明了 $\sum_{d\mid n}\mu(d)=[n=1]$ 反演结论：$[gcd(i,j)=1]\Leftrightarrow\sum_{d\mid\gcd(i,j)}\mu(d)$ 直接推导：如果 $\gcd(i,j)=1$，那么意味着上述结论中的 $n=1$，也就是式子的值是 $1$。反之不满足 $[\gcd(i,j)=1] $，值即为 $0$ 利用 $\varepsilon$ 函数：根据上一结论，$[\gcd(i,j)=1]\Rightarrow\varepsilon(\gcd(i,j))$，将 $\varepsilon$ 展开即可。 线性筛由于 $\mu$ 函数为积性函数，因此可以线性筛莫比乌斯函数（线性筛基本可以求所有的积性函数，尽管方法不尽相同）。 代码： 1234567891011121314void getMu() &#123; mu[1]=1; for(int i=2;i&lt;=n;++i) &#123; if(!flg[i]) p[++tot]=i,mu[i]=-1; for(int j=1;j&lt;=tot&amp;&amp;i*p[j]&lt;=n;++j) &#123; flg[i*p[j]]=1; if(i%p[j]==0) &#123; mu[i*p[j]]=0; break; &#125; mu[i*p[j]]=-mu[i]; &#125; &#125;&#125; 拓展结论 \varphi\ast 1=\operatorname{ID}\quad\operatorname{ID}\ \text{即}\ f(x)=x将 $n$ 分解质因数：$n=\prod_{i=1}^k {p_i}^{c_i}$ 首先，因为 $\varphi$ 是积性函数，故只要证明当 $n’=p^c$ 时 $\varphi\ast 1=\sum_{d\mid n’}\varphi(\frac{n’}{d})=\operatorname{ID}$ 成立即可。 因为 $p$ 是质数，于是 $d=p^0,p^1,p^2,\cdots,p^c$ 易知如下过程： \begin{align*} \varphi\ast 1 & =\sum_{d\mid n}\varphi(\frac{n}{d}) \\ & =\sum_{i=0}^c\varphi(p^i) \\ & =1+p^0\cdot(p-1)+p^1\cdot(p-1)+\cdots+p^{c-1}\cdot(p-1) \\ & =p^c \\ & =\operatorname{ID} \\ \end{align*}该式子两侧同时卷 $\mu$ 可得 $\varphi(n)=\sum_{d\mid n}d\cdot\mu(\frac{n}{d})$ 莫比乌斯反演公式设 $f(n),g(n)$ 为两个数论函数。 如果有 f(n)=\sum_{d\mid n}g(d)那么有 g(n)=\sum_{d\mid n}\mu(d)f(\frac{n}{d})证明暴力计算 \sum_{d\mid n}\mu(d)f(\frac{n}{d})=\sum_{d\mid n}\mu(d)\sum_{k\mid \frac{n}{d}}g(k)=\sum_{k\mid n}g(k)\sum_{d\mid \frac{n}{k}}\mu(d)=g(n)用 $\sum_{d\mid n}g(d)$ 来替换 $f(\frac{n}{d})$，再变换求和顺序。最后一步转为的依据：$\sum_{d\mid n}\mu(d)=[n=1]$，因此在 $\frac{n}{k}=1$ 时第二个和式的值才为 $1$。此时 $n=k$，故原式等价于 $\sum_{k\mid n}[n=k]\cdot g(k)=g(n)$ 运用卷积原问题即为：已知 $f=g\ast 1$，证明 $g=f\ast\mu$ 易知如下转化：$f\ast\mu=g\ast 1\ast\mu\Rightarrow f\ast\mu=g$（其中 $1\ast\mu=\varepsilon$） 问题形式部分题目的题解可以在本博客中找到！ 求解内容 题目 $\sum_{i=1}^n\sum_{j=1}^m[\gcd(i,j)=k]$ 「HAOI 2011」Problem B $\sum_{i=1}^n\operatorname{lcm}(i,n)$ 「SPOJ 5971」LCMSUM $\sum_{i=1}^n\sum_{j=1}^m\operatorname{lcm}(i,j)$ 「BZOJ 2154」Crash 的数字表格 $\sum_{i=1}^a\sum_{j=1}^b\sum_{k=1}^c d(ijk)$ 「Codeforces 235E」Number Challenge 维护数组 $a$，支持对所有 $\gcd(x,n)=d$ 的 $a_x$ 增加相同的值和前缀和查询 「HDU 4947」GCD Array 本文部分内容引用于 algocode 算法之路，特别鸣谢！]]></content>
      <tags>
        <tag>算法笔记</tag>
        <tag>数论</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ZROI 2018」0821 暑假普转提模拟赛]]></title>
    <url>%2Farticles%2Ftraining-ZROI-2018-0821-PT%2F</url>
    <content type="text"><![CDATA[题目列表 「A 酱的体育课」 「B 酱的无向图」 「C 酱的商店」 A. 「A 酱的体育课」因为期望具有可加性，于是我们可以考虑第 $i$ 个人在第 $j$ 个位置对答案的贡献，累加即可。 时间复杂度：$O(n^2)$ 代码 12345678910111213#include &lt;cstdio&gt;const int N=1005;int n;double u,v,c[N],d[N];int main() &#123; scanf("%d%lf%lf",&amp;n,&amp;v,&amp;u); for(int i=1;i&lt;=n;++i) scanf("%lf",&amp;c[i]); for(int i=1;i&lt;=n;++i) scanf("%lf",&amp;d[i]); double ans=0; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j) ans+=1.0*u/(c[i]-(j-1)*d[i]-v); printf("%.3lf\n",ans); return 0;&#125; B. 「B 酱的无向图」对于所有不会构成环的边建树，其维护深度和父节点。 对于会构成环的边，暴力向上爬，把环中的所有点用并查集缩点。 最后，树上没有被缩起来的点即为桥。 时间复杂度：$O(n\cdot\alpha(n))$ 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int N=500005;struct Edge &#123; int to,nxt;&#125;e[N&lt;&lt;1];int n,m,p,tot,hd[N],ff[N],fa[N],dep[N],u[N],v[N];bool mark[N],vis[N];int find(int x) &#123;return x==ff[x]?x:ff[x]=find(ff[x]);&#125;void add(int u,int v) &#123; e[++tot].to=v; e[tot].nxt=hd[u]; hd[u]=tot;&#125;void dfs(int u) &#123; dep[u]=dep[fa[u]]+1; ff[u]=u; vis[u]=1; for(int i=hd[u];i;i=e[i].nxt) &#123; int v=e[i].to; if(v!=fa[u]) fa[v]=u,dfs(v); &#125;&#125;void jump(int &amp;x) &#123;x=ff[x]=find(fa[x]);&#125;int main() &#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;p); for(int i=1;i&lt;=n;++i) ff[i]=i; for(int i=1;i&lt;=m;++i) &#123; scanf("%d%d",&amp;u[i],&amp;v[i]); int fu=find(u[i]),fv=find(v[i]); if(fu^fv) &#123; ff[fu]=fv; mark[i]=1; add(u[i],v[i]); add(v[i],u[i]); &#125; &#125; for(int i=1;i&lt;=n;++i) if(!vis[i]) dfs(i); long long sum=0,ans=1LL; for(int i=1;i&lt;=m;++i) &#123; if(mark[i]) ++sum; else &#123; int x=find(u[i]),y=find(v[i]); int loopsize=0; while(x^y) &#123;(dep[x]&lt;dep[y])?jump(y):jump(x);loopsize++;&#125; sum-=loopsize; &#125; ans=(1LL*ans*(sum+1))%p; &#125; printf("%lld\n",ans); return 0;&#125; C. 「C 酱的商店」由于在树上直接进行背包的复杂度是 $O(m^2)$ 的，所以需要进行 $\text{DP}$ 的优化。 考虑在树上的 $\text{DFS}$ 序上进行 $01$ 背包 $\text{DP}$，各种细节在代码中都有实现和写明（状态和转移等都与一般的背包问题类似）。 时间复杂度：$O(nm\log m)$（$\text{DFS}$ 序多重背包和二进制优化） 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N=4005;int n,m,tot,cnt,w[N],s[N],c[N],hd[N],en[N],b[N],f[N][N];struct Edge &#123; int to,nxt;&#125;e[N];void add(int u,int v) &#123; e[++tot].to=v; e[tot].nxt=hd[u]; hd[u]=tot;&#125;void dfs(int x) &#123; b[++cnt]=x; for(int i=hd[x];i;i=e[i].nxt) dfs(e[i].to); en[x]=cnt;&#125;void solve() &#123; memset(f,-0x3f,sizeof(f)); f[1][0]=0; for(int i=1;i&lt;=n;++i) &#123; for(int j=0;j&lt;=m;++j) f[en[b[i]]+1][j]=max(f[en[b[i]]+1][j],f[i][j]); int ss=s[b[i]]-1,cc=c[b[i]],ww=w[b[i]]; for(int j=m;j&gt;=0;--j) &#123; if(j&gt;=cc) f[i][j]=(f[i][j-cc]&gt;=0?f[i][j-cc]+ww:-(1&lt;&lt;30)); else f[i][j]=-(1&lt;&lt;30); &#125; for(int k=1;k&lt;=ss;ss-=k,k&lt;&lt;=1) for(int j=m;j&gt;=k*cc;--j) f[i][j]=max(f[i][j],f[i][j-k*cc]+k*ww); if(ss) for(int j=m;j&gt;=ss*cc;--j) f[i][j]=max(f[i][j],f[i][j-ss*cc]+ss*ww); for(int j=0;j&lt;=m;++j) f[i+1][j]=max(f[i+1][j],f[i][j]); &#125;&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int p,i=2;i&lt;=n;++i) scanf("%d",&amp;p),add(p,i); for(int i=1;i&lt;=n;++i) scanf("%d%d%d",&amp;w[i],&amp;c[i],&amp;s[i]); cnt=0; dfs(1); solve(); for(int i=1;i&lt;=m;++i) &#123; f[n+1][i]=max(f[n+1][i],f[n+1][i-1]); printf("%d%c",f[n+1][i]," \n"[i==m]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>ZROI</tag>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ZROI 2018」0820 暑假普转提模拟赛]]></title>
    <url>%2Farticles%2Ftraining-ZROI-2018-0820-PT%2F</url>
    <content type="text"><![CDATA[题目列表 「Prefix Sum」 「Bead」 「Train」 「监视 G 房」 A. 「Prefix Sum」很容易推出答案的式子 $C_{n+m-1}^{n-1}$ 考虑证明答案的正确性：对于一个数，每次做前缀和时会对后面的数做出贡献，那么问题转化为：一个数向后跳 $m$ 次（做 $m$ 次前缀和），也可以不跳，总共要跳 $n$ 步（对后面所有数字做出贡献），求方案数。（当然也可以像我一样打表找规律） 则有 $\sum_{i=1}^m x_i=n\quad(x_i\geqslant 0)$，用插板法可以求解。如果暴力计算组合数，时间复杂度为 $O(m)$ 可以得到 $60$ 分。 其实正解只是优化了答案的式子。 C_{n+m-1}^{n-1}=\frac{(n+m-1)!}{m!\times(n-1)!}=\frac{(n+m-1)\times(n+m-2)\times\cdots\times(m+1)}{(n-1)!}上述式子的分子分母项数都是 $O(n)$ 级别的。 时间复杂度：$O(n)$ 代码 1234567891011121314151617#include &lt;cstdio&gt;const int N=5005;const int P=998244353;long long pow(long long x,long long p) &#123; long long res=1LL; for(;p;p&gt;&gt;=1,x=(x*x)%P) if(p&amp;1) res=(res*x)%P; return res;&#125;int main() &#123; int n,m; scanf("%d%d",&amp;n,&amp;m); long long f1=1LL,f2=1LL; for(int i=m+1;i&lt;=n+m-1;++i) f1=(f1*i%P); for(int i=1;i&lt;n;++i) f2=(f2*i%P); printf("%lld\n",f1*pow(f2,P-2)%P); return 0;&#125; B. 「Bead」显然此题为动态规划，$f[i][j]$ 表示已经分了 $i$ 段，最后一次分割在 $j$ 的后面，状态转移方程为： $f[i][j]=\min(f[i][j],f[k][j-1]+res[k+1][i])\quad(0\le k&lt;i)$ 其中 $res[i][j]$ 表示 $i\sim j$ 的价值。初始化为 $f[0][0]=0$ 其余为 $\infty$。 很显然状态已经无法优化了，考虑转移优化。其实这个状态转移方程满足决策单调性，因此我们可以整体二分求解。 记 $nl$ 和 $nr$ 为当前状态 $l$ 和 $r$ 的最优决策段，当 $l=r$ 时直接在 $f[k-1][nl\sim nr]$ 转移即可，否则求出 $mid=(l+r)/2$ 的在当前决策的最优决策点，接下来递归求解 $[l,mid-1]$ 和 $[mid+1,r]$。 时间复杂度：$O(n\log n)$ 代码 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;const int N=100005;int n,k,a[N],c[N],f[25][N],t[N];int L,R,ans;int query(int l,int r) &#123; while(L&gt;l) ans+=c[a[--L]]++; while(R&lt;r) ans+=c[a[++R]]++; while(L&lt;l) ans-=--c[a[L++]]; while(R&gt;r) ans-=--c[a[R--]]; return ans;&#125;void solve(int k,int l,int r,int nl,int nr) &#123; if(l&gt;r) return; if(l==r) &#123; for(int i=nl;i&lt;=nr;++i) f[k][l]=std::min(f[k][l],f[k-1][i-1]+query(i,l)); return; &#125; int mid=(l+r)&gt;&gt;1; for(int i=nl;i&lt;=nr;++i) t[i]=f[k-1][i-1]+query(i,mid); int idx=0; for(int i=nl;i&lt;=nr;++i) if(!idx||t[i]&lt;t[idx]) idx=i; f[k][mid]=t[idx]; solve(k,l,mid-1,nl,idx); solve(k,mid+1,r,idx,nr);&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;++i) scanf("%d",&amp;a[i]); L=1; R=0; memset(f,0x3f,sizeof(f)); f[0][0]=0; for(int i=1;i&lt;=k;++i) solve(i,1,n,1,n); printf("%d\n",f[k][n]); return 0;&#125; C. 「Train」对于每列火车，我们可以将其路线拆成 $x\rightarrow LCA\rightarrow y$。若我们在 $x\sim LCA$ 这部分上车，那么肯定不是最优的（在到达 $x$ 之前，$x\sim LCA$ 肯定都到达过）。故我们可以将所有线路变成 $LCA\rightarrow y$，即为许多向下的链。 我们又可以把线路转化为从 $1$ 出发到 $y$（虽然 $1\sim LCA$ 并不存在，但是这样方便排序），根据新的出发时间排序（如果时间相同则按照深度排序），如果当前时间是可达的则说明这列火车可以被乘坐，于是我们把 $LCA$ 到 $y$ 的点都标记为可达的。标记时从下到上标记，遇到已经标记过的点就退出（如果 $x$ 被标记，那么 $1\sim x$ 肯定都被标记了）。 时间复杂性：$O(m\log n)$ 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;inline char in() &#123; static char buf[1000001],*p1=buf,*p2=buf; return p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++;&#125;template &lt;class Tp&gt; void read(register Tp &amp;s) &#123; s=0; register bool neg=0; register char c=in(); while(c&lt;'0'||c&gt;'9') &#123;if(c=='-')neg=1;c=in();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9') s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-48,c=in(); s=(neg?-s:s);&#125;template &lt;class Tp&gt; void write(register Tp x) &#123; if(x&lt;0) putchar('-'),x=-x; if(x&gt;9) write(x/10); putchar(x%10+48);&#125;const int N=300005;int n,m,tot,hd[N],dep[N],f[N][21];long long dis[N];bool vis[N];struct Edge &#123; int to,nxt,w;&#125;e[N&lt;&lt;1];struct Train &#123; int u,v; long long st; bool operator &lt; (const Train &amp;b) const &#123; return st==b.st?dep[u]&lt;dep[b.u]:st&lt;b.st; &#125;&#125;tr[N];void add(int u,int v,int w) &#123; e[++tot].to=v; e[tot].nxt=hd[u]; e[tot].w=w; hd[u]=tot;&#125;void dfs(int u,int fa) &#123; f[u][0]=fa; dep[u]=dep[fa]+1; for(int i=1;(1&lt;&lt;i)&lt;=dep[u];++i) f[u][i]=f[f[u][i-1]][i-1]; for(int i=hd[u];i;i=e[i].nxt) &#123; int v=e[i].to; if(v!=fa) &#123; dis[v]=dis[u]+e[i].w; dfs(v,u); &#125; &#125;&#125;int lca(int x,int y) &#123; if(dep[x]&gt;dep[y]) swap(x,y); for(int i=20;i&gt;=0;--i) if(dep[y]-(1&lt;&lt;i)&gt;=dep[x]) y=f[y][i]; if(x==y) return x; for(int i=20;i&gt;=0;--i) if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i]; return f[x][0];&#125;int main() &#123; read(n); read(m); for(int u,v,w,i=1;i&lt;n;++i) &#123; read(u); read(v); read(w); add(u,v,w); add(v,u,w); &#125; dfs(1,0); for(int u,v,t,i=1;i&lt;=m;++i) &#123; read(u); read(v); read(t); int x=lca(u,v); Train tmp; tmp.u=x; tmp.v=v; tmp.st=t+dis[u]-2*dis[x]; tr[i]=tmp; &#125; sort(tr+1,tr+m+1); vis[1]=1; for(int i=1;i&lt;=m;++i) &#123; if(vis[tr[i].u]) &#123; int x=tr[i].v; while(!vis[x]) vis[x]=1,x=f[x][0]; &#125; &#125; int ans=0; for(int i=1;i&lt;=n;++i) ans+=vis[i]; printf("%d\n",ans); for(int i=1;i&lt;=n;++i) if(vis[i]) printf("%d ",i); puts(""); return 0;&#125; D. 「监视 G 房」树形 $\text{DP}$，记 $f[i][0,1,2]$ 分别表示第 $i$ 个结点 只有父亲、只有儿子、只有自己 放摄像头的最小数量，$g[i][0,1,2]$ 为其方案数。 对于树形 $\text{DP}$ 的具体实现见下方代码（虽然没有注释，但是所有代码的含义都是字面意思）。 时间复杂度：$O(n)$ 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int N=100005;const int P=1000000007;int n,tot,hd[N],f[N][3],g[N][3];// 0:father 1:son 2:itselfstruct Edge &#123; int to,nxt;&#125;e[N&lt;&lt;1];void add(int u,int v) &#123; e[++tot].to=v; e[tot].nxt=hd[u]; hd[u]=tot;&#125;void update(int &amp;x,int val) &#123; ((x+=val)&gt;=P)&amp;&amp;(x-=P);&#125;void dfs(int u,int fa) &#123; f[u][1]=(1&lt;&lt;20); f[u][2]=1; g[u][0]=g[u][1]=g[u][2]=1; for(int i=hd[u];i;i=e[i].nxt) &#123; int v=e[i].to; if(v==fa) continue; dfs(v,u); int res=0; int mn=min(f[v][0],min(f[v][1],f[v][2])); if(f[v][0]==mn) update(res,g[v][0]); if(f[v][1]==mn) update(res,g[v][1]); if(f[v][2]==mn) update(res,g[v][2]); f[u][2]+=mn; g[u][2]=1LL*g[u][2]*res%P; res=0; mn=min(f[u][1]+min(f[v][1],f[v][2]),f[u][0]+f[v][2]); if(f[u][1]+f[v][1]==mn) update(res,g[v][1]); if(f[u][1]+f[v][2]==mn) update(res,g[v][2]); f[u][1]=mn; g[u][1]=1LL*res*g[u][1]%P; if(f[u][0]+f[v][2]==mn) update(g[u][1],1LL*g[u][0]*g[v][2]%P); f[u][0]+=f[v][1]; g[u][0]=1LL*g[u][0]*g[v][1]%P; &#125;&#125;int main() &#123; scanf("%d",&amp;n); for(int u,v,i=1;i&lt;n;++i) &#123; scanf("%d%d",&amp;u,&amp;v); add(u,v); add(v,u); &#125; dfs(1,0); if(f[1][1]&lt;f[1][2]) printf("%d\n%d\n",f[1][1],g[1][1]); else if(f[1][1]&gt;f[1][2]) printf("%d\n%d\n",f[1][2],g[1][2]); else printf("%d\n%d\n",f[1][1],(g[1][1]+g[1][2])%P); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>ZROI</tag>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HAOI 2015」树上染色]]></title>
    <url>%2Farticles%2Fproblem-HAOI-2015-Dyeing-on-Tree%2F</url>
    <content type="text"><![CDATA[Description 题目链接：BZOJ 4033 有一棵 $N$ 个节点的树（有边权），选择 $K$ 个点染成黑色，其他点染成白色。最后得到的收益为“黑点两两之间的距离和，白点两两之间的距离和”之和，要求最大化收益。 数据范围：$0\le K\le N\le 2000$ Solution显然这是一道树形 $\text{DP}$ 题目，我们设 $f[i][j]$ 表示以 $i$ 为根节点的树中染了 $j$ 个黑点获得的最大收益。 在处理完子树 $v$ 中，我们加入边 $E(u,v)$（$u$ 是 $v$ 的父亲），则 $E(u,v)$ 的贡献为 w\times\text{子树}\ u\ \text{中白点个数}\times\text{子树}\ u\ \text{外白点个数}+w\times\text{子树}\ u\ \text{中黑点个数}\times\text{子树}\ u\ \text{外黑点个数}每次树形 $\text{DP}$ 时，先把子树 $v$ 和以 $u$ 为根的树中已经计算完的部分进行 $01$ 背包合并，最后计算 $u$ 对其父亲的贡献即可（以便接下来的递归计算）。 时间复杂度：$O(N^2)$ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N=2005;int n,m,tot,hd[N],sz[N];long long f[N][N],val[N];struct Edge&#123; int to,nxt,w;&#125;e[N&lt;&lt;1];void add(int u,int v,int w) &#123; e[++tot].to=v; e[tot].w=w; e[tot].nxt=hd[u]; hd[u]=tot;&#125;void dfs(int u,int fa) &#123; f[u][0]=f[u][1]=0; sz[u]=1; for(int i=hd[u];i;i=e[i].nxt) &#123; int v=e[i].to; if(v==fa) continue; val[v]=e[i].w; dfs(v,u); for(int k=min(sz[u],m);k&gt;=0;--k) for(int j=min(sz[v],m-k);j&gt;=0;--j) f[u][k+j]=max(f[u][k+j],f[u][k]+f[v][j]); sz[u]+=sz[v]; &#125; for(int i=0;i&lt;=min(sz[u],m);++i) f[u][i]+=val[u]*(i*(m-i)+(sz[u]-i)*(n-m-(sz[u]-i)));&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int u,v,w,i=1;i&lt;n;++i) &#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); add(u,v,w); add(v,u,w); &#125; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j) f[i][j]=-(1LL&lt;&lt;60); dfs(1,0); printf("%lld\n",f[1][m]); return 0;&#125; Complexity看起来树形 $\text{DP}$ + 背包的复杂度为 $O(N^3)$，但是实际上我们发现枚举的范围是 $0\le k\le sz[v]$，$0\le j-k\le sz[u]-sz[v]$，那么总的枚举次数为 $\sum(sz[u]-sz[v])\times sz[v]$。 而 $\sum sz[v]=sz[u]$，那么复杂度为 $sz[u]^2-\sum sz[v]^2$。以此向上推，则到根节点时复杂度为 $O(N^2)$。]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>BZOJ</tag>
        <tag>HAOI</tag>
        <tag>树形 DP</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 1027D」Mouse Hunt]]></title>
    <url>%2Farticles%2Fproblem-Codeforces-1027D-Mouse-Hunt%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Codeforces 1027D 有 $n$ 间屋子和 $1$ 只老鼠，老鼠会从第 $i$ 间房子跑到 $a_i$ 间房子。在每间房子放捕鼠夹都有代价 $c_i$，而老鼠的初始位置可能是任何一个房间，为了保证抓到老鼠（无论老鼠在哪个房间，总有一种路径会经过有捕鼠夹的房子），你需要在若干房间放上捕鼠夹，求最小代价和。 数据范围：$1\le a_i\le n\le 2\cdot 10^5$，$1\le c_i\le 10^4$ Solution想象成是一张 $n$ 个点、$n$ 条边的基环图，对于每个弱连通块单独处理。 对于第 $i$ 个点，记录是否访问过，如果它还没有答案（起点在 $i$ 时已经能在某个房间抓到老鼠）则进行 $\text{DFS}$。在搜索的过程中，如果遇到了一个已经访问过的点，则说明出现了环。这个环的答案为“搜索中遇到的所有点（用栈维护）的代价最小值”。 代码中， $vis[i]$ 记录是否访问过（用于判环），$mark[i]$ 记录是否已经有答案（用于判断是否需要 $\text{DFS}$） 时间复杂度：$O(n)$ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define FOR(i,a,b) for(int i=(a);i&lt;=(b);++i)char in() &#123; static char buf[1000001],*p1=buf,*p2=buf; return p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++;&#125;template &lt;class Tp&gt; void read(register Tp &amp;s) &#123; s=0; register bool neg=0; register char c; while(!isdigit(c=in())) if(c=='-') neg=1; while(s=(s&lt;&lt;3)+(s&lt;&lt;1)+c-48,isdigit(c=in())); s=(neg?-s:s);&#125;const int N=200005;int n,a[N],c[N],tot,hd[N],las[N],sz,m,st[N],x[N];bool vis[N],mark[N];struct Edge&#123; int to,nxt;&#125;e[N&lt;&lt;1];void add(int u,int v) &#123; e[++tot].to=v; e[tot].nxt=hd[u]; hd[u]=tot;&#125;void findloop(int u) &#123; if(vis[u]) &#123; x[++m]=u; while(sz&amp;&amp;st[sz]!=u) x[++m]=st[sz],--sz; return; &#125; vis[u]=1; st[++sz]=u; findloop(a[u]);&#125;void dfs(int u) &#123; mark[u]=1; for(int i=hd[u];i;i=e[i].nxt) if(!mark[e[i].to]) dfs(e[i].to);&#125;int main() &#123; read(n); FOR(i,1,n) read(c[i]); FOR(i,1,n) &#123; read(a[i]); add(i,a[i]); add(a[i],i); &#125; int ans=0; FOR(i,1,n) &#123; if(mark[i]) continue; sz=0; m=0; findloop(i); int res=(1&lt;&lt;30); FOR(j,1,m) res=std::min(res,c[x[j]]); ans+=res; dfs(i); &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>贪心</tag>
        <tag>Codeforces</tag>
        <tag>基环树</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 1027C」Minimum Value Rectangle]]></title>
    <url>%2Farticles%2Fproblem-Codeforces-1027C-Minimum-Value-Rectangle%2F</url>
    <content type="text"><![CDATA[Description 题目链接：Codeforces 1027C 给出 $n$ 条线段，在其中选择 $4$ 条线段组成一个矩形，记 $P$ 为围成的矩形的周长，$S$ 为围成的矩形的面积，求使得 $\frac{P^2}{S}$ 最小的 $4$ 条线段。 本题 $T$ 组数据。 数据范围：$1\le T\le 10^6$，$4\le\sum n\le 10^6$，$1\le a_i\le 10^4$ Solution设 $4$ 条线段为 $a,a,b,b\ (a\le b)$，则有 $P=2\cdot(a+b)$，$S=ab$，可得 \frac{P^2}{S}=\frac{4a^2+4b^2+8ab}{ab}=4(\frac{a}{b}+\frac{b}{a})+8因此我们只需要最小化 $\frac{b}{a}$ 即可（千万注意此处 $a\le b$）。 分类讨论 如果有 $4$ 条相等的线段，肯定选取这 $4$ 条。 否则将数量不小于 $2$ 的线段从小到大排序，贪心选择相邻的线段。将当前的 $a’,b’$ 和已知的较优解 $a,b$ 比较得出更优解。 注意精度问题！我们可以将判定条件 $\frac{b’}{a’}&lt;\frac{b}{a}$ 转化为 $ab’&lt;a’b$ 即可防止精度问题。 时间复杂度：$O(Tn\log a_i)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;map&gt;#define FOR(i,a,b) for(int i=a;i&lt;=b;++i)inline char in() &#123; static char buf[10001],*p1=buf,*p2=buf; return p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,10000,stdin),p1==p2)?EOF:*p1++;&#125;template &lt;class Tp&gt; void read(register Tp &amp;s) &#123; s=0; register bool neg=0; register char c; while(!isdigit(c=in())) if(c=='-') neg=1; while(s=(s&lt;&lt;3)+(s&lt;&lt;1)+c-48,isdigit(c=in())); s=(neg?-s:s);&#125;int T,n,a[1000005];std::map&lt;int,int&gt; cnt;int main() &#123; for(read(T);T;--T) &#123; cnt.clear(); read(n); int t,m=0; FOR(i,1,n) read(t),cnt[t]++; bool flg=0; for(std::map&lt;int,int&gt;::iterator it=cnt.begin();it!=cnt.end();++it) &#123; if((*it).second&gt;=2) a[++m]=(*it).first; if((*it).second&gt;=4) &#123; flg=1; int ans=(*it).first; printf("%d %d %d %d\n",ans,ans,ans,ans); break; &#125; &#125; if(flg) continue; int x=a[1],y=a[2]; FOR(i,3,m) if(x*a[i]&lt;a[i-1]*y) x=a[i-1],y=a[i]; printf("%d %d %d %d\n",x,x,y,y); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JSOI 2016」最佳团体]]></title>
    <url>%2Farticles%2Fproblem-JSOI-2016-Best-Group%2F</url>
    <content type="text"><![CDATA[Description 题目链接：BZOJ 4753 有 $N$ 名候选人，从 $1$ 到 $N$ 编号，队长编号为 $0$，每个候选人都由一位编号比他小的候选人推荐（如果为 $0$ 则表示是队长推荐的）。队长希望招募 $K$ 个人，但是他需要保证：如果招募了 $x$，那么他的推荐人也要招募（队长总是在团队里的）。每个人都有代价 $C_i$ 和价值 $W_i$ 两个值，招募可以获得的价值为 $\frac{\sum W_i}{\sum C_i}$，你需要最大化这个值，答案保留 $3$ 位小数。 数据范围：$1\le K\le N\le 2500$，$1\le C_i,W_i\le 10^4$ Solution先做一个小转化：以 $0$ 为根节点，选择 $K+1$ 个点，其中根节点必须选择。 首先我们考虑树形 $\text{DP}$，显然是一道普通的树上背包问题。但是由于答案是一个比值，无法记录状态进行转移，所以我们引入 $01$ 分数规划。 这个式子显然是可以二分答案的，因此可以得到 \frac{\sum W_i}{\sum C_i}\geqslant x由于分母是正数，我们将式子拆开 \sum W_i\geqslant x\times \sum C_i\quad\Longrightarrow\quad\sum W_i\geqslant\sum x\times C_i可得 \sum W_i-x\times C_i\geqslant 0故我们可以二分答案 $x$，将问题转化为：每个点有 $1$ 个属性 $P_i=W_i-x\times C_i$，能否使选取的点的属性和大于等于 $0$。 设计状态：$f[i][j]$ 表示在以第 $i$ 个节点为根的子树中，选择 $j$ 个节点的最大属性和。 $\text{DP}$ 为朴素的树上背包问题，转移非常显然（注意根节点 $i$ 对应的 $j$ 至少为 $1$，我就因为这个调试了半天）。 注意初始化：$f[i][0]=0$，$f[i][1]=W_i-x\times C_i$，其余状态的值均为无穷小。 时间复杂度：$O(N^2)​$（复杂度证明见 「HAOI 2015」树上染色） Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std; const int N=2505;const double eps=1e-5;int n,m,tot,c[N],s[N],hd[N],sz[N];double w[N],f[N][N];struct Edge&#123; int to,nxt;&#125;e[N]; void add(int u,int v) &#123; e[++tot].to=v; e[tot].nxt=hd[u]; hd[u]=tot;&#125;void dfs(int x) &#123; sz[x]=1; f[x][1]=w[x]; for(int i=hd[x];i;i=e[i].nxt) &#123; int v=e[i].to; dfs(v); for(int j=sz[x];j&gt;=1;--j) for(int k=0;k&lt;=sz[v];++k) f[x][j+k]=max(f[x][j+k],f[x][j]+f[v][k]); sz[x]+=sz[v]; &#125;&#125;bool check(double x) &#123; memset(f,-10,sizeof(f)); for(int i=0;i&lt;=n;++i) f[i][0]=0; for(int i=1;i&lt;=n;++i) w[i]=(double)s[i]-x*c[i]; dfs(0); return f[0][m]&gt;=0;&#125;int main() &#123; scanf("%d%d",&amp;m,&amp;n); ++m; for(int fa,i=1;i&lt;=n;++i) &#123; scanf("%d%d%d",&amp;c[i],&amp;s[i],&amp;fa); add(fa,i); &#125; double l=0,r=1e4,ans=0; while(l+eps&lt;=r) &#123; double mid=(l+r)/2; if(check(mid)) ans=mid,l=mid+eps; else r=mid-eps; &#125; printf("%.3lf\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>BZOJ</tag>
        <tag>树形 DP</tag>
        <tag>背包</tag>
        <tag>JSOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HDU 6314」Matrix]]></title>
    <url>%2Farticles%2Fproblem-HDU-6314-Matrix%2F</url>
    <content type="text"><![CDATA[Description 题目链接：HDU 6314 对于一个 $n\times m$ 的网格，每个格子只能涂上黑色或白色。求所有涂色方案中，至少有 $A$ 行 $B$ 列为黑色的方案数（对 $998244353$ 取模）。 数据范围：$1\le n,m,A,B\le 3000$ Solution显然，行和列是相同的，于是我们可以把列去掉，记 $Ans(i)$ 表示至少有 $i$ 行全黑的方案数。 接下来考虑容斥，有以下式子 Ans(a)=\sum_{i=a}^n f_i \times C_n^i\times\text{其他格子随意填的方案数即}\ 2^{n-i}其中 $f_i$ 是 $Ans(a)$ 所对应的一个未知的容斥系数。 故我们只需要考虑如何求 $f_i$ 考虑任意一个选了 $i$ 行且这 $i$ 行全黑的方案在上面的式子里计算的次数（每个方案最后应该只会被计算一次） \sum_{j=a}^i f_j\times C_i^j=1尝试推导 $f_i$ 的递推式 \begin{align*} \sum_{i=a}^n f_i\times C_n^i & =\sum_{i=a}^{n-1}f_i\times C_n^i+f_n \\ & =\sum_{i=a}^{n-1}f_i\times(C_{n-1}^{i-1}+C_{n-1}^i)+f_n \\ & =\sum_{i=a}^{n-1}f_i\times C_{n-1}^i+\sum_{i=a}^{n-1}f_i\times C_{n-1}^{i-1}+f_n \\ & =1+\sum_{i=a}^{n-1}f_i\times C_{n-1}^{i-1}+f_n \\ & =1 \end{align*}故 f_n=-\sum_{i=a}^{n-1}f_i\times C_{n-1}^{i-1}这样我们就可以在 $O(n^2)$ 的时间内递推出容斥系数。 因为行和列的问题是等价的，所以可以用相同的方法求出列的容斥系数。 记 $Ans(a,b)$ 表示至少 $a$ 行和 $b$ 列全黑的方案数，则有 Ans(a,b)=\sum_{i=a}^n\sum_{j=b}^m f_{a,i}\times C_n^i\times f_{b,j}\times C_m^j\times\text{其他格子随意填的方案数即}\ 2^{(n-i)(m-j)}时间复杂度：$O(n^2+m^2+nm)$ Code1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;const int N=3000;const int mod=998244353;int n,m,a,b,fa[N+5],fb[N+5],p[N*N+5],c[N+5][N+5];void init() &#123; p[0]=1; for(int i=1;i&lt;=N*N;++i) &#123; p[i]=2*p[i-1]; if(p[i]&gt;=mod) p[i]-=mod; &#125; for(int i=0;i&lt;=N;++i) c[i][0]=1; for(int i=1;i&lt;=N;++i) for(int j=0;j&lt;=i;++j) &#123; c[i][j]=c[i-1][j-1]+c[i-1][j]; if(c[i][j]&gt;=mod) c[i][j]-=mod; &#125;&#125;void solve() &#123; fa[a]=1; for(int i=a+1;i&lt;=n;++i) &#123; int sum=0; for(int j=a;j&lt;i;++j) sum=(sum+1LL*c[i-1][j-1]*fa[j])%mod; fa[i]=-sum; &#125; fb[b]=1; for(int i=b+1;i&lt;=m;++i) &#123; int sum=0; for(int j=b;j&lt;i;++j) sum=(sum+1LL*c[i-1][j-1]*fb[j])%mod; fb[i]=-sum; &#125;&#125;int main() &#123; init(); while(~scanf("%d%d%d%d",&amp;n,&amp;m,&amp;a,&amp;b)) &#123; solve(); int ans=0; for(int i=a;i&lt;=n;++i) for(int j=b;j&lt;=m;++j) ans=(ans+1LL*fa[i]*c[n][i]%mod*fb[j]%mod*c[m][j]%mod*p[(n-i)*(m-j)])%mod; printf("%d\n",(ans%mod+mod)%mod); &#125; return 0;&#125; Extended上述代码的运行时间为 $700\text{ms}$ 左右，考虑如何优化。 此处，我们还是考虑只有行的情况。 如果我们强制有 $b$ 行为黑色，那么它对答案有 $\sum_{i=a}^b C_b^i$ 次的贡献（被计算进答案的次数）。 而事实上，我们想让它的贡献为（系数） $1$，考虑如下公式 \sum_{i=a}^b C_b^i\times (-1)^{i-a}\times C_{i-1}^{a-1}=1故容斥系数为 $(-1)^{i-a}\times C_{i-1}^{a-1}$ 通过优化，程序运行时间可以压到 $400\text{ms}$ 左右。 时间复杂度：$O(nm)$ 代码 1234567891011121314151617181920212223242526#include &lt;cstdio&gt;const int N=3005;const int M=9000005;const int P=998244353;int n,m,a,b,o[N],x[N],y[N],p[M],c[N][N];void init() &#123; o[0]=1; for(int i=1;i&lt;=3000;++i) o[i]=P-o[i-1]; p[0]=1; for(int i=1;i&lt;=9000000;++i) p[i]=2*p[i-1]%P; for(int i=0;i&lt;=3000;++i) &#123; c[i][0]=c[i][i]=1; for(int j=1;j&lt;i;++j) c[i][j]=(c[i-1][j-1]+c[i-1][j])%P; &#125;&#125;int main() &#123; init(); while(~scanf("%d %d %d %d",&amp;n,&amp;m,&amp;a,&amp;b)) &#123; for(int i=a;i&lt;=n;++i) x[i]=1LL*o[i-a]*c[n][i]%P*c[i-1][a-1]%P; for(int i=b;i&lt;=m;++i) y[i]=1LL*o[i-b]*c[m][i]%P*c[i-1][b-1]%P; int ans=0; for(int i=a;i&lt;=n;++i) for(int j=b;j&lt;=m;++j) ans=(ans+1LL*x[i]*y[j]%P*p[(n-i)*(m-j)])%P; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>组合数学</tag>
        <tag>容斥</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AGC 005D」~K Perm Counting]]></title>
    <url>%2Farticles%2Fproblem-AGC-005D-K-Perm-Counting%2F</url>
    <content type="text"><![CDATA[Description 题目链接：AGC 005D 给出 $n$ 和 $k$，求有多少个长度为 $n$ 的排列 $a$ 使得对于任意的 $1\le i\le n$，都满足 $|a_i-i|\neq k$。 数据范围：$2\le n\le 2000$，$1\le k&lt;n$ Solution很显然本题正着做很麻烦，于是我们考虑容斥的方法。 记 $f(i)$ 表示至少有 $i$ 个位置不满足条件的方案数，则答案为 \sum_{i=0}^n (-1)^i\times f(i)注意到对于每个数，与它的差的绝对值为 $k$ 的数不超过 $2$ 个，也就是说如果在 $x$ 和 $x+k$ 之间连边，那么会形成 $k$ 条链，每个点只能和与它有相连的边配对（如果要不满足条件，$x$ 要放在下标为 $x\pm k$ 的位置）。 考虑对每条链 $\text{DP}$，设 $f[i][j]$ 表示前 $i$ 个点选了 $j$ 个不满足条件的数的方案数。 但是注意到一点：每个数 $x$ 可以和 $x\pm k$ 配对，所以我们需要记录下当前点和下一个点是否被配对。 考虑对于每条链 $\text{DP}$，我们记 $f[i][j][p][q]$ 表示前 $i$ 个点选了 $j$ 个不满足条件的数，当前数字 $x$ 和下一个 $x+k$ 是否被选上的方案。 具体 $\text{DP}$ 转移详见代码（注意有些转移要求差为 $k$）。 时间复杂度：$O(n^2)$ Code1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#define FOR(i,a,b) for(int i=a;i&lt;=b;++i)const int N=2005;const int P=924844033;int n,k,a[N],fac[N];long long f[N][N][2][2];bool vis[N];int main() &#123; scanf("%d%d",&amp;n,&amp;k); fac[0]=1; FOR(i,1,n) fac[i]=1LL*fac[i-1]*i%P; int tot=0; FOR(i,1,n) if(!vis[i]) for(int j=i;j&lt;=n;j+=k) vis[j]=1,a[++tot]=j; f[0][0][0][0]=1; a[0]=-(1&lt;&lt;30); FOR(i,1,n) &#123; f[i][0][0][0]=1; FOR(j,1,i) &#123; f[i][j][0][0]=(f[i-1][j][1][0]+f[i-1][j][0][0]+(a[i]-a[i-1]==k)*f[i-1][j-1][0][0])%P; f[i][j][0][1]=(a[i+1]-a[i]==k)*(f[i-1][j-1][1][0]+f[i-1][j-1][0][0])%P; f[i][j][1][0]=(f[i-1][j][0][1]+f[i-1][j][1][1]+(a[i]-a[i-1]==k)*f[i-1][j-1][0][1])%P; f[i][j][1][1]=(a[i+1]-a[i]==k)*(f[i-1][j-1][0][1]+f[i-1][j-1][1][1])%P; &#125; &#125; int ans=0; FOR(i,0,n) &#123; int sum=(f[n][i][0][0]+f[n][i][0][1]+f[n][i][1][0]+f[n][i][1][1])%P; if(i&amp;1) (ans+=P-1LL*sum*fac[n-i]%P)%=P; else (ans+=1LL*sum*fac[n-i]%P)%=P; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>AtCoder</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SPOJ 5971」LCMSUM]]></title>
    <url>%2Farticles%2Fproblem-SPOJ-5971-LCMSUM%2F</url>
    <content type="text"><![CDATA[Description 题目链接：SPOJ 5971 求如下式子的值： \sum_{i=1}^n \operatorname{lcm}(i,n)本题 $T$ 组数据。 数据范围：$1\le T\le 3\times 10^5$，$1\le n\le 10^6$ Solution易得原式即 \sum_{i=1}^n \frac{i\cdot n}{\gcd(i,n)}根据 $\gcd(a,n)=1$ 时一定有 $\gcd(n-a,n)=1$ ，可将原式化为 \frac{1}{2}\cdot(\sum_{i=1}^{n-1}\frac{i\cdot n}{\gcd(i,n)}+\sum_{i=n-1}^{1}\frac{i\cdot n}{\gcd(i,n)})+n上述式子中括号内的两个 $\sum$ 对应的项相等，故又可以化为 \frac{1}{2}\cdot \sum_{i=1}^{n-1}\frac{n^2}{\gcd(i,n)}+n可以将相同的 $\gcd(i,n)$ 合并在一起计算，故只需要统计 $\gcd(i,n)=d$ 的个数。当 $\gcd(i,n)=d$ 时，$\gcd(\frac{i}{d},\frac{n}{d})=1$，所以 $\gcd(i,n)=d$ 的个数有 $\varphi(\frac{n}{d})$ 个。 故答案为 \frac{1}{2}\cdot\sum_{d|n}\frac{n^2\cdot\varphi(\frac{n}{d})}{d}+n变换求和顺序，设 $ d’=\frac{n}{d}$，式子化为 \frac{1}{2}n\cdot\sum_{d'|n}d'\cdot\varphi(d')+n设 $g(n)=\sum_{d|n} d\cdot\varphi(d)$，已知 $g$ 为积性函数，于是可以 $O(n)$ 预处理。最后枚举 $d$，统计贡献即可。 时间复杂度：$O(n\log n)$ Code1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;const int N=1000000;int tot,p[N+5],phi[N+5];long long ans[N+5];bool flg[N+5];void solve() &#123; phi[1]=1; for(int i=2;i&lt;=N;++i) &#123; if(!flg[i]) p[++tot]=i,phi[i]=i-1; for(int j=1;j&lt;=tot&amp;&amp;i*p[j]&lt;=N;++j) &#123; flg[i*p[j]]=1; if(i%p[j]==0) &#123; phi[i*p[j]]=phi[i]*p[j]; break; &#125; phi[i*p[j]]=phi[i]*(p[j]-1); &#125; &#125; for(int i=1;i&lt;=N;++i) &#123; for(int j=1;i*j&lt;=N;++j) &#123; ans[i*j]+=1LL*j*phi[j]/2; &#125; &#125; for(int i=1;i&lt;=N;++i) ans[i]=1LL*i*ans[i]+i;&#125;int main() &#123; int T,n; solve(); for(scanf("%d",&amp;T);T;--T) &#123; scanf("%d",&amp;n); printf("%lld\n",ans[n]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>莫比乌斯反演</tag>
        <tag>SPOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2154」Crash 的数字表格]]></title>
    <url>%2Farticles%2Fproblem-BZOJ-2154-Crash-Number-Table%2F</url>
    <content type="text"><![CDATA[Description 题目链接：BZOJ 2154 求如下式子的值（对 $20101009$ 取模）： \sum_{i=1}^n\sum_{j=1}^m\operatorname{lcm}(i,j)数据范围：$1\le n,m\le 10^7$ Solution易知原式等价于 \sum_{i=1}^n\sum_{j=1}^m\frac{i\cdot j}{\gcd(i,j)}枚举最大公因数 $d$，显然两个数除以 $d$ 得到的数互质 \sum_{i=1}^n\sum_{j=1}^m\sum_{d|i,d|j,\gcd(\frac{i}{d},\frac{j}{d})=1}\frac{i\cdot j}{d}非常经典的 $\gcd$ 式子的化法 \sum_{d=1}^n d\cdot\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[\gcd(i,j)=1]\cdot i\cdot j后半段式子中，出现了互质数对之积的和，为了让式子更简洁就把它拿出来单独计算。于是我们记 \operatorname{sum}(n,m)=\sum_{i=1}^n\sum_{j=1}^m [\gcd(i,j)=1]\cdot i\cdot j接下来对 $\operatorname{sum}(n,m)$ 进行化简。首先枚举约数，并将 $[\gcd(i,j)=1]$ 表示为 $\varepsilon(\gcd(i,j))$ \sum_{d=1}^n\sum_{d|i}^n\sum_{d|j}^m\mu(d)\cdot i\cdot j设 $i=i’\cdot d$，$j=j’\cdot d$（其中 $i’,j’$ 指上式中的 $i,j$ ），显然式子可以变为 \sum_{d=1}^n\mu(d)\cdot d^2\cdot\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}i\cdot j观察上式，前半段可以预处理前缀和；后半段又是一个范围内数对之和，记 g(n,m)=\sum_{i=1}^n\sum_{j=1}^m i\cdot j=\frac{n\cdot(n+1)}{2}\times\frac{m\cdot(m+1)}{2}可以 $O(1)$ 求解 至此 \operatorname{sum}(n,m)=\sum_{d=1}^n\mu(d)\cdot d^2\cdot g(\lfloor\frac{n}{d}\rfloor,\lfloor\frac{m}{d}\rfloor)我们可以 $\lfloor\frac{n}{\lfloor\frac{n}{d}\rfloor}\rfloor$ 数论分块求解 $\operatorname{sum}(n,m)$ 函数。 在求出 $\operatorname{sum}(n,m)$ 后，回到定义 $\operatorname{sum}$ 的地方，可得原式为 \sum_{d=1}^n d\cdot\operatorname{sum}(\lfloor\frac{n}{d}\rfloor,\lfloor\frac{m}{d}\rfloor)可见这又是一个可以数论分块求解的式子！ 本题除了推式子比较复杂、代码细节较多之外，是一道很好的莫比乌斯反演练习题！（上述过程中，默认 $n\le m$） 时间复杂度：$O(n+m)$（两次数论分块） Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;algorithm&gt;using std::min;const int N=1e7;const int mod=20101009;int n,m,mu[N+5],p[N/10+5],sum[N+5];bool flg[N+5];void init() &#123; mu[1]=1; int tot=0,k=min(n,m); for(int i=2;i&lt;=k;++i) &#123; if(!flg[i]) p[++tot]=i,mu[i]=-1; for(int j=1;j&lt;=tot&amp;&amp;i*p[j]&lt;=k;++j) &#123; flg[i*p[j]]=1; if(i%p[j]==0) &#123;mu[i*p[j]]=0;break;&#125; mu[i*p[j]]=-mu[i]; &#125; &#125; for(int i=1;i&lt;=k;++i) sum[i]=(sum[i-1]+1LL*i*i%mod*(mu[i]+mod))%mod;&#125;int Sum(int x,int y) &#123; return (1LL*x*(x+1)/2%mod)*(1LL*y*(y+1)/2%mod)%mod;&#125;int func(int x,int y) &#123; int res=0; for(int i=1,j;i&lt;=min(x,y);i=j+1) &#123; j=min(x/(x/i),y/(y/i)); res=(res+1LL*(sum[j]-sum[i-1]+mod)*Sum(x/i,y/i)%mod)%mod; &#125; return res;&#125;int solve(int x,int y) &#123; int res=0; for(int i=1,j;i&lt;=min(x,y);i=j+1) &#123; j=min(x/(x/i),y/(y/i)); res=(res+1LL*(j-i+1)*(i+j)/2%mod*func(x/i,y/i)%mod)%mod; &#125; return res;&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); init(); printf("%d\n",solve(n,m));&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>莫比乌斯反演</tag>
        <tag>BZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HAOI 2011」Problem B]]></title>
    <url>%2Farticles%2Fproblem-HAOI-2011-Problem-B%2F</url>
    <content type="text"><![CDATA[Description 题目链接：BZOJ 2301 求如下式子的值： \sum_{i=x}^{n}\sum_{j=y}^{m}[\gcd(i,j)=k]本题 $T$ 组数据。 数据范围：$1\le T,x,y,n,m,k\le 5\times 10^4$ Solution根据容斥原理，原式可以分成 $4$ 块来处理，每一块的式子形式都为 \sum_{i=1}^{n}\sum_{j=1}^{m}[\gcd(i,j)=k]考虑化简该式子 \sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}[\gcd(i,j)=1]因为 $\gcd(i,j)=1$ 时对答案才用贡献，于是我们可以将其替换为 $\varepsilon(\gcd(i,j))$（$\varepsilon(n)$ 当且仅当 $n=1$ 时值为 $1$ 否则为 $0$ ），故原式化为 \sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}\varepsilon(\gcd(i,j))将 $\varepsilon$ 函数展开得到 \sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}\sum_{d\mid \gcd(i,j)}\mu(d)变换求和顺序，先枚举 $d\mid gcd(i,j)$ 可得（其中 $[d\mid i]$ 表示 $i$ 是 $d$ 的倍数时对答案有 $1$ 的贡献） \sum_{d=1}^{\lfloor\frac{n}{k}\rfloor}\mu(d)\sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}[d\mid i]\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}[d\mid j]易知 $1\sim\lfloor\frac{n}{k}\rfloor$ 中 $d$ 的倍数有 $\lfloor\frac{n}{kd}\rfloor$ 个，故原式化为 \sum_{d=1}^{\lfloor\frac{n}{k}\rfloor}\mu(d) \lfloor\frac{n}{kd}\rfloor\lfloor\frac{m}{kd}\rfloor很显然，式子可以数论分块求解（过程中默认 $n\le m$）。 时间复杂度：$O(N+T\sqrt{n})$ Code1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int N=50000;int mu[N+5],p[N+5];bool flg[N+5];void init() &#123; int tot=0; mu[1]=1; for(int i=2;i&lt;=N;++i) &#123; if(!flg[i]) &#123; p[++tot]=i; mu[i]=-1; &#125; for(int j=1;j&lt;=tot&amp;&amp;i*p[j]&lt;=N;++j) &#123; flg[i*p[j]]=1; if(i%p[j]==0) &#123; mu[i*p[j]]=0; break; &#125; mu[i*p[j]]=-mu[i]; &#125; &#125; for(int i=1;i&lt;=N;++i) mu[i]+=mu[i-1];&#125;int solve(int n,int m) &#123; int res=0; for(int i=1,j;i&lt;=std::min(n,m);i=j+1) &#123; j=std::min(n/(n/i),m/(m/i)); res+=(mu[j]-mu[i-1])*(n/i)*(m/i); &#125; return res;&#125;int main() &#123; int T,a,b,c,d,k; init(); for(scanf("%d",&amp;T);T;--T) &#123; scanf("%d%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d,&amp;k); printf("%d\n",solve(b/k,d/k)-solve(b/k,(c-1)/k)-solve((a-1)/k,d/k)+solve((a-1)/k,(c-1)/k)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>莫比乌斯反演</tag>
        <tag>BZOJ</tag>
        <tag>数论分块</tag>
        <tag>HAOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Our Diary]]></title>
    <url>%2Farticles%2Fnote-Our-Diary%2F</url>
    <content type="text"><![CDATA[Press the Password to Continue... Incorrect Password! No content to display! U2FsdGVkX19aW6wzpTSigC4a8DIzqqapdBBaxlNvLd059/EapGSNYFrskj1YzjpzbfHH3Sw+N/D7EOiyy3QqJAlnFHtS9xDp2vrZpHwqC1ZmtBqqUHQRu2t+qDZ4PB6JrbQbqxVtc4mntQqzZd1khS7YT6cof8wq/1KMnbZqZ9txS5QwqZQWDFSZIzmR1btONbp6Yzo5p10rXcqpg8JMCRLokYZ740QtiFwjIRnm/fB2o9kUA3Y9GsXxReTzD51GZG6dxRJ+IrIH9PF8w6hpogub8Ch2XWmSMyxpv8bv3SKLYjcTCjBh/6qeCHkzqnbmVsBzPSii/K4C9wXp0hQbm3DEw2ooXKT0tqRsXV1zTb8Y95ynbdiAI7c6ApH/lqe/jMnORX9qJEVseodNEkQREPzKo37Pa0piYKWx8tJlQtP6xuCOxA6oK2VRI2H02wXeIsy4N7XYKJcfEilNPQsYU+60Cba2rt2g2Iwg8EYSlISrKzjrnvoZQfFJ1hNJZnX1LXX2dGkwAQtBGJgCaeI3DPopAFQcUGzYWN04Be4eX4Q0zqcHvGmVvY4/nEL8ZJRy9AESvXvb2GFnxH0QnFzhdkmBLWwjij7VLJmHb4DayyFxtGDqwnK/IwDp+mxBUjH3ferDIpqIYNYDnRu6T8ZPjaW6CRRbCno8oENHmZqZRRIaH4K5Wi/mK4dHVQKDM/R20Pa5yquiDYZxXncDvzXQCyTVjrW/4z1v4EZOBu2nP8+Vwu7BMlVF42cRK8tBMiNauWTILL9PqS7jkShk0cS6dUoXklJbWxyrsiZFSjP3m0m855d+cXifjJfgi22V2bhBfV4lzN50YBKVsJ1yb28nODat94fsbXCUkBL5HE9ZRB8VJzPLA9TgkdMRdrS1QKytxvEv8pOCNBTecK6Vlxlp2/sGRBJPtTiyBGAUEqoqGZ2Gf6hxp5PT+CoK8auy/GqKvF6rjD0qm6zEP0H7M8ClsRIKcSLnUBVyXgbZ7X2mkjl6g8He+JXG4PiH5fT3N+P3oGUKfzwzkz9VY/xC7cUdWYdEatzOtYAfAseoARPODIuEMQWp5XlwyBf5CWjMF2Q1BWrPr6PHd63GlgEBRGa6mpJgw1jnBsE5D0T3Vk12bftv+zDF4Rnu+0z7r3JZv/1a+lw5SejscqtSClA4wrRZ1jbT5zAgXOa90YD9M4OJJTZajpgYZO8bUA6ZSA/c8wY1/LrwEPMm+WAD1DIPPBuJvF72UppJo2jvlTakseWx/k6VsC3O7aYizi9MwMI4IaDExgeD8/bc+MMPn0sE1POGVKPUPOrP1LI3mVmK5o+pDMNJXwNQ8vbON06y3gEi5wer4sQ+z5JLsQbiZJLgS/zgPizaTETOZnHGri/UlbK0CNbls83TdGycSycrzlxtP7Zz8dZl+TYZ36QlKHVhIB2780bGYkqm5kX2OmVuYWNO94Fbs9UdsBsU5CoEgyIxL7SSQWb3I1yt5upu5Y9h24L8WW9Z8N65kt/p/BfxCDTfXzHDThQrWgY4+W17i/eUunKnlzBYO86+AfHEQM0zgHJg1YoGfgVStppbvR0bXebs2IHtVOalCN5Jkag8ZZVt3AhllYMU3SJu5AgoBOoj/nPELy9iLhbRRFrfJ808j9dMKWutlNF0h4+JqzY5CSNPxSxcn/1TNFdmaD2zJ2btO4u3bmDvs0XyILFVqmyg4PBvVp0Ltb5jNY2lxambGZIst8kKNoTsgkP3luGHdOoZor7EtGDaJ6O3EgPZVDNpA0jOn10hMOAl5HatnOk3xJ4OcQuYYBLHTE+eVYr2tKmO0ZF9GOa3s9Ku1+rkYM1s+JjPcrOf7f/lP/ruJSdLHcmtkg9loXQt1Eazh79M0jzYOx4jt/8FWeqry2E7HTeGcruu2Xy80FHuPOYJw0ngyd8NTWxJCJ3eifUvNI4AOIaUfwktrXJvxxyaBhIyQf7lvg8rDx8dztIw14ea0nuRxnb75Iz8j66cZxBOi0sYcWqUG14TaVqP1HCnE85W/QcoADIzVP94xpIdnQ0e7UNvjI6VANRCms45ZmmSVBBl3eqA2KoTixQDaLGbftf9MXUkaeVCbVgGHECcKI1ukJ9Pki9bBzJ31T/p13iUxxnZ0P78SgLfMMZPZGMMsSq7Zjc2gPFLdhBQAYK05MwksMTlMd9clGKOW/gYBgoeM96EexL+xISex7MlXL1FdxfDEB3zEO6iz3c4nmYNt1hgk+/zFV321HK8D2Z2YLBfrk2/aKISGKRipr+NtIXpGX+IP7ZRHnaBCky7aj/u2bShliVGH651VUoL6b+ErEI2Op3O0t955iLwL0KW/A9kl0TauJCY8vEZuPr+Vsuv1mT5JHXyv7QwC/cq9bbj4utkrRBF+CmZY2aYdfQGyBYep27yD+f0+vJqvFc7HxWJ+ovPGOZUyuCoq86k5/uMG204FeXQDD7DGUC3uKKGmwLkl5oEr6y5Cle8Lx/Qabv25nANgASD20Urx7GXXO3Pax2RVMufZgsGEM3VQHNZwVPCvzZlU6XJdqR/T4W9kIOP+IopCZL9KLgC4XKSnoAf0YvVVd0mRXuZRb93z5c3Stc66+xrXgPOKOKCGfsvQ0qhQnU85bp4Avl/W9r3c8fOxKL7w5cYU82gBd8Dt/BIxLpdpVQFb5T71rKm9/Q2/5V8rPndmUKHJcEt4t8+T7fXFoC9KMMPrd8AZUAJ1/ZqRWLgVTUr9hhnp+gA68s2gETHHz1x+HZXV6Vue+Nv0unX3c2Id+GG6c0r7kZ9gLp2XsuEe3wz/oluQWQ3d4xQfc2yq7pj1z5AL1WtTXTVfXsW1F5zzR5V7pWbdFbkpCuPoE/F3GsNhihfEz4zphU1qPtwtXRzIM2RyO6rF5yUFhcBT4gGsHKueMe4VI/pliQ3dyJDko2ZticCsKBTTSn/sCBCW5mEl1sz2GP2I9IGgIFqw9ukIbzEdEJqMkY8DlqNKLtYfRiDyljQD6+ulKXfHU5TdgI/fWvdDylgleigOVFqWu6yt1ir73KEj9lbLNyB9/2Jg3EMOJwsIh7jSD7+UenNJDtclpibyipfx9/n03rb/7xV+m6PeDcfzsGZ3id1WFtqghTqbIth2VAxpfUgeW159hXcTdSjIM+bXRcCjKnKcFHoGSngc06Pj1/LDzxTgiuZMcUEEi6ZAokcr3OfjOopn8AmOsZCaBHM7WH1QiykKbs/eE6WdUQsAoxRO7QRu2pTbnhbok1XK0OIpvh4EY5+jjM91zki8Ffe+3QE04wCwdNDf71OkcxdYFslbR4Qs4xIuqMACbuyHusIkoXoOrxQmS0zwjt9CVSddacpZ3IxwBiune7KaVY9Tq90RicbKeL3ovEYRJYMEFFpS2H0oGbfjvdWHyLV6POKVADxHzxKbFHoVJPZoxtlPri0d3/El1SWm9a7+zC5hrCB/YJsDHNju7EtYgHQeYlKZI9W/0kuKIumakFcgJW0KsxkgLamiqKBJgTsteCU/iaEunUNG8/z4puV1lJ+Bbh4SJSi4mcFZTv1MLR5syy43jE1JSuBPo32/SIT7QFroRMqpD91jGJxJVaUI57oW7p45A+qkWlm4fCr65KipDGeo3bG8JHClQ+pzKDpkcS7DZvpR7l/JQzB8tng+StAGV1xuHPZ+CWcsp+0vIhKuoHpw3KzWjd07pC87thIPvic7gq5/fdg8ZzeY+Xcz6zeGXuMpogZxMFaZb0CxGboR7Z4bVEOZLvrte38AEmE3OiSuBFM92aOMTG/xpqb1iyzRjRM7izfgp2+hey8wXixNPb5aLxnr5tg+0/r4RbJ4vZN4wkqOFZ32hzXv081Jv4fh6e33CTQp6B7VANIgpbvJPfeSz2a1t+Y9YyQxJHTkSseYouAMFF6TN5qBk3EYvqT4iDV6fQRwMvGSplDzl1x2t50G6J1TKWRbYObK09t2pu0Q2wo3cgm3aGfbEXeNKHBTJIPigIRnfYz5QlPhzGAciGYkuYDtHP0EH5rdtVHowUqdVVMRl4UeuDyMoMNzy6ZOCBUAuSHr/1MApIjjlvn7p5OkyiaTPeBBksTar5DsydNNZTfAzAack9KIzA1Y77Gnol/23Zln1mHKppDvM3iGkc2D3gqnbenPNYlMFQk6MVuvFwsJLcHFguLUG3goh9TFrMKFNderB64/2hNKqGuSTkwD4Ae7hxz/FqXyIjv4SfTdWUEw0QEB8ag911MxxLtDXd2iCXv+eXVrAnP36wILH+Fb1VfBf46ovqoSzYA9ChxkUQ5wMPzOO4jrx4nXh5mzmBr/Or6X4s8NsDsPZUzwjfR454oi7TXs0oTc3XtPZW1n5webJOwP+T9GJYu3cYGfDderV3mLrsWCgR+qTrF0PbsjnbKUxfv70xl3TcGHwXfpmyyKfa+TNDzwFudihRbm5MEwNquDzrnnYujjqNRVVAxBEH6uJsqK9oskg2qJ4eyaVWx+5C+uQMFfIoCbyNVb9OddXVsQ5Brt8skPNH7paV5lU+e6oCoUy2ASv9Cw+eYl2pahbJzyeSYZ0B0QPmdRobX6D/OjUAd7Ydps728Ww645010ImP6I71SqIU/EwZgCz80BjaBp3WYxxiDwyz5Pfi2BPqC69Xff3NAQGnUbnMLBjcCb0/2mxwGq1kwR5g1O45b997K2QXRkUZ8kI8ftbVo6B11guH+FRyi7LICK6yKMPLMzhDNLP9OgJ2ZUdwbjscTr0alBL7KGmwFuGWDQdvrfMtyVNFWlKkaU8VySgKqIxkqjcHCX6oB4uGI+9ODJPZhyvkIoSla3TrSPS0lrIXZndCjSZScOW8r+Bgro622LoS+wGBs0MBQMRoZupIqKqP/hF0k8/7AZrqGb6VgVEbUUvDMN5XWpy1XoxBUN3Sfe6DOVDGae8BT5jN7XpqRADYebfDM7Bu2EunOlxmkHziMud3UNRw9E2LglWUSbyUAEImip29t7BG/v6LOyGPgHjorJAisuKDOUKc6y7YbiTkW/Dz6ygq3T/ELEIyJNR2ks51UvP9LsH5ixwbBf6GsapIHHScJpHgusJsAjUxRR8mNBi7LAGPVKYm0IrHAu1lB9FSFZsfgrQdMMTGIi+qRsW4OeXF8htKNUoSOP2yN6KDMoqLSgj2QttUljKUEpquk3RqsUuJtaV0cnsjSMjdsPDgfXjDAScLF48utOjv0jc9dCY2iR3nnKh22me5Oz3WiuMrGC0/ufPsZvXhsTnZwE84C+iRC2oaHuBhYeZoTv+k7hxl96K3g6c6s/NWVTDqqgyLx+w7Zp589V/YcplvF+NefCIQa2CMbAyqKOB8plkothw5s75NtcXnck3z6+RIqP36A1sN9CG8A8D+wUHdEmtKBv8Tf+i31mxoR42dIj7lxZ+xRXhHKKG7ZovNhiEyfkjhN4mcBdX/Dbv7kNNgYQb/avlDy1p5/6sv5PaxAS72gyiKmdAdiZDMXw3EGPyfAb7CvL+Z3uFpAVSospR6al8vZ068X7LC0OjVZ9pFTpohzqCxTUkWG7XlKiAyyZeUZqNK4qNPeDLB2uCD0hoKd0muASFSjIvx6pMLbhYFiRjEzgBhBa7pJ3324gB0K1HWAfq5Byky4+wkbKtDW/WWeurYYXHzdVEJZrIdtTqxNjj7HAFkAKmbhOg/vydns+9okw3PLYWyS3UxTF3W7/GiHc/yWRdZZFkGHvEw7aGRC3sSOfcTn7QI3iCrQ8HIZ8/wp70UlwdfiHTOvWFJfmAN/pGHfHDCh12LbHJAH2eap5iI82wgf+WtFofo3CAqhQNvgdyU6sfTy6gphX0Rr2SGDU7BTRtDDgmSy5+7cPRJlsUOYebFHl92lUcJMm2UnKgg3JVWKjSRXWAyW0g5cCXsU/J3l+Wop6JK3OXAylXBrqmHmjTya8vOov9GxjwOa+0MV22dm0bZ5FoMd2B5lN1LHT5OPC4x0pbbWkXCJGE5Lak6Dy9sw7//D4SxskJX9/Vs9hVFyDRBW26SUzJEelZe1jvS7HxmCPGcO51vKEaM+Hm7HZf09saa+Izvsesd2mQl4qHLN1dS+f9YqcPF7bkElnNdtrkUbgAIkB7bI+m4Na3iGEdgV1xiBAOsZ/zAKMsKi2lil4O3uOaSVb9NzAJnyD/asRT2lOa6dNEa4vNvP7ezkE9HfO0sw3dvGfmhxq42e6rWHnWIuZbCnyVRzGna+Oe5NaDc1zJM/ySiI8OZG3OZvr4USjWNJWloCnAQZHFG+hLxBwszg1dVs7SERRgDkuTf7/tIHHSG5ea8RkF0vXBRCwGZv2uW2Pn5PBz+FY0IoxiJLINyqNfS75t30/tgRWoLpBsEaEKiok8oEjaXmXyALsxKLT41M0C2vKeEd1ZwhMnsc9Q0A+FUaTGoN2xxlf2tteH5UOltpGlXezOlzTGEmFxWr8p8D2oXCj90Czfv35kA0ZudvWyMJj2Jshm/7K77wXYqnfK0qry3sLEVTy/7LAkX2yU7GWc30867jFP9SxvdbW0QW6aVkvMz34wx7aQ+r2ySK2BPRj5EiAvfNC0M+DNv3ji6QMPt35jTQOAeSdKEKmk6S8F5kbzH8PsaYbAq89SSrjWF6xQB0CjEGzszvzPNzHNE8kmeBaLlw8aSa4CWKxp5UiezkXqDdjIvZZYGSyfS7qEZLwC3mRHfRgQ0qq94yv5TrhCpkQpaFyzeVGkjvc2o3Hke5BwyDj2mTII9v/Hqv3AILUT3qWEvXXSzrQ9YuSXIsxsxPNBtuX342QVec4FI/WSnNdiWKXVNRk6s8DbMINyuCH/03f6mwClTP+m+GDFvoB2Ako82UZ3CqdxJ7gJMtJYeGVUveS5vEQYkiTLDWHPtK33LKi9s2Kkgu21DX3RKCa5QLsvZcoT++QM7HHvCy3yvWwtFrttPdwqJ8+7MVwnlEau5cKRT7Xn61goUA7aOQbNFH8qfcC+Ut05aC2jOL6oQT7Sv/PtKDvYMKvAmXvJsUZnQl2c81YLWvJmI0pwdxoni8P+Ha0J6cAfKoQlg8Db2TFcy3x0M7WD58hT9CX5BnFhXR8PJ9hzVFIevJ1EHKD7n/Jsz6+4drPHREM0kNDVjM6qrUWBFRHUPE6LjHp/2CVl6NKtYcLc5vbhTuJfN5gO+X58r07J2eegBkYQ3IMoHqGv6aeral4UeQcGyBmtFLPOnVv8SbIEJICLvA+NlNKXpF0fciYkqe7GPPDn5DisRQef9LZ0Rx+5ztdcEHhpfr1G87T7EZ+GNjALwJVIYh5hFgrtUKIl0Hso68ptHeIxzXzF0Snh+XQkXh4UECiae/p9ef52w5uIAs0fvynS8vrrQK2PaWr+2eUp19c7ZHv8qhCQEB0i9D7CqEINef0S3Ge3dKIIgeqn+oNr2QIMgKK0jVuBP4TSmHTjs2CS4TNW1OKKNUjyc8yEu3PYHYzBOGMZtUHoPXsceG91/WcLMDGUwK2nVK6c9c52tuo8FmzkPcrq3nMjt9OMfn4XCzg04W7QhCe2PtaQKzp4BvsHLtmcjILRC8BboAPe5F3oO2P9NzDZFpaBsfSwDqJoKflJpT8e/LV+PUxkz9JPBcnZvaj4kf4rJyFmmBJfzAMGmdsuZod3nyUwSxrLGgnm28OAWTUq5Jn+Fart32+vrauMohDXea9cIBdfKLm453hXZ08YVn6D6WBpTW81HUFezKq1oU3urJsuH8bUxJVfIWl1vYfa0L56BlRIRG6HGV+Al66MgexOiGnGXEG0JKfNa8aJeCjah0Obj4UK7SSV2DarkErLjEg50Sr2paxUB27sbzCAgv666svcy/02izPkPElSdaWycTth3mFTL90bs7D1YbbvLUEu+6AyNbhHiYpFBSuuuaOzSKKmdu9sODiwmFstmHbqc0x36EkrsotYlHKI0kj8BDmWpYFbePJPNaJ3mxWqBGV/CLPqJFnlE+Ms3Q9DibvNYcg7BEOLC4oizJDMih+XdHZ86TXXQKuXFS2bo4mBfS6wGu8czZdSEotahiKQhi53L1Neh2OnMu5oToxkNySKSHAQ1Yrd7nMjmHOo0Gk32ATXKpJOwbkGbeCe7cNT0owuoQtQmXPE8Fn8ND5/BlcVVd0/mvWXMBoQAjMCJjDyL1sDnMlfs0Q4CLYYJzaTxpqcymRFUXhbVit03Urx4Sfip7sqGUzYRZGdo+fnS0LmBh9qL+avEe9vRwEQ9FyMndoxBA3jp6fGFcJKC0JEeARres5xPo4CAxjam4SmNGEfvqVnA8r/WbQ907mL5YiiifbpNM6FE/arcLL3urfuYLoFaEvoHV0DOJXv4hZ0Zdsz2HKGJDdHAbEem93MnjZRo4harup77oYTAtkl6FwkNVDGiifAZ2+jDnrKDVRl1SrXNbjA4Aw4bK4K1+scLd0UYEBDQox/whs33vqugtHHBGvuB/jwpH2DOMWTyCOSGNGBwcryUYnY1cm3b1CIAzr2z9rsjnvXgwwr1AtfMAc97f8nLPXqjaeGgM9PWkgMHE/F7+ziYSDvqY/K3AMzBh3S9t6pAPiLHdkDOFV06UuMs5aHQopxl/sov8tPYsklKPgrWirkkKWuW4Ba/QSqR9EdudRWnHQa3nNZL9NJ4On7LK/U9jfIoDYaHJ45vg4kPGl8khYpddRJJeLpcAewNJReTKLtXKcfcdHFeusXd4+wodL8DGa3i3HBe57FgxcNC/b1HBAVYKYJOKmjHRFYB4V5LvZvE5kJqwE2Ip+E8/gdZwGOTcHK+4R9+Fd3pVTOxsuII64fJxvpo1DYjiwf0KVZdA58ZRZp3WKKmEGWwUM92kH9+wN8xEi4urz/HGJfo1l7Yw7A57QkVHEKBBxxiGrCWxYDK+0O3VsYLNSd0S772jjsSjcGaADOuzh2CJ31l5YOmdKpIk71n9vd0jpbC91zQwBBX5dJ4vUEoUe7zPw1vnMYH8pwa9oyH4jPW/dIp7U7IzGc4YPnehb0oKnKexDFoP6TDDMMLRa59yKtYT/OV7Wcdr2kDi3Vt4ZZ30/rmJOAPOJ987CuTLBt8QGIIDAaG3UCB8cGgSbY6cGT2/uEAG2bLy/IzwpRw4IpbEGeE1fUPH3XEanIucT7yVWEHEviOXnmGqfT75vDHsJjWsKQERTUHVRIAa4sBvaT1T3LqWPDrEX6YIlk9WDE3uj0JcLeECatMoQhUQyerkSNR+6IX3qsbcwtHkW6uUG0qzQ/Fyr8XQIu6GLgKvFdY9VgCgIemmFNa0Xe1i9emRzHvyN5eRF8DiNR2kOE2LhyPgzI3koAmAxUygNHqwNSz4wTzdSrWgOAxMUrVSrPZpdxpcxnD7tw9RLgdBOSZsyLyap1Dvyym7TXX8/CTFupHdi+3spKqiTtK6uJgdHbNCTVhOw1eDrM6MD0F75yHGd9TaFyeo1X3favEfv+h+hYp2ALLBOgLHXqCs54OscPbt8WWF5Z33UAtfR6TacimCq681xk5UfWShx7bSvvW/4tU/8c/1gw7X/fo1DL2XaZSzhaAyTXU5wtYRToBU7Mn8hxCIe/WDbUVJQmpbfpmrFpuC56RPUzrgCju19CuwUbqYMfVb8p7nHTKMwkvZxXuDXFpf9BNjr4wAT6TUWdHK/n3NPnPqHh9UiKPC8Bc3qPm9UrblzrjhyUBW7s/hlLotFUnu/i8gQfYrok0TC1us2/l/kCTgoP6uQGNwSriETRmt/jY7YcKXoZzdAf3FF2wBizAeNo70AFBI9KhiuHzWK1S+gM1Ys0IHoIJOat3wbaInloVEALb9H1oyJqkaBYnnN0GPdZjcjhrMPmGhBzjYiSmbT/PcIUs40KRRUs3/ItlPlPXnmuhZq/9pywaMNZkmYLIkPYWT8hOlBEmBzqDG+BVn10IjjIAFuQJ0zixUBNJwUkLJn8Mxt6a5fNIAkH8T5ybmrKPGzj2pisz008fqrW9On7NoJj0U2jMi52qcdjKx3DV6PeJIDFyj5K19hO3rXymkVvGBhF57Rc4tWGzIie+Iaw4+Q/mz9mj6ygdjQmOSTAw3gG/zV/Rz4Ua6SriaCFGGphFKBFbHWRU0YDb8FYggWdL3NdssjJ2RcZc787HwEQ/ffe4QIQVpn0wN9tv/i8nVWJAnvnma2boeRedPFpulU8+Ez5BWkl5Z6qyQ5kNQmbUYfNuVcoTGpej8XGmMlPVvzNGmypO4HpIH9hdSHzilv0I01BlRaBDQ1LYk0H5UHG4UHme0jWka6zmdF+9YU81/4vHcTPp293W/skIP+7ZivM/hutDj4Ke/9sT/ahZ3XwdaN6AH11TMsRqoYKm/ZQOakpi7puZtJaa/HXhQJlUBqwO1z4oyZ4dos1BYe+EtX32Yu56DW4p2cdL7t5Iauw2dy78kEwHm6enSu5jhyl7gDqE0lDxlDE3XNyrEQoOQKuXqqeUdZAfqZDAxaP3D5bxVRssbGo5K44p7nsKohCUpdIxhvZU64rQP7aPlDCooHbl2Fudzg3rv+7PHnZVj9AYbqiFyYzTmnv5KGAScahGHTXkWfDeyBVXhJ6XxF5De8L/hlYtaFIs5sSDBYOFgxu45vOU41e1ZMXzLXsK+Ilftt0t4I17tTD4+W8qZTMhp9J60IklVnfNHRMwNI2Jb6IL8gxZmO7Y7m6ZAcdq4HUq2Hw570Loy0WFdxoosF+SwxPCuegtisY0m9/+SkMevJYMxq1bCM8yP6j/xBaawkFG+goA3UapkucvztjvXXmmZYp6ntQ84aTOPKIFPSUtqFg0qHS8hesO5VIeZtkmK+k3Vs40lDu5lkYz21t3B9w50GavqE2OD+TGyTpGpYdnFh/yohmSwUHimBn1q6X5c3Py598tbZ1/jGG1gUqdkATK8xXe8F1Eu+aB+AH0c2vbCj2HYJNtOIafVIC9D7hEFuXhupWUy+bofjWjHcoXs/dfvVM8z0ChBZygCzExYcZkvG5NbMAtHvHq0t0CmRerRfwftR6Tx6d+lE/EHkLaqdNE/D6c9obEDl0cd2U0h6oHakckEdnYP2SaBonLAec8b7KYKvD7YRO+yhAHyUd7qfmjN4q89KhbMhMpYYr3ngOiZy6S2SYjv11Es4HGBHsAUtBB1hkrLQLtT1uGAE+R4AKFWKLWBc3h2bFM1kP1oyzl2dZt4o9FNL/Aj0cfhRF8FzuPY8nFND9ij5i1ttNrhDCweQfh7YUJk9pSgwsW2avl/3WUypapcosoCDZzSXw/pew9/UQTmTga+a2odPbsUPATLNs5ui0EKFgeG2lyrXy03TajAUS6zgjQ2VSCPi7LU8CWaeJLF/QYCcqxWO4xjsx+XP7+KLQmeFcWOFz5aU4c8OEmMJC56etlD0qwkwmyqjfGOBwGlQqDNk4oiTL2v7WjBVBkraoap+Iyr99SHJZlzyD6blFdQKdve1xB8493fbP3HZNwc99UwWhCHDMC102DBpwZwDsk4qPgkT32h1Itc3L4NVFUzlMo/Ht64UJV4I2r5d/LR2WuhyrJ/FFocwcClKnocJJut0vENTLlrKUQbFMMAeEuAHJ70K+Uc7p0E1CF0ueXS+wm5dUDQKcCdXsrO0x8B/0qJO53LhSCuOOEuzHHIRqtC/fUk41drYLI2kVwh7CqRv12TpTf68vW8iv9p7LlpHKptJshDQL/QfvFvvD1l6xlj4+pGlzOCRjupjwqVEFOqNZhwNCh6LJRXlatWBmXTZdX0ZtWuuUBjMTc8ocnzdWEh8xMWlfy0xboPyY9rtRZocyJrVUm3OWiCZKKjpn4s1JUB+VVo+7aXkFXuBbc/K0z7ZO2njYN3Ordoywa2WkRYwW/fbD92cP7DofTgCq2IlfDRtyu1lC/X8cP3kxnUZZ8i+g/dLxI2l/TMPwiyFDWoC5f2na9bk0UbBIaNVb8TBQdWOCflC88r3EUyXdBDROOX18tyM7Z5X7bz8T3RmDJFLPHhgvbiUHnB2u9HjiPCjrUJLxY2k3OQrdyBIJcq/gt90T1hE9VV8aeVtUyP1t7evboMHDYSoMb1f6nLpZCCKLtPaw9/D3D2Al+gD3iBO69Dt36QL27PW68z3QcfwVjje/xSJxi/Bzx4mC+fDXEyUOCGnPRrS1KFRq8BbpHamorsXBIYMDqrhYTTGLKsu7esev+00k3qel8M8polLg8vMY6REC1kHd8mz5Ij+7/Vvori/yKUKsQLuLRZ/BfZBrEh8OBuwZ0v3icRIap7COlwxGzayqx/WXObtkx182SaCECpLprpyswpdsdGzvUhIxDvsIDNIXAnhBU05OVgcLyipTL46bckzgmvmn42H2toBwa4rCV7037LwOYKSsHagjMIm9U9g1mkcn9RnunewN8jGAOS3PGdojx6XPB4/Wt29Tw4panFgTVBi1Jvex7gnE50Oat/s3R+8U0B/D72h1j8aoXkV2XFFHHtaZF4Lp+ILTGZ/xwHy7H+0iOcHYdmvUb92cB8TjqXhNs1/46o4I8rB3ibjWqUCNSlA0lu7vO/Mbb4lx0kIgyX49gKxj8E8StRcSY1NaNZiERCZ+YQpEgJBI/UC7o8Wv0FlDUpFydcEPOKRJbZQGksiuJuXriV/YfUtuHvj85q07Xp8vangXgPODuY98mGGd78JQt6mC1Nhf/OuW3Y4ynrq9KrV/0R/bkXsyz36oiTi2mujujZ40A6VBg9Nk0LXv0HFaSLE+wC6dN6d2GGdFAUrUnq3oxgHc5+jDOb4be3A7Wz0/143p6lnE45l1IYcdzDwEo7P2WsC6TrcNreK7p8/o0e+u2oa3+jm48/VNlNs5pFXkhp7hOcY1Fl8lK9nC8blqqNk5dcHlwojUJ91rs7j200k3aXamWehCe1AuzDc5NfGyLZKqcyOEwoysUHolus2QVjCFurx6paJgURT7Bdcb/4//ienKbSWw6RPAzRqBg6ZcPAEg38csXm/ZGXSncFLpiT4LNn4ODfIXYlV7VXwHSNZ51MDbAfW4HuEvvkKFogyVvc5nqBh+AKrcde2LClfG4h9lzvXPEazBlMb58k2SNclokoIsBlH5A3t/+06jHrsSwVw+3Yqcf6GygQkYXprREMvQ0+JUpFKNxU39HSLr/KhXHLAPh6Z6Jw/IYWUq1eMEmwJss72f1XEM0Umxvs/DjZgMfYboWpDFj5HZ/0TOqSn5gwhVt2LCPUKpzi1Y/lShnHxu9UL+QonrxJCf0a6wKBp/D3EfB+uTVibtOjMmIzt0/VSq8kSKSbNFCNSptaEoPbDgSEIk1c/1jHZzMs6tdXuN2+hrLtTF+nPpiVbdpcZAZsU4ERL0iv8rxIKUnOjmPLML7bkOsBZNNsreEVSJMPNVHNWLa6HcUzEPWAX49nITKCIifNDKWgrR2mxYDPRYwsGuuTvuWP2+FhYfIOe78s1xQzhyMC5lFtfwGW3Dbn5CWoA3jKsyM/ioak9S4/C04Ax8Ey]]></content>
  </entry>
</search>
